# API Management Versioning - AZ-204 Exam Relevance

## How This Lab Maps to AZ-204 Exam Objectives

This lab covers critical skills for the AZ-204 exam, specifically under the domain of "Implement Azure security and integrate Azure services."

### Exam Objective: API Management

The AZ-204 exam expects you to understand how to:

- Implement API Management solutions
- Create and configure API Management instances
- Define policies for APIs
- Manage API versions and revisions

This lab directly addresses API versioning and revision management, which are key concepts you'll need to demonstrate on the exam.

### Key Concepts for the Exam

**1. Versioning Schemes**

The exam may ask you to choose the appropriate versioning scheme for a scenario. You should know these options:

- **Header**: Version specified in an HTTP header (as we used with x-api-version)
- **Query string**: Version specified as a query parameter
- **Path**: Version specified in the URL path (e.g., /v1/api/resource)

Each has trade-offs. Header versioning keeps URLs clean but requires header inspection. Query string versioning is explicit in URLs but can complicate caching. Path versioning is very visible but requires more routing configuration.

**2. Revisions vs Versions**

This is a critical distinction for the exam:

- **Revisions** are for non-breaking changes and don't require client updates
- **Versions** are for breaking changes and require client migration

You need to be able to identify scenarios that require one versus the other. For example, if a question describes adding optional parameters, that's a revision. If it describes making required parameters mandatory or changing response schemas, that's a version.

**3. Integration with App Service Deployment Slots**

The exam tests your understanding of how different Azure services work together. This lab demonstrates:

- Using deployment slots to run multiple versions of application code
- Configuring APIM backend URLs to point to different slots
- Managing traffic routing between different application versions

You should understand that deployment slots each have their own URL and can run different code independently.

**4. OpenAPI Specifications**

APIM uses OpenAPI (Swagger) specifications to define APIs. The exam may ask you about:

- Importing APIs from OpenAPI specs
- Updating existing APIs with new specifications
- The structure and purpose of OpenAPI definitions

### Common Exam Scenarios

Here are typical scenarios you might see on the exam related to this lab:

**Scenario 1**: "A company needs to add new optional fields to their API response. Existing clients should continue to work without changes. What should you do?"

Answer: Create a new revision in API Management. This maintains backward compatibility while allowing new clients to use the additional fields.

**Scenario 2**: "An API currently returns data as XML, but version 2.0 needs to return JSON instead. How should you implement this change?"

Answer: Create a new API version, not a revision, because changing the response format is a breaking change that requires client updates.

**Scenario 3**: "You need to test a new API version in production without affecting existing users. How can you accomplish this?"

Answer: Deploy the new version to an App Service deployment slot, create a new API version in APIM pointing to that slot URL, and use header-based versioning to route requests.

### Testing and Validation

The exam values practical knowledge. You should know how to:

- Test API operations in the APIM test console
- Verify that versioned APIs require the version identifier
- Confirm that revisions maintain backward compatibility
- Use tools like curl to test APIs with different version headers

### Deployment and Management Commands

Be familiar with these Azure CLI commands for the exam:

```bash
# Create App Service with Standard SKU for deployment slots
az webapp up -g resource-group --os-type Linux --sku S1 --runtime dotnetcore:6.0 -n webapp-name

# Create deployment slots
az webapp deployment slot create -g resource-group --slot slot-name -n webapp-name

# Deploy code to a specific slot
az webapp deployment source config-zip -g resource-group --src path-to-zip --slot slot-name -n webapp-name
```

You don't need to memorize exact syntax, but you should understand what these commands do and when to use them.

### Policy Configuration

While this lab focuses on versioning, remember that APIM policies are a major exam topic. In a real-world scenario, you might combine versioning with policies for:

- Rate limiting different API versions
- Transforming requests/responses differently per version
- Applying different authentication requirements to different versions

### Best Practices for the Exam

Based on this lab, remember these best practices:

1. **Version from the start**: Don't add versioning later; include it in your initial API design
2. **Use semantic versioning**: Major.Minor version numbers (1.0, 1.1, 2.0)
3. **Document changes**: Both revisions and versions should have clear descriptions
4. **Test before promoting**: Use deployment slots and revisions to test before making changes current
5. **Support multiple versions**: Don't force immediate client migration; support older versions during transition periods

### What to Focus On

When studying for the exam:

- Understand when to use revisions vs versions
- Know the three versioning schemes and their use cases
- Understand how APIM integrates with backend services
- Know how to manage API lifecycle from initial deployment through multiple versions
- Understand deployment slots and how they enable running multiple versions simultaneously

This lab gives you hands-on experience with these concepts, which is the best preparation for scenario-based exam questions.
