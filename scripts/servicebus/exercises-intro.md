We've covered Service Bus as a high-throughput, reliable message queue service for building distributed applications with decoupled components. Now let's implement fire-and-forget messaging patterns with guaranteed delivery.

We'll start by creating a Service Bus namespace and queue using the CLI. The Service Bus resource you create is actually a namespace, which is a grouping construct for multiple queues. You'll explore the options available in the portal first, seeing how the namespace name gives you a unique subdomain at servicebus.windows.net, and how the pricing tiers define maximum message size, features, and operation count. Then you'll create a namespace with the CLI using the Basic SKU, and you'll see the output includes the Service Bus endpoint showing that communication is over HTTPS. After creating the namespace, you'll create a queue within it. The Basic SKU only supports queues, but that's exactly what we need for this messaging pattern. You'll also see shared access policies at both the namespace and queue level, which let you create fine-grained permissions for apps that need to send to one queue and read from another.

Next you'll run a .NET subscriber that listens on the queue in an infinite loop. The subscriber uses the Service Bus client library and demonstrates the standard protocol called AMQP that Service Bus implements. This means Service Bus can be used as a drop-in replacement for other queue technologies like RabbitMQ. The subscriber app prints the contents of every message it receives and then acknowledges that the message has been processed. This acknowledgment is critical for reliability. You'll run the app locally with your connection string, and it will listen for messages until you shut it down. Then you'll run a publisher app that sends messages in batches, which is typically more efficient than making separate connections for individual messages. You'll see the publisher send messages and the subscriber receive them, and you can watch the metrics in the portal.

The next section on reliable and scalable messaging is where things get interesting. You'll check the last batch number processed by the subscriber, then end the subscriber while leaving the publisher running. The publisher keeps sending messages while your subscriber is offline. When you run the subscriber again, it picks up where it left off, processing all the new batches that were published while it was stopped. This demonstrates that Service Bus queues store messages until they receive a completion acknowledgement. New subscribers don't get messages that have already been completed, but they do get all the uncompleted messages in the queue, so requests don't get lost or processed twice if a subscriber fails.

You'll then run multiple instances of the subscriber at the same time, and you'll see them share the messages, taking turns to receive messages with no duplication. This shows how instances can process their own set of messages and scale horizontally to handle more load.

For the lab challenge, you'll explore what happens when there are multiple publishers and how subscribers split that work. You'll also investigate reliability by running a subscriber without acknowledging message completion. If a subscriber processes messages but doesn't acknowledge them, what happens when you quit and replace that subscriber? This helps you understand the importance of message acknowledgment in ensuring reliable message processing. When you're done, you'll clean up by deleting the resource group.
