# Azure Service Bus - AZ-204 Exam Preparation Narration Script

## Introduction

Welcome to the AZ-204 exam preparation lab for Azure Service Bus. This session focuses on the specific Service Bus topics and scenarios you'll encounter on the AZ-204: Developing Solutions for Microsoft Azure exam.

Service Bus is part of the "Connect to and Consume Azure Services" domain, which accounts for 20-25% of the exam. Understanding Service Bus queues, topics, subscriptions, and advanced messaging features is crucial for success.

This lab assumes you've completed the basic Service Bus exercises. We'll now dive into exam-specific scenarios and advanced features.

## What the AZ-204 Exam Tests

The exam evaluates your ability to:

1. **Implement Service Bus queues** - Point-to-point messaging
2. **Implement topics and subscriptions** - Pub/sub patterns with filtering
3. **Use message sessions** - FIFO ordering and stateful processing
4. **Handle dead-letter queues** - Managing unprocessable messages
5. **Defer and schedule messages** - Advanced message timing
6. **Use transactions** - Atomic operations across messages
7. **Implement duplicate detection** - Preventing duplicate processing

Let's work through each of these systematically.

## Exercise 1: Service Bus Queues - Exam Focus

### Understanding Queue Fundamentals

For the exam, you need to know:

- **Queues provide point-to-point messaging** - Each message is consumed by exactly one receiver
- **FIFO ordering** - Messages are generally delivered in the order they're sent (guaranteed with sessions)
- **PeekLock vs ReceiveAndDelete** - Two message settlement modes

### Create Namespace and Queue

Create a resource group for these exam exercises:

```bash
az group create -n labs-servicebus-az204 --tags courselabs=azure -l eastus
```

Create a Standard tier namespace (required for topics and subscriptions):

```bash
az servicebus namespace create \
  -g labs-servicebus-az204 \
  -n <servicebus-namespace> \
  --sku Standard \
  -l eastus
```

**Exam Tip:** Know the differences between tiers:
- **Basic**: Queues only, 256 KB messages, pay-per-use
- **Standard**: Adds topics/subscriptions, 256 KB messages
- **Premium**: Dedicated resources, 1 MB messages, VNet integration

Create a queue with exam-relevant settings:

```bash
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-queue \
  --max-size 1024 \
  --default-message-time-to-live P14D \
  --enable-dead-lettering-on-message-expiration true
```

**Exam Focus:** Understand these parameters:
- `max-size`: Queue capacity (1024 MB in this case)
- `default-message-time-to-live`: Messages expire after this duration (P14D = 14 days)
- `enable-dead-lettering-on-message-expiration`: Expired messages go to dead-letter queue

### Get Connection String

```bash
az servicebus namespace authorization-rule keys list \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name RootManageSharedAccessKey \
  --query primaryConnectionString -o tsv
```

This returns: `Endpoint=sb://<namespace>.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=<sas-key>`

### Send and Receive with .NET SDK

The exam expects you to understand the code patterns. Here's the essential sending pattern:

```csharp
using Azure.Messaging.ServiceBus;

string connectionString = "<servicebus-connection-string>";
string queueName = "orders-queue";

// Create client
await using var client = new ServiceBusClient(connectionString);
await using ServiceBusSender sender = client.CreateSender(queueName);

// Send single message
ServiceBusMessage message = new ServiceBusMessage("Order #12345");
message.ContentType = "application/json";
message.MessageId = Guid.NewGuid().ToString();
message.ApplicationProperties.Add("priority", "high");
await sender.SendMessageAsync(message);
```

**Exam Focus:** Know these message properties:
- `MessageId` - Unique identifier, used for duplicate detection
- `ContentType` - Indicates message format
- `ApplicationProperties` - Custom metadata for filtering
- `SessionId` - Required for session-enabled queues

### Batch Sending Pattern

For better performance:

```csharp
var messageBatch = await sender.CreateMessageBatchAsync();
for (int i = 1; i <= 10; i++)
{
    var msg = new ServiceBusMessage($"Order #{i}");
    if (!messageBatch.TryAddMessage(msg))
    {
        await sender.SendMessagesAsync(messageBatch);
        messageBatch = await sender.CreateMessageBatchAsync();
        messageBatch.TryAddMessage(msg);
    }
}
if (messageBatch.Count > 0)
{
    await sender.SendMessagesAsync(messageBatch);
}
```

**Exam Tip:** Batching reduces network overhead and improves throughput.

### Receiving Messages

```csharp
await using ServiceBusReceiver receiver = client.CreateReceiver(queueName);

// Receive single message
ServiceBusReceivedMessage receivedMessage = await receiver.ReceiveMessageAsync(
    maxWaitTime: TimeSpan.FromSeconds(5));

if (receivedMessage != null)
{
    Console.WriteLine($"Received: {receivedMessage.Body}");
    await receiver.CompleteMessageAsync(receivedMessage);
}
```

**Exam Focus:** Message settlement modes:
- **PeekLock** (default): Locks message during processing, must explicitly complete
- **ReceiveAndDelete**: Immediately removes message (no retry if processing fails)

## Exercise 2: Topics and Subscriptions - Pub/Sub Pattern

### Understanding Topics

For the exam, understand that:
- **Topics** enable publish/subscribe patterns
- **Subscriptions** are independent message receivers
- **Filters** determine which messages each subscription receives
- Each subscription gets its own copy of matching messages

### Create Topic

```bash
az servicebus topic create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name notifications
```

### Create Subscriptions with Filters

Create a subscription for high-priority messages:

```bash
az servicebus topic subscription create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --name high-priority-sub

az servicebus topic subscription rule create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --subscription-name high-priority-sub \
  --name HighPriorityFilter \
  --filter-sql-expression "priority='high'"
```

Create a subscription for all messages:

```bash
az servicebus topic subscription create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --name all-messages-sub
```

**Exam Scenario:** You need messages to be processed by multiple systems with different requirements.
**Solution:** Use topics with filtered subscriptions.

### Publish to Topic

```csharp
await using var sender = client.CreateSender("notifications");

var message = new ServiceBusMessage("System alert");
message.ApplicationProperties.Add("priority", "high");
message.ApplicationProperties.Add("region", "east");
await sender.SendMessageAsync(message);
```

### Subscribe from Specific Subscription

```csharp
await using var receiver = client.CreateReceiver(
    "notifications",
    "high-priority-sub");

var receivedMsg = await receiver.ReceiveMessageAsync();
await receiver.CompleteMessageAsync(receivedMsg);
```

### Filter Types - Exam Focus

**SQL Filters** - Flexible but slower:
```
priority='high' AND region='east'
```

**Correlation Filters** - More efficient (recommended):
```csharp
// Set in CLI with --correlation-filter parameter
```

**Boolean Filters**:
- `TrueFilter` - Receives all messages (default)
- `FalseFilter` - Receives no messages

**Exam Tip:** Correlation filters are more performant than SQL filters for simple property matching.

## Exercise 3: Message Sessions - FIFO Ordering

### Understanding Sessions

Sessions are critical for the exam. They provide:
- **FIFO guarantee** - Messages with the same session ID are delivered in order
- **Stateful processing** - Session state can be stored
- **Related message grouping** - Process related messages together

### Create Session-Enabled Queue

```bash
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-session-queue \
  --enable-session true
```

**Important:** Sessions must be enabled at queue creation - cannot be enabled later.

### Send Session Messages

```csharp
await using var sender = client.CreateSender("orders-session-queue");

string sessionId = "customer-123";

for (int i = 1; i <= 5; i++)
{
    var message = new ServiceBusMessage($"Order step {i}");
    message.SessionId = sessionId;
    await sender.SendMessageAsync(message);
}
```

All messages with the same `SessionId` are processed in order.

### Receive Session Messages

```csharp
await using var sessionReceiver = await client.AcceptSessionAsync(
    "orders-session-queue",
    sessionId);

// Get session state
byte[] state = await sessionReceiver.GetSessionStateAsync();

await foreach (var message in sessionReceiver.ReceiveMessagesAsync())
{
    Console.WriteLine($"Session {message.SessionId}: {message.Body}");
    await sessionReceiver.CompleteMessageAsync(message);
}

// Set session state
await sessionReceiver.SetSessionStateAsync(
    BinaryData.FromString("Processing completed"));
```

**Exam Scenarios for Sessions:**
1. Customer orders must be processed sequentially
2. Multi-step workflows need state tracking
3. Related events must be processed together
4. Load balancing by customer/tenant

## Exercise 4: Dead-Letter Queue - Handling Failures

### Understanding DLQ

The dead-letter queue (DLQ) is an exam favorite. Messages move to DLQ when:

1. **Max delivery count exceeded** - Message failed processing too many times
2. **Message TTL expired** - Message stayed in queue too long (if dead-lettering enabled)
3. **Explicitly dead-lettered** - Application code moves it

### Abandoning Messages

```csharp
// Abandon increments delivery count
await receiver.AbandonMessageAsync(message);
```

After max delivery count (default: 10), message moves to DLQ.

### Explicitly Dead-Lettering

```csharp
await receiver.DeadLetterMessageAsync(
    message,
    deadLetterReason: "Invalid format",
    deadLetterErrorDescription: "Missing required fields");
```

### Processing Dead-Letter Queue

```csharp
await using var dlqReceiver = client.CreateReceiver(
    "orders-queue",
    new ServiceBusReceiverOptions
    {
        SubQueue = SubQueue.DeadLetter
    });

await foreach (var dlqMessage in dlqReceiver.ReceiveMessagesAsync())
{
    Console.WriteLine($"DLQ Message: {dlqMessage.Body}");
    Console.WriteLine($"Reason: {dlqMessage.DeadLetterReason}");
    Console.WriteLine($"Error: {dlqMessage.DeadLetterErrorDescription}");
    Console.WriteLine($"Delivery count: {dlqMessage.DeliveryCount}");

    await dlqReceiver.CompleteMessageAsync(dlqMessage);
}
```

### Configure Max Delivery Count

```bash
az servicebus queue update \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-queue \
  --max-delivery-count 5
```

**Exam Tip:** Always monitor DLQ in production. Messages in DLQ require investigation.

## Exercise 5: Message Deferral

### Understanding Deferral

Deferral lets you postpone message processing:
- Message remains in queue but is skipped by normal receivers
- Must be retrieved later by sequence number
- Useful when message processing depends on other messages

### Defer a Message

```csharp
long sequenceNumber = message.SequenceNumber;
await receiver.DeferMessageAsync(message);
```

### Retrieve Deferred Message

```csharp
ServiceBusReceivedMessage deferredMessage =
    await receiver.ReceiveDeferredMessageAsync(sequenceNumber);

await receiver.CompleteMessageAsync(deferredMessage);
```

**Exam Scenario:** Messages arrive out of order, and step 2 arrives before step 1.
**Solution:** Defer step 2 until step 1 is processed.

## Exercise 6: Scheduled Messages

### Understanding Scheduling

Schedule messages to become available at a future time:
- Message sent now but not visible to receivers until scheduled time
- Useful for delayed processing, reminders, time-based workflows

### Schedule a Message

```csharp
DateTimeOffset scheduleTime = DateTimeOffset.UtcNow.AddHours(1);

long sequenceNumber = await sender.ScheduleMessageAsync(
    new ServiceBusMessage("Scheduled order"),
    scheduleTime);

Console.WriteLine($"Message scheduled. Sequence number: {sequenceNumber}");
```

### Cancel Scheduled Message

```csharp
await sender.CancelScheduledMessageAsync(sequenceNumber);
```

**Exam Scenario:** Send a reminder notification 1 hour from now.
**Solution:** Use scheduled messages.

## Exercise 7: Duplicate Detection

### Understanding Duplicate Detection

Prevents processing the same message twice:
- Based on `MessageId` property
- Detection window: 30 seconds to 7 days
- Must be enabled at queue/topic creation

### Enable Duplicate Detection

```bash
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-dedupe-queue \
  --enable-duplicate-detection true \
  --duplicate-detection-history-time-window PT10M
```

`PT10M` = 10 minutes detection window.

### Send with MessageId

```csharp
var message = new ServiceBusMessage("Order #12345");
message.MessageId = "order-12345";

await sender.SendMessageAsync(message);

// Duplicate send within detection window (rejected)
await sender.SendMessageAsync(message);
```

**Exam Tip:** Cannot enable duplicate detection on existing queue - must be set at creation.

**Exam Scenario:** Prevent duplicate order processing if publisher retries.
**Solution:** Enable duplicate detection and set MessageId to order ID.

## Exercise 8: Transactions

### Understanding Transactions

Atomic operations across multiple messages:
- All operations succeed or all fail
- Useful for workflows requiring consistency

### Transaction Example

```csharp
using System.Transactions;

await using var sender = client.CreateSender("orders-queue");
await using var receiver = client.CreateReceiver("orders-queue");

var message = await receiver.ReceiveMessageAsync();

using (var ts = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
{
    // Complete received message
    await receiver.CompleteMessageAsync(message);

    // Send new message
    await sender.SendMessageAsync(new ServiceBusMessage("Processing order"));

    // Commit transaction
    ts.Complete();
}
```

If any operation fails, the entire transaction rolls back.

**Exam Scenario:** Receive order from one queue and send confirmation to another atomically.
**Solution:** Use transactions.

## Exam Study Points - Critical Knowledge

### Service Bus vs Queue Storage

This comparison appears frequently on the exam:

| Feature | Service Bus | Queue Storage |
|---------|-------------|---------------|
| Max message size | 256 KB (Standard)<br/>1 MB (Premium) | 64 KB |
| FIFO guarantee | Yes (with sessions) | No |
| Topics/Subscriptions | Yes | No |
| Duplicate detection | Yes | No |
| Transactions | Yes | Yes |
| Dead-letter queue | Yes | No |
| Price | Higher | Lower |
| Use case | Enterprise messaging | Simple queuing |

### Message Settlement Methods

Know these for the exam:

1. **Complete** - Successfully processed, remove from queue
2. **Abandon** - Failed, return to queue (increments delivery count)
3. **Dead-letter** - Move to DLQ, unprocessable
4. **Defer** - Save for later processing by sequence number

### Common Exam Scenarios

**Scenario 1:** Need FIFO processing for customer orders
- **Answer:** Use queue with sessions enabled, set SessionId to customer ID

**Scenario 2:** Different systems need different subsets of messages
- **Answer:** Use topics with filtered subscriptions

**Scenario 3:** Handle messages that fail after 5 attempts
- **Answer:** Set max delivery count to 5 and process dead-letter queue

**Scenario 4:** Send notification in 1 hour
- **Answer:** Use scheduled messages with ScheduleMessageAsync

**Scenario 5:** Prevent duplicate order processing
- **Answer:** Enable duplicate detection at queue creation, set MessageId to order ID

**Scenario 6:** Process related messages together in order
- **Answer:** Use sessions with same SessionId for related messages

**Scenario 7:** Message arrives but dependency not ready
- **Answer:** Defer message and retrieve later by sequence number

## Best Practices - Exam Relevant

1. **Use sessions** for FIFO and stateful processing
2. **Batch messages** for better throughput
3. **Set appropriate TTL** to avoid queue buildup
4. **Monitor DLQ** regularly for failed messages
5. **Use Premium tier** for production high-throughput scenarios
6. **Implement retry logic** with exponential backoff
7. **Use correlation filters** instead of SQL for better performance
8. **Set max delivery count** to prevent poison messages
9. **Enable duplicate detection** for idempotent processing
10. **Use transactions** for atomic multi-message operations

## Security and Authentication

### Shared Access Signatures

Service Bus uses SAS for authentication:
- **RootManageSharedAccessKey** - Full access (Send, Listen, Manage)
- **Custom policies** - Fine-grained permissions

Create custom policy:

```bash
az servicebus namespace authorization-rule create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name SendOnlyPolicy \
  --rights Send
```

### Managed Identity

For production, use managed identity:

```csharp
var client = new ServiceBusClient(
    "<namespace>.servicebus.windows.net",
    new DefaultAzureCredential());
```

**Exam Tip:** Know when to use SAS vs managed identity. Managed identity is more secure (no secrets in code).

## Monitoring and Troubleshooting

### Key Metrics

Monitor these metrics for the exam scenarios:

- **Active Message Count** - Messages waiting to be processed
- **Dead-letter Message Count** - Failed messages needing attention
- **Incoming Messages** - Message publishing rate
- **Outgoing Messages** - Message consumption rate
- **Throttled Requests** - Indicates capacity issues

### Common Issues

**High delivery count:**
- Messages failing repeatedly
- Check processing logic
- Verify external dependencies

**Growing DLQ:**
- Messages not processable
- Review dead-letter reasons
- Fix publishers or processors

**Active messages growing:**
- Consumers not keeping up
- Scale out consumers
- Check for blocking code

## Cleanup

Delete all resources:

```bash
az group delete -y -n labs-servicebus-az204 --no-wait
```

## Final Exam Tips

### What to Memorize

1. **Tier differences** - Basic, Standard, Premium features and limits
2. **Message settlement methods** - Complete, Abandon, Dead-letter, Defer
3. **Session use cases** - FIFO, stateful processing, related messages
4. **Filter types** - SQL, Correlation, Boolean
5. **DLQ triggers** - Max delivery, TTL expiration, explicit
6. **Service Bus vs Queue Storage** - Feature comparison

### Code Patterns to Know

1. Creating client: `new ServiceBusClient(connectionString)`
2. Sending message: `await sender.SendMessageAsync(message)`
3. Receiving message: `await receiver.ReceiveMessageAsync()`
4. Completing message: `await receiver.CompleteMessageAsync(message)`
5. Dead-lettering: `await receiver.DeadLetterMessageAsync(message)`
6. Sessions: `await client.AcceptSessionAsync(queueName, sessionId)`
7. Scheduled: `await sender.ScheduleMessageAsync(message, scheduleTime)`

### Question Types to Expect

1. **Choose the right messaging service** - Service Bus vs Queue Storage vs Event Grid
2. **Select correct tier** - Basic vs Standard vs Premium
3. **Implement patterns** - FIFO, pub/sub, duplicate prevention
4. **Handle failures** - DLQ, max delivery, error handling
5. **Filter messages** - SQL vs correlation filters
6. **Code completion** - Fill in missing SDK methods

## Additional Study Resources

- [Azure Service Bus documentation](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)
- [Service Bus .NET SDK reference](https://docs.microsoft.com/en-us/dotnet/api/overview/azure/messaging.servicebus-readme)
- [Message sessions documentation](https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
- [Microsoft Learn: Service Bus module](https://learn.microsoft.com/en-us/training/modules/implement-message-workflows-with-service-bus/)

## Conclusion

You've now covered all the Service Bus topics required for the AZ-204 exam. Focus on:

- Understanding when to use each feature
- Recognizing exam scenarios and their solutions
- Memorizing key differences (tiers, message modes, etc.)
- Practicing code patterns

With this knowledge and hands-on experience, you're well-prepared for the Service Bus questions on the AZ-204 exam. Good luck!
