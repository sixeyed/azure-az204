We've covered the concepts of securing AKS applications using Azure networking and managed identities. Now let's implement a production-ready security pattern with defense-in-depth protection.

We'll begin by creating the resource group, virtual network, and subnet that will form the foundation of our secure infrastructure. You'll create a VNet with a specific address prefix, then add a subnet dedicated to AKS pods. This is different from a standard AKS deployment because we're explicitly defining the network infrastructure. The subnet will use IP addresses from the VNet range, which allows us to implement service endpoints that restrict access to other Azure resources. AKS is a managed service, but it's VNet-deployable, meaning the Pods will use IP addresses from this subnet, enabling us to secure all the other services to only allow access from Pods.

Next comes creating the AKS cluster with specific networking configuration. You'll need to get the ID of the subnet you just created, then use that when creating the cluster with Azure networking enabled. The cluster will use the Azure network plugin instead of the default kubenet, and you'll also enable the KeyVault add-on and managed identity. This process takes a while because Azure needs to do the Active Directory role propagation for the VNet, so you can open a new terminal and continue creating the rest of the infrastructure while it runs.

While the cluster is creating, you'll move on to creating the storage account and Key Vault that the application needs. The app uses Blob Storage to store its data, so you'll create a storage account, create a blob container called assetsdb, and print out the connection string. That connection string gives complete access to everything in the Storage Account, so it needs to be kept safe. You'll edit a JSON file to include your connection string, then create a Key Vault and upload that file as a secret. You can verify that you can read the secret from your machine, but remember that this secret will be read by the app running in the AKS Pod, and there's no need for it to be accessible outside of Azure.

The critical security step involves restricting Key Vault access to only allow connections from your AKS subnet. First, you'll configure service endpoints on the AKS subnet for both Microsoft.KeyVault and Microsoft.Storage. Then you'll add a network rule to the Key Vault that allows access only from the AKS subnet, and update the Key Vault's default action to deny all other access. You'll also grant the AKS managed identity permission to read secrets using a Key Vault access policy. After these changes take effect, you won't be able to read the secret from the CLI or Portal anymore because requests from outside the AKS subnet will be blocked, even if they're authenticated.

Now you're ready to deploy the app to AKS. The Kubernetes model includes a LoadBalancer Service for external access, a Deployment with a Pod spec that loads the KeyVault secret into a volume mount, and a SecretProviderClass that makes the KeyVault secret available to mount. You'll need to edit the SecretProviderClass YAML file with your own KeyVault name, AKS identity ID, and Azure tenant ID. Then you'll connect to AKS using az aks get-credentials, deploy all the YAML files with kubectl apply, wait for the Pod to be running, and get the external IP address. When you browse to the app, it should load the connection string from KeyVault, connect to Blob Storage, insert data, and display it on the page.

The lab exercise points out that the Storage Account is still open to the Internet at this point. Storage Accounts can't be deployed inside a VNet, but they can be restricted using network rules just like Key Vault. Your challenge is to fix the Storage Account so only Pods running in AKS have access, completing the security perimeter around your application.

Finally, the cleanup section shows you how to delete the resource group to remove all the resources. Let's build a production-ready, secure AKS application!
