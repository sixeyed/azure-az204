We've covered custom VM images as a solution to reduce deployment time and complexity. Instead of installing applications after each VM creation, you create an image from a fully configured VM so new VMs are ready immediately. Now let's build and deploy custom images.

Creating a base VM with your application deployed is the first step. You use az vm image list-skus to find Windows Server images, then create a VM using the full URN format like MicrosoftWindowsServer:WindowsServer:2022-datacenter-core-g2:latest. This specifies publisher, offer, SKU, and version, with generation 2 supporting UEFI boot and newer features. You connect via Remote Desktop and install IIS Web Server with PowerShell, running Install-WindowsFeature for Web-Server role, .NET Framework ASP.NET support, and Web-Asp-Net45 feature. You deploy a custom ASP.NET page that displays the VM name dynamically, testing it locally before imaging.

Preparing the VM for imaging is a critical step that removes machine-specific information so the image can create new VMs with unique identities. You run Sysprep.exe selecting Enter System Out-of-Box Experience, checking Generalize to remove machine-specific data, and choosing Shutdown. Without generalization, multiple VMs would have the same computer name and security identifiers, causing serious problems. The VM shuts down after Sysprep completes, and you lose your Remote Desktop connection.

From Azure's perspective, you need to deallocate and generalize the machine using az vm deallocate to release compute resources and az vm generalize to mark the VM as sysprepped in Azure's metadata. Verification with az vm show and the show-details flag confirms VM deallocated power state and no public IP. Now the VM is ready.

Creating an image from the VM uses az image create, specifying the source as your generalized VM and hyper-v-generation V2 matching the source. This is surprisingly quick, just seconds, because Azure creates an image reference without copying the entire disk. You can copy the image to another resource group using az image copy for separation since images have different lifecycles than application resources. This creates a snapshot and copies gigabytes of data, taking a few minutes.

Finally, deploying VMs from the image uses az vm create with the image parameter pointing to your custom image and count 3 creating three identical VMs in one command. These VMs boot with IIS, .NET, and your application already installed, dramatically faster than standard deployment with post-deployment configuration scripts.

Custom images bake configuration into reusable templates, Sysprep and generalization remove machine-specific data, and deployment from images is much faster than post-deployment configuration. Let's build efficient VM templates!
