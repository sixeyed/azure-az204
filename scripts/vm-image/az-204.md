# Building Custom VM Images - AZ-204 Exam Exercises

Custom VM images appear in the AZ-204 exam as part of the Infrastructure as a Service solutions domain. While the exam emphasizes Platform as a Service offerings more heavily, understanding how to create and manage custom VM images demonstrates important concepts about deployment automation, consistency, and lifecycle management that apply across Azure services. The exam tests both the technical steps of image creation and the architectural decisions about when custom images are the appropriate solution.

## Prerequisites

You should complete the basic VM labs before working with custom images. Understanding how to create VMs, connect to them, install software, and manage their lifecycle provides the foundation for image creation. These exercises assume you're comfortable with VM basics and ready to explore how images eliminate repetitive configuration tasks and accelerate deployment processes.

## AZ-204 Exam Skills Covered

The exam tests several aspects of custom VM image management. You need to understand the generalization process that prepares VMs for imaging, which differs between Windows and Linux but serves the same purpose of removing machine-specific information. Creating managed images from generalized VMs is a straightforward process but requires understanding the relationship between VMs, disks, and images. Deploying VMs from custom images demonstrates the practical benefits of image-based deployment. Understanding when to use custom images versus alternative approaches like containers or configuration management tools helps you answer architectural questions. Shared Image Galleries provide enterprise-grade image management with versioning and replication capabilities that appear in scenarios involving large-scale deployments. Image lifecycle management including updates, versioning, and deprecation strategies are important for operational questions. Finally, integration with automation tools and CI/CD pipelines for building images programmatically appears in DevOps-focused scenarios.

## Understanding VM Images

VM images are templates that contain a pre-configured operating system and optionally installed applications. Understanding what images are and how they differ from other Azure resources is fundamental to the exam.

An image is essentially a reference to a generalized OS disk. When you create an image from a VM, Azure captures the state of the OS disk after you've removed machine-specific information through generalization. The image doesn't copy the disk every time you use it. Instead, Azure uses the image as a template to create new disks for new VMs, applying the generalized configuration to each new instance.

Marketplace images from Microsoft and partners provide starting points for common operating systems and applications. These images have URNs that uniquely identify them, like MicrosoftWindowsServer:WindowsServer:2022-datacenter:latest. The URN format specifies the publisher, offer, SKU, and version. Understanding URN format helps you reference images correctly in CLI commands and ARM templates, which the exam might test through code completion questions.

Custom images are ones you create from your own VMs after installing and configuring software. These images let you standardize deployments across your organization. You might create images with development tools for developer workstations, monitoring agents for all servers, security baselines that meet compliance requirements, or line-of-business applications that take a long time to install. The exam presents scenarios requiring standardized deployments where custom images provide the solution.

Managed images are the modern approach to custom images, stored as Azure resources in resource groups. This is what we create when we use the az image create command. Managed images provide the foundation for more advanced features like Shared Image Galleries. The exam focuses on managed images rather than older approaches like VHD files in storage accounts.

The relationship between VMs, disks, and images is important to understand. A running VM has an OS disk attached. When you generalize the VM and create an image, the image references that OS disk. When you deploy new VMs from the image, Azure creates new OS disks based on the image. Each new VM gets its own disk, so changes on one VM don't affect others. This independence is what makes images useful for deploying multiple instances.

## Generalization Process

Generalization is the critical step that prepares a VM for use as an image template. Understanding why generalization is necessary and how to perform it correctly is essential for the exam.

Generalization removes machine-specific information from the VM. Every VM has unique identifiers including computer name, security identifiers, machine keys, user account information, and network configuration. If you created an image without generalization, every VM deployed from that image would have identical identifiers, causing serious conflicts. Security identifiers control permissions, so duplicate SIDs create security issues. Computer names must be unique on networks. Machine keys are used for encryption and authentication. Generalization removes all this machine-specific data so each new VM can generate its own unique values.

For Windows VMs, you use the Sysprep tool which stands for System Preparation. Sysprep is built into Windows and designed specifically for preparing Windows for imaging. You run sysprep.exe and select Enter System Out-of-Box Experience mode, which makes Windows behave as if it's a brand new computer being started for the first time. You must check the Generalize checkbox to remove machine-specific data. And you typically choose Shutdown so the VM stops after preparation completes. The exam might show screenshots of Sysprep or ask about the correct options to select.

For Linux VMs, you use the Azure Linux Agent with the deprovision command. The command is typically waagent -deprovision+user which removes user accounts, SSH keys, host keys, and other machine-specific configuration. Linux generalization is command-line based rather than GUI based, and you should include the +user option to remove all user accounts including the one you used to configure the VM. The exam might present code samples and ask what they accomplish or what's wrong with them.

After running Sysprep or waagent, you must perform two Azure-level operations. First, you deallocate the VM using az vm deallocate, which shuts down the VM from Azure's perspective and releases compute resources. Deallocation ensures the VM isn't incurring charges and that Azure knows it's intentionally stopped. Second, you mark the VM as generalized using az vm generalize, which updates Azure's metadata to indicate this VM has been generalized and should not be started again. This prevents anyone from accidentally starting the generalized VM, which would be in a broken state after Sysprep or deprovision.

The exam frequently tests whether you understand the complete generalization sequence. For Windows, it's Sysprep with generalize option, then az vm deallocate, then az vm generalize. For Linux, it's waagent deprovision, then deallocate, then generalize. Missing any step causes image creation to fail or produces images that don't work correctly. Scenario questions might describe problems like "VMs deployed from an image have duplicate computer names" where the answer is that generalization wasn't performed correctly.

Once a VM is generalized, you cannot start it again. Generalization is a one-way operation. If you need to make changes, you must start over with a new VM. This is why you should test your configuration thoroughly before generalizing. The exam might ask about modifying images or what to do if you discover a problem after generalization.

## Creating Managed Images

Once you have a properly generalized VM, creating an image is straightforward, but understanding the parameters and options is important for the exam.

The az image create command creates a managed image resource. The command requires you to specify the resource group where the image will be stored, the image name, and the source VM that has been generalized. If your source VM used a generation 2 image, you must specify hyper-v-generation as V2 when creating the image. Generation 2 VMs support newer features like UEFI boot and larger disks, but images must match the generation of their source. The exam might present image creation failures where the generation mismatch is the issue.

Image creation completes quickly because Azure isn't copying the entire disk. Instead, it creates an image resource that references the source VM's OS disk. The image stores metadata about the disk rather than duplicating all the data. This makes image creation fast and efficient. Understanding this architecture helps you answer exam questions about image storage and costs.

Images are region-specific resources. An image created in one region cannot directly be used to create VMs in another region. For multi-region deployments, you must copy or replicate images. The az image copy command or Shared Image Galleries provide mechanisms for making images available across regions. The exam might present global deployment scenarios where image replication is required.

Images can include data disks in addition to the OS disk, though this is less common. If your VM has multiple disks attached and you want them all in the image, you can include them during image creation. Most scenarios only image the OS disk since data typically lives in external storage or databases. The exam typically focuses on OS disk imaging, but understanding that data disks can be included helps with complete application deployment scenarios.

The source VM remains in the resource group after image creation, but you typically don't need it anymore. The image has captured everything important from the VM. However, you cannot delete the source VM's disk while the image references it. The image maintains a dependency on the source disk. If you try to delete the VM or disk, Azure prevents it to protect the image. The exam might ask about resource dependencies or why a disk deletion fails.

After creating an image, you can verify it using az image list or by viewing it in the portal. The image shows its provisioning state, source VM, OS type, and creation date. Images appear as resources you can manage with role-based access control, tags, and policies just like any other Azure resource. This manageability is one advantage of managed images over older approaches.

## Deploying VMs from Custom Images

Deploying VMs from custom images uses the same az vm create command as deploying from marketplace images, but with your image name instead of a marketplace URN. Understanding the deployment process and its benefits is important for exam scenarios.

The image parameter in az vm create can accept either a marketplace URN or a custom image name. When you provide a custom image name, Azure looks for that image in your subscription. If the image is in a different resource group than where you're creating the VM, you must provide the full resource ID of the image. The exam might show deployment commands and ask you to identify errors or complete missing parameters.

The count parameter lets you create multiple VMs from the same image in a single command. Setting count to three creates three identical VMs, each with the same software and configuration but unique machine identifiers thanks to generalization. This ability to quickly deploy multiple consistent instances demonstrates the main benefit of custom images. The exam presents scenarios like "deploy ten web servers with identical configuration" where the answer involves creating an image and using the count parameter.

Deployment time from custom images is significantly faster than deploying marketplace images and then running configuration scripts. A marketplace VM plus configuration might take ten to fifteen minutes, while deploying from a custom image takes only two to three minutes because all the software installation and configuration already happened when you created the base VM. This time savings is important for scenarios involving auto-scaling, disaster recovery, or rapid deployment. The exam might ask about optimizing deployment time where custom images are the answer.

Each VM deployed from an image gets its own OS disk copied from the image template. The VMs are independent after deployment. Changes on one VM don't affect others. If you need to update the configuration across all VMs, you must update the image and redeploy, or use configuration management tools. This independence versus the need for updates creates architectural trade-offs the exam might test.

VM size doesn't have to match the size used for the base VM. You can deploy small VMs or large VMs from the same image. The image captures the OS and software configuration, not the hardware specification. This flexibility lets you use the same image for different workload sizes. The exam might present cost optimization scenarios where using appropriate VM sizes for different workloads while maintaining consistent configuration is important.

All the supporting resources like network interfaces, public IPs, and Network Security Groups get created automatically just as they do with marketplace images. The custom image only affects the OS disk contents. Network configuration, authentication, and other settings are specified in the az vm create command as normal. Understanding what comes from the image versus what's specified at deployment time helps you answer questions about VM configuration.

## Shared Image Galleries

Shared Image Galleries provide enterprise-grade image management with features that go beyond basic managed images. Understanding when and how to use galleries is important for exam scenarios involving large-scale or multi-region deployments.

A Shared Image Gallery is a service that helps you organize and manage images with versioning, replication, and sharing capabilities. While basic managed images work fine for simple scenarios, galleries provide the structure and features needed for enterprise deployments. The exam presents scenarios with requirements like global deployment, version control, or sharing images across teams, where galleries are the appropriate solution.

Image definitions within a gallery provide logical grouping and metadata. An image definition represents a type of image, like "Windows Server with SQL Server" or "Ubuntu with development tools." Each definition can have multiple image versions representing different builds or configurations. This versioning allows you to deploy specific versions, roll back to previous versions, or test new versions before making them default. The exam might ask about managing image versions or rolling back deployments.

Gallery images support regional replication, allowing you to create an image once and replicate it to multiple Azure regions automatically. This solves the region-specific limitation of basic managed images. When you deploy VMs, Azure automatically uses the replica in the nearest region for better performance. The exam frequently tests multi-region architecture where gallery replication provides globally consistent image deployment.

Sharing galleries across subscriptions or Azure AD tenants enables collaboration between teams or organizations. You can grant read access to galleries using role-based access control, allowing other subscriptions to deploy VMs from your images without copying them. This sharing capability appears in exam scenarios involving multiple development teams, separate production and development subscriptions, or partner organizations.

Zone-redundant storage for gallery images provides higher availability by storing image replicas across availability zones. This resilience is important for production images that must remain available even during datacenter failures. The exam might present availability requirements where zone-redundant gallery images are part of the solution.

Gallery images support generation 1 and generation 2 VMs with proper metadata tracking. They also support specialized VM types and can target specific VM sizes or families. This targeting capability helps ensure images are only used with appropriate VM configurations. The exam might ask about enforcing that certain images only deploy to specific VM types for licensing or compatibility reasons.

Creating gallery images involves more steps than basic managed images. You create the gallery resource, define an image definition with metadata like OS type and recommended specifications, then create image versions from generalized VMs or snapshots. The additional complexity provides additional capabilities. The exam expects you to know when the extra capabilities justify the extra complexity.

## Image Lifecycle Management

Managing images over time involves updates, versioning, and deprecation strategies that appear in exam scenarios about operational processes and governance.

Updating images requires creating new VMs with updated software, generalizing them, and creating new images or image versions. You cannot directly modify existing images because they're read-only references to disk snapshots. This immutability ensures that VMs deployed from an image always get the same configuration, providing consistency and predictability. The exam might ask how to update application versions on VMs deployed from images, where the answer involves creating new images and redeploying or using configuration management for post-deployment updates.

Versioning strategies differ between basic managed images and gallery images. Basic managed images don't have built-in versioning, so you must version through naming conventions like app-image-v1, app-image-v2. Gallery images have native versioning where you create multiple versions under the same image definition. The exam presents scenarios requiring version tracking where gallery versioning provides better management.

Image deprecation and retirement involves marking images as unsuitable for new deployments while keeping them available for existing VMs. Gallery images support excluding versions from latest queries, effectively deprecating them while maintaining them for reference or rollback. Basic managed images don't have deprecation features, requiring manual processes. The exam might ask about preventing teams from using outdated images where gallery features provide governance.

Storage costs for images are often lower than you might expect because Azure uses snapshots and only stores unique blocks. Multiple images with similar content share storage blocks, reducing costs. However, maintaining many old image versions does accumulate cost, so lifecycle policies that delete very old images help control expenses. The exam might include cost optimization scenarios where image lifecycle management is part of the answer.

Testing images before widespread deployment is crucial. Create test VMs from new images, run validation tests, verify applications work correctly, then promote images for production use. The exam might describe quality assurance processes where image testing is part of the deployment pipeline. Shared Image Galleries support this with versioning and the ability to target specific versions for testing versus production.

Documentation and metadata for images help teams understand what each image contains, when it was created, and what it should be used for. Gallery image definitions support description fields and tags. Basic managed images support tags. Good image documentation prevents confusion about which image to use for which purpose. The exam might ask about governance and documentation practices where image metadata helps.

## Images vs Alternative Approaches

Understanding when custom images are the right solution versus other approaches is crucial for the exam because Microsoft expects you to recommend appropriate technologies based on requirements.

Custom VM images versus configuration management tools like Ansible, Chef, or Puppet represents a choice between baked-in configuration and dynamic configuration. Images bake configuration into the VM at creation time, making deployment fast but updates require new images. Configuration management applies configuration after VM creation, making initial deployment slower but updates easier. The exam presents scenarios where you must evaluate trade-offs. Fast deployment with infrequent changes suggests images. Frequent configuration updates suggest configuration management.

Custom VM images versus containers represent a fundamental architectural choice. Images are appropriate for applications requiring full OS control, legacy applications not designed for containers, Windows applications with complex dependencies, or scenarios where containerization isn't feasible. Containers are better for cloud-native applications, microservices, cross-platform portability, and rapid scaling. The exam frequently tests this decision. Look for clues like "legacy application" or "requires specific OS kernel" pointing to VMs, versus "microservices" or "platform portability" pointing to containers.

Custom images versus ARM templates with extensions represents timing and approach differences. Images provide pre-installed software at deployment time. ARM templates with custom script extensions install software after deployment. Images deploy faster but are larger and less flexible. Extensions deploy slower but are easier to update and require less storage. The exam might describe requirements where one approach clearly fits better, like "deploy must complete in under three minutes" suggesting images.

Custom images versus marketplace images represents build versus buy. Marketplace images from vendors provide software without you managing the installation. Custom images give you complete control but require maintenance. The exam asks about scenarios where existing marketplace images meet requirements versus where customization necessitates building your own images. Look for unique configuration requirements or compliance needs that marketplace images don't satisfy.

Snapshots versus images for backup purposes is another comparison. Snapshots provide point-in-time copies of disks for backup and recovery but include machine-specific data. Images are generalized templates for creating new VMs. Use snapshots for backing up VMs you want to restore. Use images for creating new VMs with the same configuration. The exam might ask about backup strategies where snapshots and images serve different purposes.

## Integration with DevOps Processes

Custom images integrate with CI/CD pipelines and automation tools, creating repeatable processes for image creation and deployment that appear in exam scenarios about DevOps and automation.

Packer from HashiCorp provides automated image building. You define image configuration in JSON templates specifying the base image, provisioning scripts, and settings. Packer creates VMs, runs provisioning, generalizes them, and creates images automatically. This automation is crucial for maintaining images as code alongside application code. The exam might describe requirements for automated image creation where Packer is the appropriate tool.

Azure DevOps pipelines can include stages for building images, testing them, and promoting them through environments. You might have a pipeline that runs whenever application code changes, builds new VMs with updated applications, creates images, deploys test VMs, runs validation tests, and publishes images to galleries for production use. The exam presents DevOps scenarios where image creation is part of the release pipeline.

GitHub Actions provides another platform for automated image creation. You can trigger workflows on code commits or pull requests that build and test images. The integration with GitHub makes it natural to version image definitions alongside application code. The exam might ask about CI/CD platforms where multiple options including Azure DevOps and GitHub Actions are valid.

Image testing automation is important for quality assurance. Automated tests deploy VMs from images, verify applications work, check configurations, and validate performance before promoting images for widespread use. The exam might describe quality gates where image testing prevents bad images from reaching production.

Infrastructure as code practices treat image definitions as code stored in version control. Changes go through code review, automated testing, and controlled deployments. This approach provides auditability, repeatability, and quality control. The exam asks about infrastructure as code practices where image management is part of the broader IaC strategy.

## Exam Study Points

Several key concepts about custom VM images deserve special attention for the AZ-204 exam. The generalization process is fundamental because images don't work without it. Know the complete sequence for both Windows and Linux including OS-level generalization, deallocation, and marking as generalized in Azure. Understand why each step is necessary and what happens if you skip steps.

Creating managed images with the az image create command requires understanding parameters including source VM, resource group, image name, and hyper-v-generation. Know that images are region-specific and reference source disks. Images are quick to create because they reference disks rather than copying all data.

Deploying VMs from images uses the same az vm create command with the image parameter accepting custom image names. The count parameter deploys multiple instances. Understand that each VM gets its own disk and unique identity despite coming from the same image template.

Shared Image Galleries provide versioning, replication, and sharing capabilities beyond basic managed images. Know when gallery features justify the additional complexity. Multi-region deployment, version control, and sharing across subscriptions indicate gallery usage.

Image lifecycle management includes updating through creating new images, versioning through naming or galleries, deprecating old versions, and managing storage costs. Understand that images are immutable and updates require new images.

Choosing between images and alternatives requires evaluating trade-offs. Images deploy faster but update slower compared to configuration management. Images work for legacy applications while containers suit cloud-native applications. Images provide OS-level control while PaaS services eliminate infrastructure management.

DevOps integration with tools like Packer, Azure DevOps, and GitHub Actions automates image creation as part of CI/CD pipelines. Treating images as code with version control, testing, and controlled releases provides quality and repeatability.

Images versus snapshots serves different purposes. Images are generalized templates for creating new VMs. Snapshots are backup copies of disks for restoring existing VMs. Know when to use each.

Security considerations include ensuring generalization removes credentials and machine-specific data. Images should not contain secrets or sensitive information. Use managed identities and key vaults for credentials rather than baking them into images.

The exam tests practical application through scenarios describing requirements and asking you to recommend solutions. Look for clues about deployment speed, consistency requirements, scale, update frequency, and legacy versus cloud-native applications to guide your answers. Understanding not just how to create images but when they're the right solution is what separates good answers from great answers.

## Cleanup

When you're finished with image exercises, delete the resource group containing test VMs to stop charges, but consider keeping the resource group with images if you'll use them in future labs. Images incur minimal storage costs compared to running VMs. The cleanup strategy balances cost management with retaining useful resources. The exam might include questions about cost optimization where understanding what resources cost money actively versus what has minimal storage costs helps you identify appropriate cleanup strategies.
