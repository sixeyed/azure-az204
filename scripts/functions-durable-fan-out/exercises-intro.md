We've covered the fan-out/fan-in pattern for executing multiple activities in parallel and aggregating results. Now let's build a quote engine that dramatically reduces processing time by calling multiple suppliers simultaneously.

Working with the HTTP trigger with orchestration shows you a durable function that starts from an HTTP request instead of a timer. The HttpOrchestratorStart function receives the request and starts the QuoteOrchestrator, then immediately returns a set of HTTP management URLs that the client can use to track the running orchestration. The quote orchestrator coordinates parallel work using Task.WhenAll, calling three supplier activity functions that simulate getting price quotes from different vendors. Each supplier takes several seconds to respond, so sequential execution would take the sum of all response times. But with fan-out, all three activities run simultaneously and complete in roughly the time of the slowest supplier, dramatically improving performance.

When you test the function locally, you'll run the Azurite emulator for durable state storage since durable functions need Azure Storage to track orchestration state. Then you'll trigger orchestrations via HTTP using curl and observe parallel execution in the logs. You'll see all three supplier activities executing at the same time, their results being collected by the orchestrator, and the best price being selected. The orchestrator returns HTTP management URLs including the statusQueryGetUri that lets you check orchestration status, seeing it progress from Running to Completed with the final result containing the cheapest quote. This is the standard pattern for async HTTP APIs where you start an operation, return immediately with status URLs, and let the client poll for completion rather than holding the HTTP connection open.

After deployment to Azure, you'll monitor through the portal seeing the orchestration timeline that shows parallel execution visually with all three supplier calls happening at the same time. The lab challenge asks you to compare fan-out to event-driven pub-sub patterns, thinking about when you should use orchestrated parallel execution versus independent event processing. The key insight is that fan-out/fan-in is perfect when you need to aggregate results from parallel operations and make decisions based on all the responses together. If operations are independent and don't need aggregation, event-driven pub-sub with Event Grid or Service Bus is simpler and more loosely coupled.

Let's implement parallel aggregation!
