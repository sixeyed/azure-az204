# Azure Durable Functions: Fan-Out/Fan-In Pattern - AZ-204 Exam Focus

**Duration:** 8-10 minutes
**Format:** Exam preparation and key concepts review

---

## Introduction to Exam Coverage

Welcome to the AZ-204 exam-focused review of Azure Durable Functions and the fan-out/fan-in pattern. In this session, we're going to concentrate specifically on what you need to know for the certification exam. We'll cover the key concepts that are tested, common exam scenarios, and important details that often appear in questions.

The AZ-204 exam expects you to understand not just how to implement durable functions, but also when to use them, how they compare to other patterns, and what their limitations and benefits are.

---

## Exam Domain: Develop Azure Compute Solutions

*[SHOW ON SCREEN: AZ-204 exam domain structure]*

Durable Functions fall under the "Develop Azure compute solutions" domain of the AZ-204 exam. Specifically, you need to know how to implement Azure Functions, including durable functions and their orchestration patterns. This typically accounts for around twenty-five to thirty percent of the exam.

The exam tests your ability to choose the right function type for a scenario, implement function bindings and triggers, configure function settings, and implement durable function patterns including fan-out/fan-in, function chaining, and async HTTP APIs.

---

## Key Concept 1: Understanding Durable Functions Architecture

*[SHOW ON SCREEN: Durable Functions architecture diagram]*

Let's start with the fundamentals. For the exam, you must understand that durable functions are an extension of Azure Functions that let you write stateful functions in a serverless environment. This is achieved through the Durable Task Framework.

The key architectural components are: Orchestrator functions, which define the workflow and must be deterministic. Activity functions, which perform the actual work and can be non-deterministic. And entity functions for managing small pieces of state, though we're focusing on orchestrators today.

Here's what the exam tests: Orchestrator functions must be deterministic, meaning they produce the same result when replayed. You cannot use random number generators, DateTime.Now, or make HTTP calls directly from an orchestrator. All these operations must be done in activity functions.

State is persisted in Azure Storage, specifically in Azure Table Storage, Blob Storage, and Queue Storage. The storage account you configure for your function app is used automatically for this persistence.

---

## Key Concept 2: The Fan-Out/Fan-In Pattern

*[SHOW ON SCREEN: Fan-out/fan-in pattern flow diagram]*

For the exam, you need to clearly understand what the fan-out/fan-in pattern is and when to use it.

Fan-out means starting multiple activity functions in parallel from an orchestrator. Fan-in means waiting for all of them to complete before processing the collected results.

The implementation uses Task.WhenAll to wait for all parallel tasks. This is different from awaiting tasks sequentially, which would defeat the purpose.

Exam scenarios that call for fan-out/fan-in include: processing large datasets by splitting them into chunks, calling multiple external services simultaneously, performing parallel validation checks, or aggregating data from multiple sources.

The key benefit the exam focuses on is performance. If you have three operations that each take five seconds, sequential execution takes fifteen seconds, but parallel execution with fan-out/fan-in takes only five seconds—the duration of the longest operation.

---

## Key Concept 3: HTTP Orchestration Features

*[SHOW ON SCREEN: HTTP trigger with status URLs diagram]*

The exam specifically tests your knowledge of HTTP features for durable functions. When you use an HTTP trigger with a durable orchestrator, the function immediately returns HTTP 202 Accepted along with a set of management URLs.

You need to know what these URLs are for: statusQueryGetUri lets you check the orchestration status, sendEventPostUri allows you to send external events to the running orchestration, terminatePostUri lets you forcefully terminate an orchestration, and purgeHistoryDeleteUri allows you to delete orchestration history.

This pattern is called the async HTTP API pattern, and it's perfect for long-running operations in web applications. The exam might give you a scenario where a user submits a request that takes several minutes to process, and ask you to identify the right pattern. HTTP-triggered durable functions with status polling is the correct answer.

The client can poll the status URL to check if the operation is complete, making this pattern ideal for responsive UIs that need to show progress.

---

## Key Concept 4: Error Handling and Retries

*[SHOW ON SCREEN: Retry policy code example]*

Error handling is definitely tested on the exam. You need to know that activity functions can have automatic retry policies configured.

In your orchestrator, you can configure retry options including maximum number of attempts, first retry interval, backoff coefficient for exponential backoff, maximum retry interval, and retry timeout.

The exam might present a scenario where an external API occasionally fails, and ask you to implement resilience. Configuring automatic retries on the activity function is the correct approach.

You also need to know that orchestrators can use try-catch blocks to handle failures and implement compensation logic. If a critical activity fails even after retries, you can catch the exception and perform compensating actions.

---

## Key Concept 5: Performance and Scaling

*[SHOW ON SCREEN: Performance metrics comparison]*

Performance is a key exam topic. You need to understand how durable functions scale and perform.

Orchestrator functions are single-threaded and process events one at a time, but multiple orchestrator instances can run in parallel, each handling a different orchestration. Activity functions scale independently and can process many tasks concurrently.

For the fan-out/fan-in pattern specifically, you can easily scale to hundreds or thousands of parallel activities. The limit is primarily determined by your consumption plan limits and the storage account performance.

The exam might ask you to optimize a slow process. If the question describes sequential API calls that could be independent, suggesting the fan-out/fan-in pattern is likely the correct answer.

Important performance consideration: Each activity invocation incurs a small storage transaction cost. For very fine-grained operations, it might be more efficient to batch work within activities rather than creating thousands of tiny activities.

---

## Key Concept 6: State Management and Persistence

*[SHOW ON SCREEN: State persistence flow diagram]*

Understanding how state is managed is crucial for the exam. Durable functions automatically checkpoint the orchestrator state after each await operation. This means if your function app crashes or recycles, the orchestration can resume from the last checkpoint.

The exam tests your understanding that this state persistence enables long-running orchestrations that can survive infrastructure failures. An orchestration can run for days or weeks if needed.

You need to know that orchestrator history is stored and can grow large. The framework provides APIs to purge old history when it's no longer needed. In exam scenarios involving thousands of orchestrations, you might need to implement history cleanup.

Also important: Because orchestrator code can be replayed multiple times, side effects like sending emails or writing to databases must be done in activity functions, never directly in the orchestrator.

---

## Key Concept 7: Comparison with Other Patterns

*[SHOW ON SCREEN: Pattern comparison table]*

The exam often asks you to choose between different integration patterns. Let's compare fan-out/fan-in with alternatives.

Versus event-driven pub-sub: Fan-out/fan-in gives you centralized control and guaranteed aggregation of all results. Pub-sub gives you loose coupling and easier extensibility. If the scenario requires knowing when all tasks are complete and processing the combined results, use fan-out/fan-in. If systems should be completely independent, use pub-sub.

Versus Azure Logic Apps: Logic Apps provide a visual designer and hundreds of connectors but can be more expensive at scale. Durable Functions give you code-based control and better cost efficiency for high-volume scenarios. If the scenario emphasizes rapid development with minimal code, Logic Apps might be better. For complex logic requiring custom code, Durable Functions win.

Versus direct parallel HTTP calls: Durable functions provide automatic state management, retry policies, and resilience. Direct calls are simpler for short-lived operations. If the scenario involves operations that might take minutes or could fail, use durable functions.

---

## Common Exam Scenarios

*[SHOW ON SCREEN: Scenario examples]*

Let's walk through some typical exam questions you might encounter.

Scenario one: "A company needs to validate orders against three external systems simultaneously and only proceed if all validations pass. Which pattern should you use?" Answer: Fan-out/fan-in with durable functions. The key words are "simultaneously" and "all validations pass."

Scenario two: "An API call takes ten minutes to complete, and the client application needs to know when it's done. How should you implement this?" Answer: Use an HTTP-triggered durable function that returns status URLs. The client polls the status URL until completion.

Scenario three: "Your function occasionally fails when calling an external API due to transient network issues. How can you improve resilience?" Answer: Configure retry policies on the activity function that calls the API.

Scenario four: "You need to process ten thousand files from blob storage as quickly as possible. What approach should you use?" Answer: Use fan-out/fan-in with one activity per file or per batch of files, depending on the scale. This enables massive parallelism.

---

## Configuration and Deployment Considerations

*[SHOW ON SCREEN: Configuration settings]*

The exam tests your knowledge of how to configure durable functions properly.

You must configure a storage account connection string in your application settings. For local development, you use "UseDevelopmentStorage=true" to work with the Azurite emulator. For Azure, you reference the storage account connection string.

The task hub name can be customized in host.json. Task hubs provide isolation between different applications using the same storage account. Understanding when you'd change this is important, typically in multi-tenant scenarios or when deploying multiple environments to the same storage account.

Concurrency settings can be configured to control how many orchestrator and activity functions run simultaneously. The exam might present a scenario where you need to throttle external API calls, and configuring maxConcurrentActivityFunctions is the answer.

---

## Monitoring and Troubleshooting

*[SHOW ON SCREEN: Application Insights dashboard]*

The exam expects you to know how to monitor and troubleshoot durable functions.

Durable functions integrate with Application Insights for telemetry and logging. You can see orchestration tracking events that show the complete execution flow. Understanding how to read these logs to diagnose issues is important.

The Azure Portal Monitor tab shows invocation history and execution details. For durable functions specifically, you can see the orchestration replay events, which show how many times the orchestrator was replayed.

Common issues the exam might present: "An orchestrator is being replayed many times." This could indicate non-deterministic code in the orchestrator or an activity that keeps failing and retrying. "An orchestration never completes." Check if all activities are completing or if there's a logic error in the wait conditions.

---

## Cost Considerations

*[SHOW ON SCREEN: Cost breakdown]*

While the exam doesn't focus heavily on cost, understanding the basics is important.

Durable functions incur costs for function execution time, storage transactions for state management, and storage capacity for persisted state. The fan-out/fan-in pattern can be very cost-effective because parallel execution completes faster, reducing total execution time.

However, creating thousands of tiny activities might incur more storage transaction costs than necessary. The exam might present a scenario where you need to optimize costs, and batching work within activities could be the answer.

---

## Best Practices for the Exam

*[SHOW ON SCREEN: Best practices checklist]*

Let's review the best practices you need to know for the exam.

Always keep orchestrators deterministic. Never use random numbers, current time, or direct I/O in orchestrators. Use activity functions for non-deterministic operations.

Configure appropriate retry policies for activities that call external systems. This improves resilience without requiring custom error handling code.

Use fan-out/fan-in for parallel operations that need to be aggregated. Don't use it when operations are truly independent with no need to collect results.

Implement proper monitoring and logging using Application Insights. The exam might ask how you'd diagnose a production issue.

Clean up orchestration history for long-running applications to prevent unbounded storage growth.

Use HTTP-triggered orchestrators for long-running operations invoked from web applications, enabling status polling and responsive UIs.

---

## Practice Question Walkthrough

*[SHOW ON SCREEN: Sample exam question]*

Let's work through a practice question together.

"Your application needs to process customer orders by calling three microservices: inventory check, payment processing, and shipping estimation. The order cannot proceed unless all three services respond successfully, but they can be called in any order. The inventory check typically takes two seconds, payment takes five seconds, and shipping takes three seconds. Which implementation provides the best performance?"

Option A: Call each service sequentially in your function.
Option B: Create three separate queue-triggered functions, one for each service.
Option C: Use a durable function with fan-out/fan-in to call all three services in parallel.
Option D: Use a Logic App with parallel branches.

*[PAUSE for thinking time]*

The correct answer is C. Here's why: The requirement states you need all three services to respond, which eliminates option B because separate queue functions don't provide aggregation. Sequential calls in option A would take ten seconds total, while parallel execution in option C would take only five seconds, the duration of the slowest call. Option D could also work, but option C is more appropriate when you need code-based control and the scenario emphasizes performance optimization.

This is typical of exam questions—they give you a scenario with specific requirements and ask you to choose the best solution.

---

## Final Exam Tips

*[SHOW ON SCREEN: Study tips]*

As you prepare for the exam, focus on these areas for durable functions.

Understand all the orchestration patterns: function chaining, fan-out/fan-in, async HTTP APIs, monitoring, and human interaction. Know when to use each pattern.

Be clear on the difference between orchestrator functions and activity functions. Know what code belongs in each.

Understand state persistence and how it enables resilience. Know that orchestrations can survive application restarts.

Know how to implement error handling with retries and compensation logic.

Understand the HTTP features for durable functions and how to implement long-running APIs.

Be able to compare durable functions with alternatives like Logic Apps, Service Bus pub-sub, and direct API calls.

Practice identifying the right pattern for different scenarios. The exam is very scenario-focused.

---

## Additional Resources

*[SHOW ON SCREEN: Microsoft Learn paths]*

For deeper preparation, review the Microsoft Learn paths for Azure Functions and specifically the modules on durable functions. The official Microsoft documentation on durable function patterns is excellent and aligns closely with exam content.

Practice with hands-on labs, not just reading. The exam expects you to know how to implement these patterns, not just the theory. Build the quote engine we worked with, then modify it. Try adding more suppliers, implementing timeout logic, or handling different error scenarios.

Review the Azure Functions best practices documentation, as many exam questions are based on real-world scenarios where best practices apply.

---

## Summary

Let's wrap up what you need to know for the AZ-204 exam regarding the fan-out/fan-in pattern.

Understand that fan-out/fan-in enables parallel execution of multiple activities with aggregation of results. Know that it's implemented using Task.WhenAll in the orchestrator. Recognize scenarios where this pattern is appropriate, particularly when you need to call multiple services simultaneously and process the combined results.

Be clear on the benefits: improved performance, automatic state management, built-in retry capabilities, and resilience to failures. Know the limitations: orchestrators must be deterministic, and there's overhead in the state persistence.

Understand how HTTP-triggered durable functions enable long-running APIs with status tracking, perfect for responsive web applications.

Know how to configure retry policies, implement error handling, and monitor orchestrations in production.

And finally, be able to compare this pattern with alternatives and choose the right tool for each scenario.

With a solid understanding of these concepts and some hands-on practice, you'll be well-prepared for the durable functions questions on the AZ-204 exam.

Good luck with your certification journey!

---

**[END OF AZ-204 EXAM FOCUS]**
