We've covered Cosmos DB Table API as a modern replacement for Azure Table Storage with zero code changes required. Now let's migrate a legacy application and see how seamless the transition can be.

You'll start by looking at the reference documentation including the Cosmos Capacity Calculator, migration tools, and querying patterns. Then you'll create a Cosmos DB Table database using both the Portal and CLI. Note the specific creation pattern using the kind GlobalDocumentDB with the capabilities EnableTable flag. This creates a Cosmos account that speaks the Table Storage protocol. The options are the same as the SQL API because the underlying database engine is the document DB for both. There are some different options from other Cosmos flavours where there are no Collections or Containers, just Account and Tables in a flat structure. The Integrations section lets you add an Azure Function which will be triggered when data changes.

Next, you'll explore using Cosmos Table API as a log sink by deploying an app that writes log entries to Table Storage. You'll start by creating a Storage Account and Table which will be the legacy data store. Then you'll create an App Service Plan and a .NET Web App. Web Apps are intended for HTTP applications but they can also run background processes in the same hosting environment through WebJobs. You'll upload a web job to run the demo app in the background, setting the Always On flag so the hosting environment doesn't shut down. After grabbing the connection string and setting it as a configuration item, you'll deploy the app. Web job deployment doesn't fit any of the normal App Service deployment options so you need to upload a ZIP file with your compiled application. When deployment completes you'll see a WebJob with status Running, meaning the background worker is writing logs to a Storage Table.

After that comes the really interesting part when you work on switching to Cosmos Table API as the log sink. The app is still running and generating logs. To prove that CosmosDB is a drop-in replacement for tables, all you need to do is change the connection string so the app starts writing to Cosmos instead. You'll print the Primary Table Connection String from the list of keys for Cosmos DB. The table connection string is in the same format as the Storage Account connection string so clients don't need any changes to be able to read the connection data and connect. Change the config setting in the app and watch as changing configuration causes the webjob to restart. When the web job starts up it will be writing data to Cosmos.

The lab exercise asks you to query CosmosDB using Data Explorer to find specific log entries and compare the query approach to the original Table Storage or to Cosmos with the SQL API. Finally, you'll look at cleanup procedures to delete the resource group. Let's migrate a legacy application to Cosmos DB!
