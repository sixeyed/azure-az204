We've covered the publish-subscribe pattern where publishers send messages without knowing which subscribers will receive them, and every subscriber gets a copy of each message. Now let's implement the fan-out pattern for extensible architectures.

We'll start by creating a Service Bus namespace and topic. You need at least Standard tier to get the topics feature, so the Basic tier we used before won't work here. You'll create the namespace with Standard SKU and TLS 1.2 enabled. Once you have the namespace, you'll create a topic called broadcast with a TTL of 10 minutes and a maximum size of 2GB. Topics have these interesting options where you define how long messages stay available if there are no subscribers to pick them up, and you set the maximum amount of storage since topics store messages and forward them to subscribers. You'll also create a queue for comparison, and when you look at both in the portal, you'll see that topics have subscriptions, which queues don't have. You can't listen on a topic directly like you can with a queue, consumers need to have a subscription to listen on.

Next you'll create subscriptions, which are like channels for routing. Publishers send messages to the topic as a whole, and all the subscriptions receive a copy of the message. You typically have multiple subscriptions with each one having a component listening and processing messages. Think about a store application where you have an order-created message published to the topic. You might have a fulfilment component processing shipping, an analytics component summarizing data, and an auditing component tracing order details, all listening on different subscriptions. You'll create two subscriptions called web and desktop, and you can print the details of each subscription to see how many messages are there, which starts at zero.

After creating subscriptions, you'll publish messages to the topic. The publisher app uses exactly the same code to send to a queue or a topic, from the sender's point of view it doesn't matter which. You'll create a new authorization rule for a sender role which only has permissions to send messages to this topic, following the principle of least privilege. You should be careful not to use any more permissions than you need, even though every namespace has a root policy with permission to everything. You'll get the connection string for that role and run the publisher app, then check that both subscriptions have the same message count. They will, because the topic forwards all messages to all subscriptions.

Next you'll receive messages from a subscription by creating another access policy that gives read access to any subscription in the topic. Access policies can be applied to the namespace as a whole or to individual queues or topics, but subscriptions aren't independently secured. You'll run a subscriber on the web subscription and see the messages, as long as they haven't expired after the topic's default TTL of 10 minutes. You can leave the subscriber running and start the publisher again to see messages flowing in real time.

Then you'll receive messages from both subscriptions to see how they work independently. One subscriber is consuming from the web subscription, but the desktop subscription doesn't have any consumers. When you compare the message counts, the web subscription has zero messages because they've all been delivered to your consumer, but the desktop subscription has a copy of every message that's been published and not yet expired. When you start a subscriber for the desktop subscription, it gets all the un-expired messages so it catches up on the backlog. Once it's caught up, it will receive new messages at the same time as the web subscriber.

For the lab challenge, you'll investigate what happens with multiple subscribers listening on the same subscription and multiple publishers publishing to the same topic. This explores how Service Bus handles reliability and scalability in different scenarios. When you're done, you'll clean up by deleting the resource group.
