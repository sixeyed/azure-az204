# Kubernetes Pods - AZ-204 Exam Focus
## Exam-Specific Narration Script

---

## Opening

Welcome to the AZ-204 exam-focused section on Kubernetes Pods. In this video, we're going to zero in on exactly what you need to know about Pods for the exam. Let's make sure you're fully prepared!

---

## Pod Lifecycle - Critical Exam Topic

**[On screen: Pod lifecycle state diagram]**

First up, the Pod lifecycle. This is a frequently tested concept on the AZ-204 exam, so let's break it down clearly.

When you create a Pod, it starts in the **Pending** state. During this phase, Kubernetes is scheduling the Pod to a node and pulling container images. If you see a Pod stuck in Pending, check for issues like insufficient cluster resources or image pull errors.

Once the containers start running, the Pod moves to the **Running** state. This means at least one container is executing. All containers don't have to be running - as long as one is up, you're in Running state.

Eventually, Pods reach a terminal state. **Succeeded** means all containers completed successfully and won't be restarted. You'll see this with batch jobs or tasks that run to completion.

**Failed** means at least one container terminated with an error. Understanding why a Pod failed - checking logs and events - is an exam skill you must have.

There are also intermediate states like **CrashLoopBackOff**. This happens when a container keeps failing and Kubernetes is backing off between restart attempts. The restart delay increases exponentially to prevent overwhelming the system.

---

## Creating and Configuring Pods

**[On screen: YAML specification example]**

For the exam, you need to know how to create Pod specifications from scratch. Let's review the essential components.

Every Pod spec requires these four fields - api Version, kind, metadata, and spec. For api Version, Pods use "v 1" as they're part of the core API.

In the metadata section, you must provide a name. You can also add labels, which are key-value pairs used for organizing and selecting Pods. Labels are super important - they're how Services find Pods and how you group resources.

The spec section defines the containers. Each container needs a name and image. You should also know how to set resource requests and limits - these define how much CPU and memory your container needs and is allowed to use.

Environment variables can be set directly in the spec or pulled from ConfigMaps and Secrets. You'll definitely see questions about injecting configuration into Pods.

---

## Multi-Container Pod Patterns

**[On screen: Three diagrams showing sidecar, adapter, and ambassador patterns]**

Multi-container Pods are heavily emphasized in the AZ-204 curriculum. There are three key patterns you need to know.

The **Sidecar pattern** is the most common. A sidecar container enhances the main application container. Classic examples include log shippers that collect logs and send them to a central location, or monitoring agents that gather metrics.

The **Adapter pattern** uses a helper container to standardize output from the main container. For instance, if your application outputs logs in a custom format, an adapter container can transform them into a standard format that your logging system expects.

The **Ambassador pattern** uses a proxy container to represent the main container to the outside world. The ambassador might handle authentication, connection pooling, or routing to different backend services.

Here's what the exam expects you to understand: all containers in a Pod share the same network namespace and IP address. They can communicate using localhost. They can also share storage volumes. And critically, they're always scheduled together on the same node - they live and die together.

---

## Container Communication

**[On screen: Network diagram showing Pod-to-Pod communication]**

Understanding container communication is essential for the exam. Let's cover the different scenarios.

**Within the same Pod**, containers communicate using localhost and different ports. Container A can reach Container B at localhost colon port-number. They share the network namespace, so this is fast and efficient.

**Between Pods**, you use the Pod's cluster IP address. Every Pod gets a unique IP that's routable within the cluster. However, Pod IPs are ephemeral - they change when Pods are recreated. That's why you use Services for stable endpoints, but you need to understand the underlying Pod IPs.

**Accessing the Kubernetes API**, the kubernetes service is automatically available in every namespace. Applications can discover it via DNS or environment variables. This is how applications interact with the Kubernetes API from inside Pods.

---

## Container Probes

**[On screen: Three types of probes with examples]**

Container probes are critical for AZ-204. There are three types you must know.

**Liveness probes** determine if a container is running. If a liveness probe fails, Kubernetes kills the container and restarts it according to the restart policy. Use these to detect when your application is deadlocked or hung.

**Readiness probes** determine if a container is ready to receive traffic. A failed readiness probe doesn't restart the container - it just removes it from Service endpoints so it won't receive requests. Use these during startup when your app needs time to initialize.

**Startup probes** protect slow-starting containers. They disable liveness and readiness checks until the container finishes starting up. This prevents Kubernetes from killing containers that are legitimately taking a long time to start.

Each probe can use an HTTP GET request, a TCP socket check, or execute a command inside the container. Know when to use each type and how to configure them in your YAML.

---

## Resource Management

**[On screen: Resource requests and limits configuration]**

Resource management is another key exam topic. You need to understand requests versus limits.

**Resource requests** are what you ask for. Kubernetes uses these to decide which node to place your Pod on. If a node doesn't have enough resources to satisfy your requests, your Pod won't be scheduled there.

**Resource limits** are the maximum resources your container can use. If your container tries to exceed CPU limits, it gets throttled. If it exceeds memory limits, it gets killed.

Here's what you need to remember: requests are for scheduling decisions. Limits are for runtime enforcement. You can set both for CPU and memory. Best practice is to always set requests, and set limits to prevent runaway containers from affecting other workloads.

---

## Restart Policies

**[On screen: Three restart policy options]**

Pod restart policies control what happens when containers exit. There are three options.

**Always** is the default. The kubelet always restarts the container when it exits, regardless of the exit code. Use this for long-running applications like web servers.

**OnFailure** means restart only if the container exits with a non-zero status. Use this for jobs and tasks where successful completion shouldn't trigger a restart.

**Never** means never restart containers automatically. Use this when you want full control and will handle failures externally.

For the exam, know which policy to use in different scenarios. Web applications? Always. Batch jobs? OnFailure. One-time tasks? Never.

---

## Working with Pod Logs and Diagnostics

**[On screen: kubectl commands for troubleshooting]**

Troubleshooting Pods is a practical skill tested on the exam. Let's review the key commands.

To view logs, use kubectl logs with the Pod name. For multi-container Pods, add the dash c flag to specify which container's logs you want.

To see why a Pod is failing, use kubectl describe pod. This shows events that explain what's happening - image pull failures, scheduling issues, health check failures.

To check what's happening in real-time, use kubectl get pods with the dash w flag for watch mode. This continuously updates the display.

To execute commands inside a running container for debugging, use kubectl exec. The dash i t flags give you an interactive terminal.

Know these commands cold - the exam may present troubleshooting scenarios where you need to identify the right approach.

---

## Common Exam Scenarios

**[On screen: Bullet list of scenarios]**

Let's walk through some common exam scenarios you might encounter.

**Scenario one**: A Pod is stuck in Pending state. What do you check? Look for insufficient resources on nodes, check if the image exists and is pullable, verify node selectors aren't too restrictive.

**Scenario two**: A Pod is in CrashLoopBackOff. What's happening? The container is starting but immediately failing. Check the container logs with kubectl logs, verify the image is correct, check for configuration errors or missing dependencies.

**Scenario three**: You need a sidecar container to ship logs. How do you configure it? Define multiple containers in the Pod spec, use a shared volume between containers so the sidecar can read the main container's log files, configure the log shipper to watch that volume.

**Scenario four**: Your application needs secrets and config. How do you inject them? Use environment variables sourced from Secrets and ConfigMaps, or mount them as volumes. Know both approaches.

---

## Azure-Specific Considerations

**[On screen: Azure Kubernetes Service logo and specific features]**

Since this is the AZ-204 exam, let's cover Azure-specific aspects.

When working with Azure Kubernetes Service, Pods can integrate with other Azure services. They can use managed identities to authenticate to Azure resources without storing credentials.

Azure CNI networking gives each Pod an IP address from your Azure virtual network subnet, allowing direct connectivity from other Azure resources.

Azure Monitor can collect logs and metrics from your Pods. Understand how to enable container insights and configure log collection.

Pods can mount Azure Storage - both Azure Files for shared storage and Azure Disks for block storage. Know when to use each type.

---

## Key Takeaways for the Exam

**[On screen: Checklist of essential knowledge]**

Let's summarize what you absolutely must know for the exam:

**Check one** - Understand the complete Pod lifecycle and state transitions.

**Check two** - Know how to write Pod YAML specifications from scratch, including containers, resources, and probes.

**Check three** - Understand multi-container Pod patterns and when to use each one.

**Check four** - Know how containers communicate within Pods and between Pods.

**Check five** - Configure liveness, readiness, and startup probes correctly.

**Check six** - Set appropriate resource requests and limits.

**Check seven** - Choose the right restart policy for different workload types.

**Check eight** - Troubleshoot common Pod issues using kubectl commands.

**Check nine** - Integrate Pods with Azure services and understand AKS-specific features.

---

## Practice Recommendations

**[On screen: Study tips]**

Here's how to prepare effectively. First, practice writing Pod specs from scratch - don't just copy and paste. Create Pods with different configurations and see what happens.

Second, deliberately break things and fix them. Deploy Pods with wrong image names, insufficient resources, or bad probes. Learn to recognize and resolve common issues.

Third, time yourself using kubectl commands. The exam may test your ability to quickly diagnose issues.

Fourth, understand not just how but why. The exam tests conceptual understanding, not just memorization.

---

## Closing

You now have the focused knowledge you need about Kubernetes Pods for the AZ-204 exam. Remember, Pods are foundational - they're used by Deployments, StatefulSets, DaemonSets, and Jobs. Master Pods, and you've built a solid foundation for container orchestration on Azure.

Good luck with your exam preparation, and keep practicing!

---

**[End of AZ-204 focus video]**
