# Docker Compose - AZ-204 Exam Exercises

Docker Compose understanding is essential foundation knowledge for the AZ-204 exam even though you won't directly use Compose in Azure services. The patterns and concepts you learn with Compose apply directly to Azure Container Instances multi-container groups, Azure Container Apps, and Azure Kubernetes Service. These exercises establish critical knowledge about multi-container coordination, service discovery, and configuration management that transfer to all Azure container platforms.

## Prerequisites

You should complete the basic Docker 101 lab before working with Docker Compose. Understanding how individual containers work, how networking enables communication, and how environment variables configure applications are essential foundations. These Compose exercises assume you're comfortable with single containers and ready to explore orchestrating multiple containers together.

## AZ-204 Exam Skills Covered

The exam expects you to understand several concepts that Docker Compose teaches effectively. You'll need to master defining multi-container applications declaratively using YAML specifications. Understanding service discovery and how containers find each other using DNS names is crucial across all Azure container services. Network configuration for container communication appears in every containerization scenario. Managing application configuration with environment variables is tested repeatedly. The desired-state deployment model where you define what you want rather than how to achieve it underlies all Azure infrastructure as code. Finally, debugging distributed applications by isolating problems and using logs prepares you for production troubleshooting.

## Service Discovery and DNS

Understanding how containers communicate is perhaps the most important concept from Compose for the AZ-204 exam. In Compose, service names become DNS hostnames automatically. When you define a service named rng-api, other containers can reach it using that exact hostname. No IP addresses, no manual DNS configuration.

This same pattern appears across Azure services with slight variations. In Azure Container Instances, containers in the same container group communicate via localhost because they share a network namespace. For multi-container groups, you configure communication through localhost and different ports. Understanding the Compose model where services get DNS names helps you recognize this communication pattern.

In Azure Container Apps, each container app gets a DNS name within the environment. Applications discover each other using these names. The environment provides internal DNS resolution automatically, just like Compose networks provide DNS within a network.

In Azure Kubernetes Service, Services provide DNS names for Pods. The pattern is identical to Compose: define a service, get a DNS name, use that name for communication. The implementation differs but the concept remains the same.

The exam frequently tests service discovery with scenarios describing communication failures between containerized components. The solution often involves configuring the correct DNS names or understanding how services discover each other within their environment.

## Configuration Through Environment Variables

The RNG application lab demonstrated configuration through environment variables. The web container used RngApi__Url to specify the API location. Changing this variable changed application behavior without modifying code or rebuilding images.

This pattern is fundamental to containerization and appears throughout the AZ-204 exam. Whether you're working with ACI, Container Apps, or App Service containers, environment variables configure applications. The exam tests your knowledge of setting environment variables during deployment and understanding that configuration should be externalized from images.

For Azure services, environment variables integrate with Azure Key Vault. Instead of hardcoding connection strings as environment variables, you reference Key Vault secrets. The service retrieves secrets at runtime using managed identities. Understanding this progression from basic environment variables in Compose to Key Vault integration in Azure helps you answer security questions on the exam.

The double-underscore configuration syntax you saw for .NET is specific to that framework's configuration system. Different frameworks have different conventions, but the principle remains: use environment variables for configuration, keep secrets out of images, and integrate with secret management services in production.

## Desired-State Deployment

When you updated the Compose file from v1 to v2 and ran docker-compose up again, Compose compared the current state with the desired state. It identified that the API container hadn't changed and left it running. The web container had new environment variables, so Compose recreated it.

This desired-state approach is fundamental to infrastructure as code and appears throughout Azure. ARM templates and Bicep use desired state: you describe what you want, Azure figures out what needs to change. Azure Resource Manager determines whether to create new resources, update existing ones, or leave them unchanged.

Azure Container Apps uses the same model. When you update a container app with new environment variables or a different image, it creates a new revision. You can control traffic distribution between revisions for blue-green deployments or canary testing.

Understanding desired state helps you answer exam questions about updating applications, managing configuration changes, and deployment strategies. The exam might present a scenario where configuration needs to change and ask what happens. The answer involves understanding that declarative infrastructure compares desired and current state to determine actions.

## Multi-Container Patterns

The RNG application demonstrated a simple two-container pattern: web frontend and API backend. Understanding common multi-container patterns helps you recognize architectures on the exam.

The sidecar pattern places a helper container alongside the main application. Common examples include logging agents that collect and forward logs, proxies that handle authentication, or monitoring agents that collect metrics. ACI container groups and Kubernetes pods both support sidecar patterns. The exam might present a monitoring scenario and expect you to recognize sidecar as the solution.

The ambassador pattern uses a proxy container to handle outbound connections. The main application connects to localhost, the proxy handles routing to external services. This simplifies the main application and centralizes connection logic. Understanding when to use ambassador versus direct connections helps answer architectural questions.

The adapter pattern transforms data between the application and external services. An adapter container might convert REST to gRPC, transform JSON formats, or handle protocol translation. This pattern appears in integration scenarios on the exam.

All these patterns work the same way conceptually whether you're using Compose for development, ACI for simple scenarios, or Kubernetes for complex orchestration. Learning the patterns in Compose provides foundation knowledge that applies everywhere.

## Networking and Isolation

Docker Compose creates networks automatically for applications. All services in a Compose file join the same network by default and can communicate using service names. This provides isolation: different Compose applications use different networks, preventing accidental communication.

In Azure Container Instances, container groups provide similar isolation. Containers within a group share networking and can communicate via localhost. Different container groups are isolated unless you integrate them with VNets.

Azure Container Apps provides environment-level networking. Apps within an environment can communicate using internal DNS. External apps require public ingress or VNet integration.

Understanding network isolation helps you answer exam questions about security and communication boundaries. A common scenario describes services that should not communicate and asks how to isolate them. The answer involves understanding network boundaries: different container groups in ACI, different environments in Container Apps, or network policies in Kubernetes.

## Limitations and When to Move Beyond Compose

The lab challenge asked about load balancing multiple RNG instances. This limitation is important for the exam because it highlights when Compose is insufficient and you need Azure services.

Compose doesn't provide load balancing. Each service instance has its own published port. You need external load balancers like Nginx or HAProxy to distribute traffic. In Azure, this limitation disappears: Container Apps provides built-in load balancing, ACI with Application Gateway distributes traffic, and AKS includes load balancing services.

Compose doesn't auto-scale based on load. You manually scale services with docker-compose up scale commands. Azure services provide auto-scaling: Container Apps scales based on HTTP requests, CPU, memory, or queue depth. This is a common exam scenario: application needs to scale automatically based on load, and the answer involves Container Apps or AKS, not simple containers.

Compose doesn't provide high availability across hosts. Everything runs on one machine. If that machine fails, your application is down. Azure services provide built-in redundancy: Container Apps distributes across availability zones, AKS spreads across nodes and zones.

Understanding these limitations helps you answer exam questions about choosing the right service. Scenarios describing simple development or testing point toward local Docker or Compose. Requirements for production features like load balancing, auto-scaling, or high availability point toward Azure Container Apps or AKS.

## Integration with Azure DevOps

Docker Compose appears in CI/CD pipelines as a testing tool. The exam tests your knowledge of DevOps practices with containers. Understanding how Compose fits into pipelines helps answer these questions.

Build pipelines might use Compose to run multi-container integration tests. The pipeline starts the application with docker-compose up, runs tests against it, and tears it down. This provides realistic testing with all components running together. The same Compose file developers use locally can run in the pipeline for consistency.

Release pipelines might use Compose for local deployment targets. A small staging environment might run applications with Compose before deploying to Azure for production. Understanding this progression from development with Compose to production on Azure helps answer architecture questions.

The exam might present scenarios about testing strategies or deployment pipelines. Recognizing when Compose provides value in the pipeline versus when you need Azure services demonstrates practical understanding of container workflows.

## AZ-204 Exam Study Points

Let's consolidate the key points for the exam. Multi-container applications defined in YAML provide declarative infrastructure that documents architecture and enables repeatable deployments.

Service discovery using DNS names is consistent across container platforms. In Compose, service names become hostnames. In Azure, each platform provides similar automatic DNS but with platform-specific implementation details.

Environment variables configure containerized applications consistently across all platforms. Production systems integrate with Key Vault for secrets while maintaining the same pattern of environment-based configuration.

Desired-state deployment compares specifications with current state to determine actions. This model appears in Compose, ARM templates, Bicep, and Azure service updates.

Multi-container patterns like sidecar, ambassador, and adapter solve common architectural challenges. These patterns work across all container platforms with minor variations.

Network isolation provides security boundaries. Understanding how networks separate concerns helps answer security and architecture questions.

Limitations of local Compose drive adoption of Azure services. When scenarios require load balancing, auto-scaling, or high availability, the answer involves Container Apps or AKS rather than simple containers.

Understanding these concepts at a practical level is what the exam tests. The hands-on experience with Compose provides intuition about how multi-container applications work that helps you reason through exam scenarios even when they don't explicitly mention Compose.

## Cleanup

Removing containers with docker rm -f cleans up the environment. This pattern is simple for development but production uses Azure services to manage container lifecycle with features like graceful shutdown, health checks, and restart policies.
