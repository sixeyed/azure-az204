We've covered Docker Compose as both a YAML specification for describing multi-container applications and a tool for managing them with a desired-state approach. Now let's orchestrate multiple containers together and see how the same patterns apply to Azure services.

You'll start with multi-container apps by running a broken random number generator that has a web frontend trying to connect to an API backend. When you first run it, the frontend can't find the API, which is exactly the kind of container networking issue you'll encounter in real projects. You'll use docker logs to see application output and nslookup to test DNS resolution between containers, discovering that containers on the same Compose network can reach each other using service names as hostnames. Once you understand the DNS issue and fix the configuration with the right service name, everything works perfectly.

Working through the compose app definition introduces you to the YAML specification, starting with a simple Nginx container to show how even basic apps benefit from Compose files. They act as both project documentation and executable specifications for your applications. You'll learn to read Compose files that define services, images, ports, and networks all in one place, making it clear what your application needs to run.

When you build multi-container apps in Compose, you'll work with the complete random number generator application defined in YAML. This twenty-line specification describes two services, their images, exposed ports, environment variables for configuration, and the container network that connects them. You'll run detached containers and use the Compose CLI to manage everything together rather than individual Docker commands, seeing how Compose gives you a unified view of your distributed application.

Managing apps with Compose demonstrates the real power of the desired-state approach. You'll debug the web app's connection issues by checking the API independently, discover the API is working fine but the web can't reach it because of a DNS mismatch, and then deploy an updated Compose specification that fixes the service discovery. When you run docker-compose up again, Compose compares what's running to what you've declared and recreates only the web container with the new configuration. Change the YAML, run up, and Compose figures out the minimum changes needed without disrupting everything.

The lab challenge takes everything further by having you add an Nginx container to multiple networks in the RNG app definition. You'll configure the Nginx service to bridge between a new network and the original network, deploy the updated spec, and verify that containers can communicate across network boundaries even when added after the initial deployment. This demonstrates how Compose handles complex networking scenarios that you'll see in production.

The key learning here is that patterns you learn with Docker Compose apply directly to Azure Container Instances with multi-container groups and AKS deployments. Let's orchestrate multi-container applications!
