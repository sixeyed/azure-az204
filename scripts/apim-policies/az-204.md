# API Management Policies - AZ-204 Exam Context

## Exam Relevance

API Management policies are a key topic in the AZ-204 exam, specifically under the objective "Implement API Management."

You need to understand how to configure and apply policies to control API behavior without modifying backend code.

## Key Concepts for the Exam

### Policy Types and Execution Order

**Inbound Policies** execute before the request reaches the backend. They can modify the request, short-circuit and prevent backend calls entirely. Examples include authentication, rate limiting, request transformation, and caching lookup.

**Backend Policies** execute when forwarding the request to the backend. They're less commonly used but can modify the backend URL or request when needed.

**Outbound Policies** execute after the backend responds, before returning to the client. They can modify the response. Examples include header manipulation, response transformation, and caching storage.

**On-Error Policies** execute when an error occurs at any stage. They're used for error handling and logging.

### Policy Scope

Policies can be applied at different levels. Global policies apply to all APIs in the APIM instance. Product policies apply to all APIs in a specific product. API policies apply to all operations in an API. Operation policies apply to a specific operation only.

More specific scopes override broader scopes, but you can use the base tag to inherit policies from the parent scope.

## Important Policies for AZ-204

### Caching Policies

The cache-lookup and cache-store policies reduce load on backend services and improve response times. Cache duration is configurable, and you can cache based on query parameters, headers, and other factors.

In this lab, we used cache-lookup with vary-by-developer and vary-by-developer-groups set to false, and configured a duration of 86400 seconds, which is 24 hours.

### Header Manipulation

The set-header policy can add, modify, or remove HTTP headers. It's used for security by removing sensitive headers, and for identification by adding custom headers.

The available actions are delete to remove a header, override to replace a header value, append to add a value to an existing header, and skip to avoid setting the header if it already exists.

### Response Transformation

The find-and-replace policy modifies response body content using string replacement. It's useful for URL rewriting and content sanitization.

In this lab example, we used find-and-replace with from set to swapi.dev/api and to set to your APIM domain at azure-api.net/swapi.

### Authentication and Security Policies

The validate-jwt policy validates JSON Web Tokens and enforces authentication at the API gateway level.

The ip-filter policy allows or denies requests from specific IP addresses.

The rate-limit and quota policies prevent API abuse. Rate-limit restricts calls per time period, while quota limits total calls over a longer period.

## Security Best Practices (Exam Relevant)

### 1. Hide Backend Implementation Details

**Why it matters:** Exposing server information helps attackers identify vulnerabilities.

**How to address:** Remove or modify the Server header, don't expose backend error messages, and use consistent error responses.

In this lab, we removed the nginx Server header and added a custom x-server header.

### 2. Prevent Backend Bypass

**Why it matters:** If clients can call the backend directly, they bypass your APIM policies.

**How to address:** Rewrite URLs in responses to point to APIM, use network security to restrict backend access, and don't expose backend URLs in documentation.

In this lab, we replaced all backend URLs with APIM URLs using find-and-replace.

### 3. Respect Backend Resources

**Why it matters:** Backend services may have rate limits or capacity constraints.

**How to address:** Implement caching to reduce backend calls, use rate limiting at the APIM level, and cache appropriate responses for appropriate durations.

In this lab, we cached responses for 24 hours since Star Wars data doesn't change.

## Policy XML Structure

For the exam, you should understand the basic XML structure. Policies are wrapped in a policies element containing four sections: inbound, backend, outbound, and on-error. Each section contains a base tag and space for section-specific policies.

The base tag inherits policies from the parent scope. Its position matters - policies before it execute before parent policies, policies after it execute after.

## Common Exam Scenarios

### Scenario 1: Rate Limiting
**Question type:** "Configure APIM to limit each subscription to 100 calls per minute"

**Solution:** Use rate-limit-by-key policy in inbound section with calls set to 100, renewal-period set to 60 seconds, and counter-key using a policy expression to get the subscription ID from the context.

### Scenario 2: JWT Validation
**Question type:** "Ensure all API calls include a valid JWT token from Azure AD"

**Solution:** Use validate-jwt policy in inbound section with Azure AD configuration.

### Scenario 3: Response Transformation
**Question type:** "Remove sensitive information from API responses"

**Solution:** Use set-header to remove headers or set-body with liquid templates to transform response bodies.

### Scenario 4: Backend URL Modification
**Question type:** "Route requests to different backends based on environment"

**Solution:** Use set-backend-service policy with conditional logic.

## Products and Subscriptions

Remember that policies work together with Products. APIs are added to Products. Products require subscriptions. Subscription keys are passed in the Ocp-Apim-Subscription-Key header. Without a valid subscription key, you get a 401 Unauthorized response.

In this lab, we verified this by testing without a subscription key first.

## Key Takeaways for AZ-204

Here's what you absolutely need to remember. Policies modify API behavior without changing backend code. There are four policy sections: inbound, backend, outbound, and on-error. Policies can be applied at multiple scopes: global, product, API, and operation. Common policies include caching, rate limiting, header manipulation, and JWT validation. Security policies help hide implementation details and prevent backend bypass. The base tag controls policy inheritance. Subscription keys enforce authentication at the product level. Policy expressions use C# syntax for dynamic values.

## Hands-On Skills to Practice

For the exam, make sure you can navigate the Azure Portal to configure APIM policies, use both the visual designer and XML editor, apply common policies like caching, rate limiting, and header manipulation, test policies using the built-in test console, understand policy scope and inheritance, configure products and subscriptions, and troubleshoot policy errors.

Good luck with your AZ-204 exam preparation!
