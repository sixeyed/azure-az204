# App Service for Distributed Apps - AZ-204 Exam Exercises

This lab directly addresses several key objectives from the AZ-204 Developing Solutions for Microsoft Azure certification exam. The concepts covered here appear throughout the exam, particularly in the Implement Azure App Service Web Apps domain which typically accounts for fifteen to twenty percent of your exam score. These exercises focus specifically on multi-app deployments, configuration management, and scaling scenarios that appear frequently in production environments and on the exam.

## Prerequisites

You should complete the basic App Service lab before diving into these exam-focused exercises. The fundamental concepts like App Service Plan creation, basic web app deployment, and CLI commands are essential building blocks. These advanced exercises assume you're comfortable with those basics and ready to explore distributed application scenarios and advanced configuration patterns.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across several key areas. Creating and configuring Azure App Service is foundational, including understanding how to provision App Service Plans with appropriate SKU and scale settings, and how to deploy multiple web apps to a single plan for resource optimization. Configuring scaling settings in an App Service plan appears frequently because understanding scale-up versus scale-out is critical for production scenarios. Creating App Service web apps with proper configuration is tested extensively, and configuring deployment settings for App Service includes understanding different deployment methods and when to use each one.

Web app settings configuration is heavily tested on the exam. You need to understand how to configure application settings that override application defaults, how to configure connection strings for database access, how to configure general settings like runtime version and operating system selection, and how to enable diagnostic logging for troubleshooting production issues. These skills combine in real-world scenarios where you're deploying and operating distributed applications in Azure.

## Multi-App Service Deployments

Understanding how multiple App Services can share a single App Service Plan is critical for the AZ-204 exam. The exam often tests your understanding of cost optimization and resource management, and deploying multiple apps to a single App Service Plan is a common real-world scenario and best practice for development and test environments. When you deploy multiple apps to one plan, they share the compute resources defined by the plan's SKU and instance count. This sharing means you're paying for one set of infrastructure but running multiple applications, which is significantly more cost-effective than creating separate plans for each app.

The key takeaway for the exam is that you can run multiple App Services on a single App Service Plan to share compute resources and reduce costs. Each app remains isolated with its own hostname and configuration, but they run on the same underlying virtual machines. This pattern is ideal for microservices architectures where you have multiple small services that don't each need dedicated infrastructure, or for deploying different components of the same application like a web frontend and a REST API backend.

Understanding the limitations is equally important. All apps on the same plan must be in the same region, because the plan defines the region. All apps share the same compute resources, so if one app consumes significant CPU or memory, it can impact the performance of other apps on the plan. During scaling operations, all apps on the plan are affected because you're scaling the underlying infrastructure. The exam might present scenarios where you need to decide whether to use one plan with multiple apps or separate plans for isolation.

## Configuration as Environment Variables

The exam emphasizes secure development practices, and using App Service configuration instead of hardcoding values is a fundamental principle tested throughout. Application settings in App Service are injected as environment variables into your application's runtime environment. This allows the same code to run in different environments with different configurations, following the twelve-factor app methodology that's considered a best practice for cloud applications.

Understanding how different platforms read configuration is important. For .NET applications, App Service configuration overrides values in web.config or appsettings.json files. The syntax uses double underscores to represent nested configuration hierarchies. For example, setting an app setting named RngApi__Url maps to the configuration path RngApi:Url in .NET Core's configuration system. Node.js applications read configuration from process.env variables. Python applications access configuration through os.environ. Java applications can use System.getenv.

Configuration precedence is a concept that appears frequently in exam scenarios. App Settings defined in Azure always take precedence over values in application configuration files. If you have a setting in appsettings.json with value A and an App Setting with the same name and value B, your application will use value B. This precedence enables deploying the same code to development, staging, and production with each environment using appropriate configuration values without any code changes.

The exam might present scenarios like "Your application needs to connect to different database endpoints in development and production. What is the recommended approach?" The answer involves using App Service configuration settings or connection strings that are environment-specific, rather than hardcoding connection strings in the application or storing them in source control where they might be exposed.

## Deployment Automation

Understanding different deployment methods and their automation capabilities is crucial for the exam. The lab used the webapp up command, which automates multiple steps including creating the App Service if it doesn't exist, creating a ZIP file of the source code, uploading it to Azure, and triggering the build and deployment. This convenience is excellent for rapid development, but the exam tests your knowledge of when this approach is appropriate versus when you need more control.

The key takeaway is that commands like webapp up automate multiple steps, making them great for development and testing scenarios. However, you need to understand what they do behind the scenes and their potential side effects. In the lab, we discovered that webapp up can change your App Service Plan's SKU, potentially downgrading it to the Free tier. This is an important lesson about automation - convenience comes with trade-offs, and understanding those trade-offs helps you make informed decisions in production scenarios.

For the exam, know the different deployment options. Automated deployment from source control through GitHub, Azure Repos, or Bitbucket provides continuous deployment where every commit triggers a build and deployment. Manual deployment using ZIP files, FTP, or the webapp up command gives you complete control over when deployments happen. Container-based deployment from Azure Container Registry or Docker Hub enables you to use containerized applications. Azure DevOps Pipelines provide comprehensive CI/CD with full control over build and release processes. Understanding when to use each method and their trade-offs is essential for answering scenario-based exam questions.

## Scaling Strategies

The AZ-204 exam tests your understanding of scaling approaches thoroughly, and this lab demonstrated both types. Understanding the difference between scaling up and scaling out is fundamental. Scaling up means changing the App Service Plan's SKU to a higher tier with more CPU, memory, and features. This is vertical scaling - you're making each instance more powerful. Scaling out means increasing the number of instances that run your application. This is horizontal scaling - you're adding more servers running the same code.

Different pricing tiers have different capabilities, and knowing these limitations is crucial for the exam. The Free tier supports only one instance with no ability to scale out. Basic tier supports up to three instances with manual scaling only. Standard tier supports up to ten instances and adds autoscaling capabilities. Premium tier supports up to thirty instances with enhanced performance and additional features. The exam frequently tests whether you know which features are available in which tier.

In the lab, we experienced a scaling failure because the webapp up command changed our plan to the Free tier, which doesn't support multiple instances. This demonstrates the importance of understanding SKU capabilities and verifying your plan's configuration before attempting scaling operations. The exam might present scenarios where scaling operations fail, and you need to identify that the cause is an incompatible pricing tier.

Autoscaling, available in Standard tier and above, is a major exam topic. You can scale based on metrics where Azure monitors CPU percentage, memory percentage, HTTP queue length, or custom metrics and automatically adds or removes instances to keep these metrics within acceptable ranges. You can also scale based on schedule where you define time-based rules like scaling up during business hours and scaling down at night. Understanding how to configure autoscale rules, including setting minimum and maximum instance counts and defining cool-down periods to prevent rapid scaling fluctuations, is essential for exam success.

## Service Communication

Understanding how distributed components communicate is essential for the exam, including networking and security concerns like CORS. When you deploy multiple apps in App Service, they can communicate via HTTP or HTTPS using their public hostnames. In the lab, we configured the web app to call the API by setting an application setting with the API's URL. This pattern of configuration-based service discovery is common in cloud applications and appears frequently on the exam.

CORS, or Cross-Origin Resource Sharing, is a security mechanism implemented by web browsers to prevent JavaScript running on one domain from accessing resources on another domain without permission. The exam tests your understanding of when CORS is needed and how to configure it. In the lab scenario with the static web app calling the API, CORS configuration is necessary because the browser sees these as different origins. Without CORS configuration, the browser blocks the request for security reasons.

Configuring CORS in App Service involves specifying which origins are allowed to make cross-origin requests to your app. You can specify specific domains like https://myapp.azurewebsites.net, or use wildcard patterns like *  to allow all origins, though this is not recommended for production due to security concerns. Understanding the security implications of CORS configuration is important - overly permissive CORS settings can expose your API to potential attacks from malicious sites.

The exam might present scenarios like "A single-page application hosted in Azure Static Web Apps cannot call your API in App Service. What configuration is needed?" The answer involves configuring CORS on the API to allow requests from the Static Web App's origin. Understanding this requirement and knowing how to configure it in the Portal or via CLI is essential.

## Common Exam Question Patterns

The exam frequently presents scenario-based questions where you need to apply your knowledge. A common pattern is "You have a web app and an API that need to run in Azure. How can you minimize costs while maintaining separate deployments?" The answer involves deploying both to the same App Service Plan to share infrastructure while maintaining separate app configurations and hostnames. Another pattern is "Your application needs to connect to different database endpoints in development and production. What is the recommended approach?" The answer involves using App Service configuration settings or connection strings that are environment-specific.

Configuration questions appear regularly. "Which App Service setting would you use to inject environment-specific values into a .NET application?" tests your understanding of application settings and how they override configuration files. "How do you configure hierarchical configuration keys in App Service for .NET Core applications?" tests your knowledge of the double-underscore syntax for nested configurations.

Scaling questions are very common. "Your App Service Plan is on the Free tier. What must you do before scaling to three instances?" tests your understanding that you must first upgrade to at least the Basic tier, which supports multiple instances. "What command would you use to both change the SKU and scale out an App Service Plan?" tests your knowledge of the az appservice plan update command with both sku and number-of-workers parameters.

Security questions involving CORS appear frequently. "A single-page application hosted in Azure Static Web Apps cannot call your API in App Service. What configuration is needed?" tests your understanding of CORS and how to configure it. "What security mechanism prevents cross-origin API calls by default?" tests your knowledge of browser security policies and CORS.

## Hands-On Practice

The AZ-204 exam emphasizes practical skills, so you need to be able to perform these tasks without looking at documentation. Make sure you can create App Service Plans with specific configurations including SKU selection and instance count. Practice deploying applications using multiple methods including webapp up, ZIP deployment, and source control integration. Get comfortable configuring application settings using both the Portal and CLI. Practice scaling App Service Plans both up by changing SKU and out by adding instances. Understanding these operations through hands-on practice ensures you can recognize them in exam scenarios and choose the correct approach.

## Understanding the Why

Don't just memorize commands - understand the reasoning behind each approach. Why use configuration instead of hardcoding values? Because it enables the same code to run in different environments, improves security by keeping secrets out of source control, and allows configuration changes without redeployment. Why share an App Service Plan across multiple apps? Because it reduces costs by sharing infrastructure, simplifies management with fewer resources to monitor, and is appropriate when apps have complementary resource usage patterns. Why does CORS exist and when do you need it? Because browsers implement same-origin policy for security, preventing malicious sites from accessing data from other sites, and you need CORS configuration when you have legitimate cross-origin communication like a web frontend calling an API on a different domain.

## CLI vs Portal

The exam may test both Azure Portal knowledge and Azure CLI commands, so practice both approaches for each task. When creating App Service Plans, know both the Portal workflow and the CLI command syntax. For configuring application settings, be comfortable with both the Portal's Configuration page and the az webapp config appsettings set command. Understand that CLI commands are often easier to remember if you understand their parameter patterns - most follow a consistent structure of command group, operation, and required parameters.

## Pricing Tier Knowledge

Know the capabilities and limitations of each App Service Plan tier thoroughly. Free and Shared tiers are for development only with no SLA and limited resources. Basic tier is entry-level production with dedicated compute but no autoscale or deployment slots. Standard tier is production-ready with autoscale, deployment slots, and daily backups. Premium tier offers enhanced performance and more advanced features. Understanding when to recommend each tier based on requirements is crucial for scenario-based exam questions.

## Configuration Patterns

Understand how different platforms read configuration from App Service. .NET applications use configuration builders that automatically read from environment variables, with App Service settings taking precedence over file-based configuration. Node.js applications access configuration through process.env. Understanding this helps you answer questions about how applications receive configuration in different runtime environments. Know the precedence order when multiple configuration sources exist, and remember the double-underscore syntax for hierarchical keys in App Service settings.

## AZ-204 Exam Study Points

Let's consolidate the key points for exam success. Multiple App Services can share a single App Service Plan to optimize costs, with each app maintaining isolation but sharing compute resources. App Service configuration settings override application configuration files and enable environment-specific behavior without code changes. Scaling includes vertical scaling by changing SKU for more resources per instance, and horizontal scaling by adding instances for more capacity and redundancy. Different pricing tiers have different capabilities regarding scaling limits, features like deployment slots, and autoscale support. Understanding these differences helps you choose the appropriate tier for given requirements.

CORS configuration is necessary when web applications make cross-origin requests, and understanding how to configure allowed origins in App Service is essential for securing APIs while enabling legitimate cross-origin communication. Deployment methods each have specific use cases, from automated deployment through source control for continuous deployment scenarios, to manual deployment for controlled release processes. Application settings use double-underscore notation for nested hierarchies in .NET applications, and understanding this syntax is important for configuring complex application settings.

The webapp up command provides convenience by automating multiple steps but can modify existing resource configurations, so understanding its behavior and side effects is important for managing Azure resources safely. Load distribution across multiple instances happens automatically through Azure's load balancer, which you observed in the lab when testing requests to scaled applications.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything including all App Service plans, web apps, and their configurations. Using the no-wait flag lets the deletion proceed in the background while you continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization. Understanding when and how to clean up resources, and the implications of resource deletion, demonstrates mature cloud operations knowledge that the exam tests throughout various domains.
