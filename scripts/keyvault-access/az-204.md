# Securing Key Vault Access - AZ-204 Exam Exercises

Securing Key Vault Access appears in the AZ-204 exam under the "Implement Azure Security" domain, which represents fifteen to twenty percent of your exam score. This lab directly addresses several key objectives by demonstrating how to combine network-level security with identity-based security for comprehensive Key Vault protection. The exam tests not just your ability to create and use Key Vaults, but your understanding of how to secure them properly using multiple layers of defense - network restrictions, access policies, and managed identities working together.

## Prerequisites

You should complete the basic Key Vault lab before diving into these security-focused exercises. The fundamental concepts like vault creation, secret management, and access policies are essential building blocks. These exercises assume you're comfortable with the basics and ready to explore the security patterns that distinguish production deployments from simple demonstrations.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of Key Vault security capabilities. You need to understand how to configure access policies to control what principals can do with secrets, keys, and certificates, applying the principle of least privilege. Network security knowledge including virtual network service endpoints and understanding when to restrict Key Vault to specific networks is crucial. Managed identities are a major exam topic - you must know the difference between system-assigned and user-assigned identities, understand the authentication flow where Azure resources request tokens from the Instance Metadata Service, and recognize common use cases where managed identities are the preferred solution. Service endpoints versus private endpoints is frequently tested - you need to know that service endpoints are free and keep traffic on the Azure backbone with source IPs visible, while private endpoints have associated costs but create a private IP for the service inside your network. Finally, understanding the choice between access policies and RBAC for Key Vault permissions is important because the exam tests when to use each approach.

## Network Security for Key Vault

Let's start by understanding how network-level restrictions work, which is the first layer of defense.

We're creating a resource group named labs-keyvault-access in the East US region, then creating a Key Vault with a globally unique name. Remember that Key Vault names must be unique across all of Azure because they become part of the DNS endpoint. We're creating a secret named secret01 to test access throughout the lab, then verifying we can read it back using our local machine credentials.

The key concept here is that we have access because we're authenticated through Azure AD and we're the creator of the vault, which automatically grants us full permissions. Open the Key Vault in the Portal and check the Access policies tab to see your account listed with all permissions. This demonstrates that access requires two things: network connectivity and authorization through access policies or RBAC.

Now we're creating a virtual network with address prefix 10.10.0.0/16, which creates the network container for our resources. We're adding a subnet with prefix 10.10.1.0/24 where we'll deploy a VM. This subnet will be the only location allowed to access our Key Vault once we configure network restrictions.

If we try to add a network rule using keyvault network-rule add right now, it fails with an error about service endpoints. This is an important exam concept - Azure services can't route traffic to subnets unless you explicitly allow them with a service endpoint. Service endpoints are special routing rules that keep traffic on the Azure backbone network rather than going through the public internet, improving both security and performance.

We're updating the subnet with the service-endpoints parameter set to Microsoft.KeyVault. Service endpoints are configured once per service type per subnet. Now we can successfully add the network rule using keyvault network-rule add, which creates an exception allowing Key Vault access from our subnet.

Here's where many people get confused, and the exam tests this understanding. If we try to access the secret from our local machine again, it still works even though we added a network rule for the subnet. Why? Open the Key Vault Networking section in the Portal and you'll see "Allow public access from all networks" is still selected. Adding a network rule doesn't change the default action - it just adds an allow rule. You must explicitly change the default to deny public access.

We're updating the Key Vault with keyvault update setting default-action to Deny. Now when we try to access the secret from our local machine, it fails with a forbidden error. The Key Vault is locked down at the network layer. Only resources in the subnet can reach it over the network, and this happens before authentication is even attempted. This is defense in depth - network restrictions are the first barrier, and authentication is the second barrier.

## Managed Identities for Authentication

Network access alone isn't enough. Let's prove that resources in the subnet still need proper authentication by creating a VM and demonstrating both failure and success.

We're creating an Ubuntu VM in the subnet using vm create with custom-data pointing to a setup script. The setup script installs Python and the Azure SDK libraries needed to interact with Key Vault. This demonstrates a common pattern for VM initialization in Azure. When the VM is ready, we're connecting via SSH and downloading a Python script that attempts to read our Key Vault secret.

When we run the Python script, it fails with an authentication error. This is the critical exam concept - the VM is inside the subnet, so it passes the network-level check. The network rule allows the VM to reach Key Vault. But the VM still needs to authenticate as an authorized principal to actually read secrets. Network access and identity-based access are two separate layers, and both must succeed.

Now we're adding a system-assigned managed identity to the VM using vm identity assign. This creates an identity that's tied to the VM's lifecycle - when the VM is deleted, the identity is automatically deleted. The command output includes a systemAssignedIdentity field containing the identity's object ID. This ID represents the VM's identity in Azure AD.

We're granting this identity permission to read secrets using keyvault set-policy with secret-permissions set to get and the object-id set to the managed identity. This creates an access policy entry for the VM's identity. Now when we run the Python script again, it succeeds and prints the secret value.

What happened behind the scenes is crucial for the exam. The VM now has a managed identity registered in Azure AD. When the Python script runs, it uses Azure's Instance Metadata Service, which is available at a special IP address inside Azure VMs. The IMDS provides a token for the managed identity. That token is used to authenticate with Key Vault. The entire flow happens automatically without any credentials stored in code or configuration files. This is why managed identities are the preferred authentication method for Azure services communicating with each other.

## System-Assigned vs User-Assigned Identities

The exam frequently tests your understanding of when to use each type of managed identity.

System-assigned identities are what we used in this lab. They're tied to the lifecycle of a single Azure resource. When you create the identity with vm identity assign, it becomes part of the VM. When you delete the VM, the identity is automatically deleted. This is perfect for scenarios where the identity doesn't need to outlive the resource. The setup is simpler because it's all managed as part of the resource.

User-assigned identities are separate Azure resources with their own lifecycle. You create them using identity create, and they exist independently of any VM, App Service, or other resource. You can assign the same user-assigned identity to multiple resources, making it ideal when several resources need the same permissions. The identity persists even when resources are deleted, which is useful for pre-configuring permissions before deploying resources or when resources are frequently created and destroyed but need consistent access.

A common exam question pattern is "Multiple Azure Functions in different resource groups need access to the same Key Vault, and the solution must ensure identities persist if individual functions are deleted. What should you do?" The answer is to create a user-assigned managed identity, grant it Key Vault access, and assign it to all the Function Apps. Because it's user-assigned, it persists independently and can be shared across resources.

## Service Endpoints vs Private Endpoints

This lab demonstrates service endpoints, but the exam also tests private endpoints and private link. You must know the differences.

Service endpoints are what we configured in this lab. They're free to use and keep traffic on the Azure backbone network rather than routing through the public internet. The source IP addresses from your virtual network are visible to the Key Vault, which means Key Vault still has a public endpoint but restricts access based on source network. Configuration happens at the subnet level using network vnet subnet update with the service-endpoints parameter. Service endpoints are simpler and sufficient for many scenarios.

Private endpoints are more advanced and have associated costs. They create a private IP address for the Key Vault inside your virtual network, making the Key Vault appear as a resource within your network topology. The Key Vault becomes accessible only through private connectivity, with no public endpoint exposure. This provides more granular security because the service truly exists inside your network boundary. Private endpoints require more complex setup including private DNS zones to resolve the Key Vault's DNS name to the private IP.

When should you choose each? Use service endpoints when you want free network-level restrictions and are comfortable with Key Vault having a public endpoint that's restricted by source IP. Use private endpoints when compliance requirements mandate no public endpoint exposure, when you need the Key Vault to integrate more deeply with your virtual network topology, or when you're implementing a comprehensive private networking strategy.

## Access Policies vs Azure RBAC

This lab uses access policies, which is the traditional Key Vault permission model. The exam also tests Azure RBAC for Key Vault.

Access policies are configured directly on the Key Vault resource and provide fine-grained control over individual operations. We used keyvault set-policy to grant the VM's managed identity get permission on secrets. Access policies let you specify separate permissions for secrets, keys, and certificates. You can grant permissions like get, list, set, delete, backup, restore, recover, and purge individually. This granularity is powerful when you need precise control. Access policies work with any Azure AD principal including users, groups, service principals, and managed identities. They're configured per Key Vault, which means management is localized.

Azure RBAC is the newer option and uses Azure's standard role-based access control system. You enable it when creating or updating a Key Vault with the enable-rbac-authorization parameter. Once RBAC is enabled, access policies are completely ignored - you must choose one model or the other, not both. Azure RBAC uses built-in roles like Key Vault Administrator, Key Vault Secrets Officer, Key Vault Secrets User, Key Vault Crypto Officer, Key Vault Crypto User, and Key Vault Certificates Officer. These roles provide consistent permissions across Key Vaults and integrate with Azure's overall RBAC system, making permission management more centralized and consistent with other Azure services.

When should you use each? Use access policies when you need the most granular control over individual operations or when working with existing Key Vaults that use access policies. Use Azure RBAC for new deployments when you want consistency with other Azure services and simplified management through standard Azure roles. The exam might present scenarios asking which to choose based on requirements for consistency, granularity, or integration with existing RBAC deployments.

## Soft Delete and Purge Protection

The lab challenge introduces soft delete, which is an important exam topic for data protection.

Soft delete is enabled by default on new Key Vaults with a retention period of 90 days. When you delete a secret using keyvault secret delete, it doesn't disappear immediately. Instead, it enters a deleted state and remains recoverable during the retention period. This protects against accidental deletion. You can list deleted secrets with keyvault secret list-deleted and recover them with keyvault secret recover.

The important behavior for the lab challenge is that you can't create a new secret with the same name as a soft-deleted secret until you either recover or purge the deleted one. If you delete secret01 and try to recreate it immediately, the operation fails because the name is still reserved by the deleted secret. You must either recover the original with keyvault secret recover to restore it, or purge it permanently with keyvault secret purge to free up the name.

Purge protection adds an extra layer. When enabled using keyvault update with enable-purge-protection set to true, it prevents permanent deletion during the retention period. Even if you want to purge a deleted secret, you can't until the retention period expires. This protects against malicious or accidental purging. Once enabled, purge protection cannot be disabled - this is a one-way operation designed for compliance scenarios.

A common exam scenario is "You need to ensure deleted secrets can be recovered but prevent administrators from permanently deleting secrets immediately. What should you do?" The answer is to enable both soft delete with an appropriate retention period and purge protection. Together they provide recovery capability while preventing premature permanent deletion.

## Best Practices for Exam

The exam expects you to know security best practices for Key Vault. Always prefer managed identities over service principals when authenticating Azure services with each other because there are no credentials to manage and rotation is automatic. Implement defense in depth by combining network restrictions with access policies or RBAC - network access and identity-based access are independent layers. Enable soft delete and purge protection for production Key Vaults to prevent accidental data loss. Use the principle of least privilege when configuring access policies or RBAC roles, granting only the minimum permissions needed. Separate Key Vaults by environment with different vaults for dev, test, and production to prevent accidental production access. Use service endpoints or private endpoints based on your security requirements and budget. Monitor Key Vault access using Azure Monitor and set up alerts for unusual access patterns or approaching secret expiration dates.

## Common Exam Scenarios

The exam presents scenarios and expects you to choose the correct solution. Here are common patterns.

Scenario one: An application running in Azure App Service needs to read database connection strings from Key Vault. The solution is to enable system-assigned managed identity on the App Service, grant the identity get permission on secrets, and use the Azure SDK with DefaultAzureCredential in the application code. The App Service authenticates using its managed identity without any credentials in code.

Scenario two: Multiple VMs in different virtual networks need to access the same Key Vault. The solution is to configure service endpoints or private endpoints in each virtual network, add network rules allowing access from each subnet, create either system-assigned identities for each VM or a shared user-assigned identity, and grant appropriate Key Vault permissions. The choice between service and private endpoints depends on whether public endpoint exposure is acceptable.

Scenario three: A development team needs to list secrets but not read their values. Using access policies, grant list permission only without get permission. Using RBAC, assign the Key Vault Reader role which provides read access to metadata but not secret values. This demonstrates the principle of least privilege.

Scenario four: An application needs to access Key Vault but must use private connectivity only with no public endpoint. The solution is to configure Private Link with a private endpoint in the application's virtual network, configure the Key Vault to disable public access, set up private DNS zones for name resolution, and use managed identity for authentication. Private endpoints are required for this level of network isolation.

## Key Commands for Exam

You should be comfortable with these commands because they appear in code-based questions.

Creating a Key Vault uses keyvault create with parameters for name, resource group, and location. Setting secrets uses keyvault secret set with name, value, and vault-name. Granting access policies uses keyvault set-policy with secret-permissions, object-id, and vault name. Configuring managed identities uses vm identity assign for system-assigned or identity create for user-assigned. Adding network rules requires network vnet subnet update to configure service endpoints followed by keyvault network-rule add. Updating the default network action uses keyvault update with default-action set to Deny. Managing soft delete uses keyvault secret list-deleted to view deleted secrets, keyvault secret recover to restore them, and keyvault secret purge to permanently delete them.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything using az group delete with the yes and no-wait flags. The no-wait flag lets the deletion proceed in the background so you can continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management, including how soft-deleted Key Vaults are handled during resource group deletion and the retention period before permanent deletion occurs.
