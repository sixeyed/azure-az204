We've covered Azure Table Storage as a simple, scalable NoSQL database service in Azure Storage Accounts with schema flexibility where entities can have different properties - an older part of Azure's storage stack but still encountered in many solutions. Now let's work with Table Storage hands-on.

We'll start by creating a table in a storage account using the storage table create command. The mandatory parameters are simple: just table name and storage account name. An important insight is that empty tables don't cost anything, you only pay when there's actual data stored, unlike some database services where you pay for provisioned capacity regardless of usage. In the Storage Browser you'll add entities with different structures, demonstrating schema flexibility. You'll create entities with varied properties, some with FirstName LastName and Role, others with completely different structure using FullName and CountryCode, and you can even mix data types. This extreme flexibility makes Table Storage useful for evolving data structures where you don't want to define a rigid schema upfront.

Next you'll work with querying Table Storage with OData using the REST API with curl requests. OData is an open protocol providing standardized querying over HTTP. You'll discover that public access isn't enabled by default for security, Azure enforces authentication on all storage operations. This leads to using SAS tokens for authentication where you generate a token with time-limited access, read-only permissions following least privilege, and fine-grained control restricted to specific tables rather than entire storage accounts. This granular security is a key feature of SAS tokens. You'll work with OData query capabilities including getting specific entities by PartitionKey and RowKey which is the most efficient pattern targeting single entities directly, requesting JSON instead of XML using Accept headers, and getting cleaner JSON without OData metadata wrapper.

Finally you'll use table storage as a log sink by running a .NET app using Serilog that writes log events directly to Azure Table Storage. This demonstrates a real-world use case where Table Storage excels: storing high-volume, semi-structured log data. You'll see clever partition and row key patterns using reverse chronological timestamps so recent logs come first in queries. This is a practical example of how Table Storage integrates with logging frameworks and handles data that doesn't fit neatly into a relational schema.

For the lab challenge, you'll explore more advanced querying patterns and understand the performance implications of different partition key designs. When you're done, you'll clean up by deleting the resource group.
