We've covered Cosmos DB as a globally distributed multi-model database for planet-scale applications. Now let's work with Cosmos DB NoSQL API hands-on and see how it combines the flexibility of NoSQL with the familiarity of SQL syntax.

You'll start by looking at the reference documentation to understand Cosmos DB's architecture and capabilities. Then you'll move into creating a Cosmos DB database using both the Portal and Azure CLI. You'll create a Cosmos DB account first, which is the top-level container, and then add a database using the SQL API. The Portal shows you different capacity modes like provisioned and serverless, along with options for geo-redundancy and backup policies. It's important to understand the pricing model since CosmosDB is an enterprise-grade database. You'll retrieve connection strings both via Portal for visual access and CLI with JMESPath queries for automation. This connection string contains the account endpoint and keys so you need to treat it like a password.

Next, you'll run an app using Cosmos DB with Entity Framework to see how familiar ORMs work with Cosmos DB. The application is built with the CosmosDB NoSQL library but uses a standard data model with POCOs and an Entity Framework context object. You'll run the app locally passing in the database type and connection string as parameters. The app demonstrates CRUD operations and shows how SQL-like LINQ queries get translated to Cosmos DB operations automatically. You'll see lots of SQL statements in the logs which are the queries the ORM generates, giving you insight into what's happening behind the scenes.

After that, you'll explore the data using the Portal's Data Explorer. This built-in tool lets you browse containers, view documents, and run queries without any code. Containers are kind of like tables except that items in a container don't need to have the same schema. You'll manually add items to understand document structure, learning that Cosmos requires a lowercase id field not Id or ID, and the value must be unique. There's a discriminator field that the ORM uses for identifying object types. You'll see how CosmosDB automatically generates the id field if you don't specify it, but it doesn't know the conventions your app expects. This teaches you about the flexibility and the challenges of working with schema-less storage.

The lab exercise challenges you to write SQL-like queries against the NoSQL container. Despite being a NoSQL database, Cosmos DB supports a SQL-style query language. You'll filter documents with WHERE clauses, count results, and see how queries work across the data. This demonstrates the key learning point that Cosmos DB looks like SQL for queries but stores schema-less JSON documents, giving you the flexibility of NoSQL with the familiarity of SQL syntax. Finally, you'll look at cleanup procedures to understand how deleting the resource group removes the database and all data. Let's explore Cosmos DB NoSQL API!
