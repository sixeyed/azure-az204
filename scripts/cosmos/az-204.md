# Cosmos DB - AZ-204 Exam Exercises Narration Script

## Introduction

Welcome to the AZ-204 exam-focused Cosmos DB exercises. This video covers the specific scenarios and skills you need to master for the AZ-204 certification exam under the "Develop for Azure Storage" domain, which accounts for 15 to 20 percent of the exam.

Make sure you've completed the basic Cosmos DB lab first, as we'll build on those foundational concepts to explore exam-critical topics.

## AZ-204 Skills Overview

For the AZ-204 exam, you need to know how to:

- Perform operations on containers and items using the SDK
- Set appropriate consistency levels for different scenarios
- Implement change feed notifications for event-driven architectures
- Design effective partition strategies
- Configure indexing policies to optimize performance
- Optimize Request Unit consumption to control costs

Let's work through each of these topics with practical examples.

## Exercise 1: Consistency Levels

Consistency levels are a critical exam topic because they represent the fundamental tradeoff between availability, latency, and data consistency.

### Creating the Account

Let's start by creating a new Cosmos DB account for our AZ-204 exercises:

```bash
az group create -n labs-cosmos-az204 --tags courselabs=azure -l eastus

az cosmosdb create \
  -g labs-cosmos-az204 \
  -n <cosmos-account-name> \
  --default-consistency-level Session \
  --enable-automatic-failover false
```

Notice we're explicitly setting the consistency level to Session - this is the default and most commonly used level.

### Understanding the Five Consistency Levels

Cosmos DB offers five consistency levels, from strongest to weakest. Let me explain each:

**Strong Consistency**: This provides linearizability guarantees. When you read data, you're absolutely guaranteed to get the most recent committed write. This is the strongest consistency model, but it comes with trade-offs:
- Highest latency because reads must coordinate across regions
- Reads cost twice as many Request Units compared to other levels
- Only practical for single-region deployments

**Bounded Staleness**: This guarantees that reads lag behind writes by at most K versions or T time. You configure the lag, making it predictable. This is excellent for globally distributed applications that need strong consistency with better availability than Strong consistency provides.

**Session Consistency**: This is the sweet spot for most applications and the default setting. Within a single session, you get monotonic read and write guarantees - you'll never read old data after reading newer data. Different sessions might see data at different points in time, but within each session, consistency is maintained. This offers an excellent balance of consistency, availability, and latency.

**Consistent Prefix**: This guarantees that reads never see out-of-order writes. If writes happened in the order A, B, C, you might see A, or A and B, but never B without A, or C without B. This is eventual consistency with ordering guarantees.

**Eventual Consistency**: This is the weakest consistency level with no ordering guarantees. It offers the lowest latency and lowest cost, making it suitable for non-critical data like social media likes, view counters, or other scenarios where absolute consistency isn't required.

### Changing Consistency Levels

You can change the default consistency level on your account:

```bash
az cosmosdb update \
  -g labs-cosmos-az204 \
  -n <cosmos-account-name> \
  --default-consistency-level BoundedStaleness \
  --max-staleness-prefix 100 \
  --max-interval 5
```

**Exam Tip**: Remember that you can always relax consistency on individual requests, but you cannot strengthen it beyond the account's default level.

## Exercise 2: Partition Keys and Container Design

Partition key selection is absolutely critical for Cosmos DB performance and is heavily tested on the exam.

### Creating a Database and Container

First, create a database:

```bash
az cosmosdb sql database create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -n ProductsDB
```

Now create a container with a partition key:

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --partition-key-path "/category" \
  --throughput 400
```

The partition key path uses JSON notation - in this case, we're partitioning on the "category" property.

### Partition Key Selection Criteria

For the exam, you need to understand what makes a good partition key. Here are the key criteria:

**High Cardinality**: The partition key should have many distinct values. This allows Cosmos DB to distribute data across many partitions.

**Even Distribution**: Data should be evenly distributed across partition key values. Avoid hot partitions where one partition key gets significantly more traffic than others.

**Query Patterns**: Your most common queries should include the partition key in the WHERE clause. This allows Cosmos DB to route queries to specific partitions rather than scanning all partitions.

**Cannot Change**: This is critical - you cannot change the partition key after container creation. Choose carefully!

### Good Partition Key Examples

Let me give you some scenarios the exam might present:

**For user data**: Use `/userId` - each user is a partition, perfect for applications where you primarily query data for a specific user.

**For multi-tenant applications**: Use `/tenantId` - each tenant's data is isolated in its own partition, providing natural data segregation and efficient queries.

**For product catalogs**: Use `/category` - but only if categories are well-balanced. If 90% of products are in one category, this would be a poor choice.

**For IoT telemetry**: Use `/deviceId` - each device's data is in its own partition, enabling efficient queries for a specific device's history.

### Bad Partition Key Examples

The exam loves to test your understanding of what NOT to do:

**Status fields**: If you use `/status` with only values like "active" and "inactive", you'll have only two partitions, creating hot spots.

**Date fields**: Using `/createdDate` creates hot partitions because all new writes go to the current date's partition.

**Unbalanced categories**: Using `/region` when 90% of your data is in one region creates an extremely hot partition.

### Lab Challenge

Now create a container for orders. What would be a good partition key?

Take a moment to think about this before I show the solution.

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Orders \
  --partition-key-path "/customerId" \
  --throughput 400
```

Using `/customerId` makes sense because:
- Customer IDs have high cardinality
- Queries for a customer's orders are common
- Data is likely well-distributed across customers

## Exercise 3: SDK Operations

The exam tests your knowledge of performing CRUD operations using the Cosmos DB SDK. Let's look at the .NET SDK patterns.

### Initializing the Client

```csharp
using Microsoft.Azure.Cosmos;

var client = new CosmosClient(
    accountEndpoint: "https://<cosmos-account>.documents.azure.com:443/",
    authKeyOrResourceToken: "<primary-key>");

var container = client.GetContainer("ProductsDB", "Products");
```

Note the placeholder format - in production, you'd retrieve these from Azure Key Vault or App Configuration.

### Create Operations

```csharp
var newProduct = new Product
{
    id = Guid.NewGuid().ToString(),
    name = "Laptop",
    category = "Electronics",
    price = 999.99m
};

ItemResponse<Product> createResponse = await container.CreateItemAsync(
    newProduct,
    new PartitionKey(newProduct.category));

Console.WriteLine($"Created item. RU charge: {createResponse.RequestCharge}");
```

**Key points for the exam**:
- The partition key must be provided when creating items
- The response includes the RU charge - monitor this for cost optimization
- The id field must be unique within the partition

### Read Operations

```csharp
ItemResponse<Product> readResponse = await container.ReadItemAsync<Product>(
    id: newProduct.id,
    partitionKey: new PartitionKey("Electronics"));

Console.WriteLine($"Read item: {readResponse.Resource.name}");
```

**Point reads** are the most efficient operations - only 1 RU for a 1 KB item when you know both the id and partition key.

### Update Operations

```csharp
newProduct.price = 899.99m;
ItemResponse<Product> updateResponse = await container.ReplaceItemAsync(
    newProduct,
    newProduct.id,
    new PartitionKey(newProduct.category));
```

ReplaceItemAsync replaces the entire item. There's also PatchItemAsync for partial updates, which can be more efficient.

### Delete Operations

```csharp
ItemResponse<Product> deleteResponse = await container.DeleteItemAsync<Product>(
    id: newProduct.id,
    partitionKey: new PartitionKey("Electronics"));

Console.WriteLine($"Deleted item. RU charge: {deleteResponse.RequestCharge}");
```

### Query Operations

Now let's look at queries, which are heavily tested on the exam.

**Efficient query with partition key**:

```csharp
var queryDefinition = new QueryDefinition(
    "SELECT * FROM c WHERE c.category = @category AND c.price < @maxPrice")
    .WithParameter("@category", "Electronics")
    .WithParameter("@maxPrice", 1000);

var iterator = container.GetItemQueryIterator<Product>(
    queryDefinition,
    requestOptions: new QueryRequestOptions
    {
        PartitionKey = new PartitionKey("Electronics")
    });

while (iterator.HasMoreResults)
{
    var response = await iterator.ReadNextAsync();
    Console.WriteLine($"Query RU charge: {response.RequestCharge}");

    foreach (var product in response)
    {
        Console.WriteLine($"Product: {product.name}, Price: {product.price}");
    }
}
```

This is efficient because we're specifying the partition key, so Cosmos DB only searches one partition.

**Cross-partition query**:

```csharp
var crossPartitionQuery = new QueryDefinition(
    "SELECT * FROM c WHERE c.price < 100");

var crossPartitionIterator = container.GetItemQueryIterator<Product>(
    crossPartitionQuery,
    requestOptions: new QueryRequestOptions
    {
        MaxItemCount = 10
    });
```

Notice we didn't specify a partition key, so this query runs across all partitions. This is much more expensive in terms of RUs and latency.

**Exam Tip**: Always include the partition key in queries when possible. Cross-partition queries should be avoided in production for frequently-run queries.

## Exercise 4: Change Feed

The change feed is a critical topic for the exam, especially for event-driven architecture questions.

### What is Change Feed?

Change feed provides a persistent, ordered log of changes to items in a container. Every insert and update is captured and can be processed by one or more consumers.

### Change Feed Processor Pattern

```csharp
using Microsoft.Azure.Cosmos;

var monitoredContainer = client.GetContainer("ProductsDB", "Products");
var leaseContainer = client.GetContainer("ProductsDB", "leases");

var changeFeedProcessor = monitoredContainer
    .GetChangeFeedProcessorBuilder<Product>(
        processorName: "productChangesProcessor",
        onChangesDelegate: HandleChangesAsync)
    .WithInstanceName("consoleApp")
    .WithLeaseContainer(leaseContainer)
    .Build();

await changeFeedProcessor.StartAsync();
Console.WriteLine("Change Feed Processor started. Listening for changes...");

static async Task HandleChangesAsync(
    ChangeFeedProcessorContext context,
    IReadOnlyCollection<Product> changes,
    CancellationToken cancellationToken)
{
    Console.WriteLine($"Received {changes.Count} changes");

    foreach (var product in changes)
    {
        Console.WriteLine($"Detected change: {product.name}");
        await ProcessProductChangeAsync(product);
    }
}
```

### Change Feed Key Concepts

For the exam, remember these critical points:

**Ordering**: Changes are ordered per partition key, but not across partition keys.

**Insert and Update Only**: The change feed captures inserts and updates, but NOT deletes. If you need to track deletions, implement soft deletes with a deleted flag.

**At-Least-Once Delivery**: Changes are delivered at least once. Your processing logic should be idempotent.

**Lease Container**: The lease container tracks which changes have been processed, enabling multiple consumers and resumption after failures.

**Persistence**: Changes remain in the change feed indefinitely, unlike message queues that expire messages.

### Change Feed Use Cases

The exam might present scenarios like:

**Real-time Analytics**: Stream changes to an analytics pipeline for real-time insights.

**Event-Driven Architecture**: Trigger Azure Functions when data changes, enabling reactive workflows.

**Data Replication**: Sync data to other databases or services for different access patterns.

**Materialized Views**: Maintain denormalized views optimized for specific queries.

**Audit Trail**: Track all changes for compliance and auditing requirements.

## Exercise 5: Indexing Policies

Indexing policies are crucial for optimizing both performance and cost.

### Default Indexing

By default, Cosmos DB automatically indexes all properties in all items. This is convenient but might not be optimal for your workload.

Check the current indexing policy:

```bash
az cosmosdb sql container show \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --query 'resource.indexingPolicy'
```

### Custom Indexing Policy

For production workloads, you'll often want to customize indexing. Here's an example policy:

```json
{
  "indexingMode": "consistent",
  "automatic": true,
  "includedPaths": [
    {
      "path": "/name/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "String"
        }
      ]
    },
    {
      "path": "/category/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "String"
        }
      ]
    },
    {
      "path": "/price/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "Number"
        }
      ]
    }
  ],
  "excludedPaths": [
    {
      "path": "/description/*"
    },
    {
      "path": "/images/*"
    }
  ]
}
```

This policy:
- Indexes name, category, and price for efficient queries
- Excludes description and images, which are large and rarely queried
- Uses Range indexes for both equality and range queries

Update the policy:

```bash
az cosmosdb sql container update \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --idx @indexing-policy.json
```

### Indexing Trade-offs

**More indexes**:
- Faster reads and queries
- Slower writes (because indexes must be updated)
- Higher storage costs

**Fewer indexes**:
- Slower reads (especially for non-indexed properties)
- Faster writes
- Lower storage costs

**Exam Tip**: Exclude large properties like images, long text descriptions, or binary data that won't be queried.

## Exercise 6: Request Units and Throughput

Understanding Request Units is essential for the exam, as many questions involve optimizing costs.

### Throughput Models

**Database-level throughput** is shared across all containers:

```bash
az cosmosdb sql database create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -n SharedDB \
  --throughput 1000
```

This allocates 1000 RU/s shared among all containers in the database.

**Container-level throughput** is dedicated to one container:

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d SharedDB \
  -n HighPriorityData \
  --partition-key-path "/id" \
  --throughput 2000
```

This container gets a dedicated 2000 RU/s that isn't shared with other containers.

**Autoscale** automatically adjusts based on load:

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d SharedDB \
  -n AutoScaleData \
  --partition-key-path "/id" \
  --max-throughput 4000
```

Autoscale adjusts between 10% of max (400 RU/s) and the specified maximum (4000 RU/s) based on actual usage.

### Monitoring RU Consumption

```csharp
ItemResponse<Product> response = await container.CreateItemAsync(product);
Console.WriteLine($"Create RU charge: {response.RequestCharge}");

var query = container.GetItemQueryIterator<Product>(queryDefinition);
var results = await query.ReadNextAsync();
Console.WriteLine($"Query RU charge: {results.RequestCharge}");
```

Always monitor RU charges during development to understand the cost of your operations.

### RU Optimization Strategies

**Include partition key in queries**: This is the single most important optimization. Queries with a partition key only scan one partition.

**Use point reads**: ReadItemAsync with both id and partition key is the most efficient operation - only 1 RU for a 1 KB item.

**Limit query results**: Use MaxItemCount to paginate and avoid scanning entire containers.

**Index only needed properties**: Reduce write costs by excluding large or rarely-queried properties from indexing.

**Use appropriate consistency**: Strong consistency costs twice as much as Session consistency for reads.

**Batch operations**: Process multiple items together for better efficiency:

```csharp
List<Task> tasks = new List<Task>();
foreach (var product in products)
{
    tasks.Add(container.CreateItemAsync(product, new PartitionKey(product.category)));
}
await Task.WhenAll(tasks);
```

**Cache frequently accessed data**: Use Azure Cache for Redis to reduce Cosmos DB queries for hot data.

**Exam Tip**: Questions about cost optimization almost always involve checking if the partition key is included in queries.

## Exercise 7: Time to Live (TTL)

TTL automatically expires items after a specified period, reducing storage costs and simplifying data management.

### Enable TTL on Container

```bash
az cosmosdb sql container update \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --ttl 86400
```

This sets a default TTL of 86400 seconds (24 hours) for all items in the container.

### Set TTL on Individual Items

```csharp
var temporaryProduct = new Product
{
    id = Guid.NewGuid().ToString(),
    name = "Flash Sale Item",
    category = "Electronics",
    price = 49.99m,
    ttl = 3600  // Expires after 1 hour
};

await container.CreateItemAsync(temporaryProduct, new PartitionKey(temporaryProduct.category));
```

### TTL Values

For the exam, remember these TTL values:

**-1**: The item never expires, even if the container has a default TTL.

**null**: The item inherits the container's default TTL.

**Positive number**: The item expires after N seconds from the last modified timestamp.

Use cases include session data, temporary caches, event logs, and any data with a natural expiration.

## AZ-204 Exam Study Points

Let me summarize the key concepts you need to master for the exam.

### APIs Supported

Cosmos DB supports five APIs:
- NoSQL (native, previously called SQL)
- MongoDB (for MongoDB compatibility)
- Cassandra (for Cassandra compatibility)
- Gremlin (for graph databases)
- Table (for Azure Table Storage compatibility)

### Consistency Levels

From strongest to weakest:
1. Strong
2. Bounded Staleness
3. Session (default)
4. Consistent Prefix
5. Eventual

### Partition Strategy

Key points:
- Logical partitions can be up to 20 GB each
- Physical partitions are managed by Cosmos DB
- Choose high-cardinality partition keys
- You cannot change the partition key after creation
- Always include partition key in queries when possible

### Throughput Models

Three models:
- **Provisioned**: Fixed RU/s, predictable cost, best for steady workloads
- **Autoscale**: Dynamic scaling, pay for actual usage, best for variable workloads
- **Serverless**: Pay per request, best for sporadic workloads

### Change Feed

Remember:
- Ordered per partition key, not across partitions
- Captures inserts and updates only (no deletes)
- At-least-once delivery guarantee
- Multiple consumers are supported
- Changes persist indefinitely

### Query Optimization

Critical points:
- Include partition key in WHERE clause
- Use point reads (ReadItemAsync) when you know the id and partition key
- Avoid SELECT * - specify only needed properties
- Use appropriate indexes
- Monitor RU charges during development

## Common Exam Scenarios

Let me walk through some typical exam scenarios.

**Scenario 1**: A globally distributed app needs strong consistency.

**Solution**: Use Strong consistency level, but understand this limits write availability in multi-region scenarios. Strong consistency requires quorum coordination across regions.

**Scenario 2**: Process every change to items in real-time for analytics.

**Solution**: Implement a Change Feed Processor that monitors the container and streams changes to your analytics pipeline.

**Scenario 3**: Optimize query performance for specific properties that are frequently queried.

**Solution**: Create a custom indexing policy with included paths for those properties and excluded paths for large or rarely-queried properties.

**Scenario 4**: Automatically delete old data to reduce storage costs.

**Solution**: Set TTL at the container level for a default expiration, or on individual items for item-specific expiration.

**Scenario 5**: Reduce RU consumption for queries that are running expensive cross-partition scans.

**Solution**: Redesign queries to include the partition key, or consider changing the partition key strategy if queries consistently need to scan all partitions.

## Best Practices Summary

For the exam and real-world applications:

1. **Choose partition keys carefully** - Consider query patterns, data distribution, and cardinality

2. **Use Session consistency** - It's the right choice for most applications

3. **Customize indexing policies** - Exclude unnecessary paths to optimize write performance and costs

4. **Always include partition key in queries** - Avoid cross-partition queries when possible

5. **Monitor RU consumption** - Track RU charges and identify optimization opportunities

6. **Use the latest SDK** - Take advantage of bulk operations and other performance features

7. **Test with production-like data** - Performance characteristics change significantly with scale

## Cleanup

Delete the resource group when you're finished:

```bash
az group delete -y -n labs-cosmos-az204 --no-wait
```

This removes all resources and stops billing.

## Closing

You now have comprehensive coverage of the Cosmos DB topics tested on the AZ-204 exam. Focus on understanding:

- When to use each consistency level
- How to choose effective partition keys
- How to perform SDK operations efficiently
- When and how to use change feed
- How to optimize indexing policies
- How to minimize RU consumption

Practice these concepts hands-on, as the exam includes scenario-based questions that test your practical understanding, not just theory.

For additional study, review the Microsoft Learn modules on Cosmos DB and work through the sample code in the Azure Cosmos DB SDK documentation.

Good luck with your AZ-204 exam preparation!
