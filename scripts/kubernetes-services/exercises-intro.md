We've covered how Services provide stable networking endpoints for pods enabling service discovery and load balancing. Now let's create different service types and understand their use cases.

We'll start by exploring the API specs to understand how Service definitions work, including the network ports and label selector. Services and Pods are loosely coupled, with Services finding target Pods using label selectors. Then we'll run sample Pods from definitions which contain labels, working with multiple objects and deploying multiple YAML manifests with Kubectl. You'll check the status for all Pods printing IP addresses and labels, and see that Pod names have no effect on networking as Pods can't find each other by name alone.

Next, we'll deploy an internal Service. Kubernetes provides different types of Service for internal and external access to Pods. ClusterIP is the default and it means the Service gets an IP address which is only accessible within the cluster, for components to communicate internally. You'll deploy a ClusterIP service which routes traffic to the whoami Pod and print its details. The Service has its own IP address which is static for the life of the Service.

From there, we'll use DNS to find the Service. Kubernetes runs a DNS server inside the cluster and every Service gets an entry, linking the IP address to the Service name. You'll see how Pods can communicate using DNS names instead of IP addresses. When you recreate the whoami Pod and the replacement gets a new IP address, service resolution with DNS still works because the Service IP address doesn't change. The Service routes traffic to the new Pod automatically.

Then we'll deploy an external Service. There are two types of Service which can be accessed outside of the cluster: LoadBalancer and NodePort. LoadBalancers are easier to work with and are supported in Docker Desktop and managed Kubernetes clusters like AKS. NodePort works for clusters which don't support LoadBalancer Services. You'll deploy both types and see how you can call the whoami app from your local machine.

The lab challenge explores how Services are a networking abstraction, like routers which listen for incoming traffic and direct it to Pods. Target Pods are identified with a label selector, and there could be zero or more matches. You'll test scenarios with zero Pods matching and multiple Pods matching to understand what happens. Finally, we'll do cleanup. The key learning is that Services abstract pod networking providing stable endpoints, automatic load balancing, and service discovery via DNS, making them essential for building reliable microservices architectures in Kubernetes.
