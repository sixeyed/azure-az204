We've covered Docker as a solution for consistent application deployment by packaging apps and dependencies into images. Now let's get hands-on with Docker fundamentals and see how containers solve deployment challenges.

You'll start by looking at the reference documentation including Docker Desktop, the getting started guide, and the various .NET container images available. Then you'll run a .NET web container to understand the basic workflow. You'll use the docker run command to start containers from images like nginx and ASP.NET samples. The command has several flags where the d flag puts the container in the background and the p flag publishes a port on the container so Docker can route network traffic in. You'll see how Docker listens on a port of your machine and sends traffic into a port of the container. You'll also use other docker commands to manage your container apps including docker ps to list running containers and docker logs to get the logs from a container.

Next, you'll explore runtime and SDK images to understand the different variations Microsoft publishes. Runtime images contain only what's needed to run compiled apps but not to build apps from source code. You can run a container interactively so you connect to a shell session in the container, which is like creating a VM in the cloud and running SSH to connect. You'll explore the environment and see what runtimes and SDKs are installed. SDK images include both the runtime and development tools, so you can create and run new applications inside the container. Building apps inside a container is a good way of experimenting.

After that, you'll work on building .NET apps in containers to see the real value of Docker in packaging your own images. You'll use a Dockerfile which is a script that packages an application in Docker. It uses the SDK image to build the app and the runtime image to run the app. You can build and run an app without installing the specific version on your machine. You'll use docker build to create an image from the Dockerfile and source code, seeing Docker print the output from dotnet commands as it builds and compiles the app. Then you'll run a background container from the new image. The app is very simple but you can improve it by editing code and running the build command again to package up your changes.

The lab exercise introduces environment variables as a way to inject configuration settings into the app when you run a container. Container images are static packages like ZIP files with all your application binaries and dependencies, so things that change between environments need to be handled differently. Environment variables can be set when you run the container and get read by the application configuration system. You'll run a new container with a specific environment name displayed on the homepage. Finally, you'll look at cleanup procedures to remove all the containers when you're done. Let's master Docker fundamentals!
