# Docker 101 - AZ-204 Exam Exercises

Understanding Docker containers is absolutely essential for the AZ-204 Azure Developer Associate certification. Containers are foundational to several Azure services and appear across multiple domains of the exam. These exercises establish the foundation you need before working with Azure Container Instances, Azure Container Registry, Azure App Service containers, and Azure Kubernetes Service.

## Prerequisites

You should have Docker Desktop installed and running on your local machine. Familiarity with command line interfaces is helpful. These exercises assume you're new to Docker but comfortable working with the terminal. The skills you learn here directly transfer to working with containers in Azure.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency with containerization fundamentals that apply across all Azure container services. You'll need to understand how Docker images and containers work because this knowledge underpins everything else. Building images from Dockerfiles is crucial because you'll create custom images for Azure services. Managing container lifecycle with commands like run, ps, logs, and rm appears in troubleshooting scenarios. Configuring containers with environment variables is essential for Azure deployments. Understanding the difference between runtime and SDK images helps you optimize image sizes and security. Multi-stage builds create efficient production images that you'll deploy to Azure.

## Container Images Are Immutable

This is a crucial concept for the exam. Once you build an image, it doesn't change. When you edited code in the lab, you had to rebuild the image to get a new version. In Azure, this means when you update your application, you build a new image version and redeploy it. This immutability provides consistency and reliability. Every time you run a container from an image, you get exactly the same starting state.

The exam frequently tests your understanding of this concept. Questions might ask what happens when you update application code or configuration. The answer involves building a new image with a new tag and deploying that new version. You cannot modify a running container's image or update code inside a container and expect those changes to persist.

Understanding image layers is also important. Docker images are built in layers, with each Dockerfile instruction creating a new layer. When you rebuild an image, Docker reuses unchanged layers from cache. This makes rebuilds faster and deployments more efficient. The exam might ask about optimizing build times, and understanding layer caching is part of the answer.

## Configuration Through Environment Variables

The exam frequently tests your understanding of how to configure containerized applications. Environment variables are the primary mechanism. Whether you're working with ACI, App Service containers, or AKS, you'll be setting environment variables to configure your apps.

For the exam, you need to know how to set environment variables when creating containers using the -e flag. You should understand that sensitive values like connection strings must use environment variables rather than hardcoding in images. In Azure services, you'll reference Azure Key Vault secrets as environment variables for better security.

The simple-web lab demonstrated this by showing how the same image displays different environment names based on the Environment variable. This pattern applies everywhere in Azure. Your development environment points to dev databases through environment variables. Staging uses staging variables. Production uses production variables. Same image, different configuration.

## Port Mappings and Networking

Understanding how containers expose network endpoints is essential for the exam. In the lab, you used the -p flag to publish ports from containers to your host machine. The format is host-port colon container-port, like -p 8080:80.

In Azure services, port mapping works differently for each service. ACI exposes containers on specific ports and can assign DNS names. App Service handles port mapping automatically but you need to tell it which port your container listens on. AKS uses Services to expose containers on specific ports.

The exam tests your understanding of networking in scenarios like debugging why an application isn't accessible or choosing the right port configuration for a service. Remember that containers can always talk to each other on internal networks using container ports. Published ports are for external access.

## Multi-Stage Builds

The Dockerfile you examined used a multi-stage build, building with the SDK image and running with the runtime image. This is a best practice that the exam expects you to understand. Multi-stage builds reduce final image size by excluding build tools from production images. They improve security by removing compilers and development tools that aren't needed in production. They speed up deployments with smaller images that transfer faster.

The exam presents scenarios requiring you to optimize container images for production. The answer often involves multi-stage builds. Questions might show a Dockerfile and ask you to identify problems or improvements. Look for using appropriate base images, copying only necessary artifacts between stages, and ensuring production images don't include development dependencies.

## Connecting to Azure Services

Docker containers in Azure don't run in isolation. They integrate with other Azure services that appear on the AZ-204 exam. Understanding these integration patterns is crucial.

Azure Storage provides persistent data for containers. Containers are stateless by default, losing data when they stop. For persistent data, containers mount Azure Storage Blob or File Share as volumes. This is commonly tested in ACI scenarios. You might see a question asking how to persist data from a containerized application, and the answer involves mounting an Azure Files share.

Azure Key Vault stores secrets that containers retrieve at runtime. You should never hard-code secrets in Docker images. Instead, containers running in Azure retrieve secrets from Key Vault. The exam may ask you to configure ACI or App Service to pull secrets from Key Vault, often using managed identities for authentication.

Azure Monitor and Application Insights provide observability for containerized applications. Container logs that you viewed with docker logs get sent to Azure Monitor in production. Application Insights can monitor containerized applications just like any other .NET app. Understanding container logging is important for troubleshooting scenarios on the exam.

Virtual Networks provide network isolation and security. Azure container services can be integrated into VNets. The exam tests your knowledge of running ACI containers in VNets, connecting App Service containers to VNets, and configuring network policies in AKS.

## Choosing the Right Container Service

The exam frequently asks you to choose between ACI, App Service Containers, and AKS based on requirements. Understanding when each is appropriate is crucial.

Azure Container Instances works best for simple single containers, serverless scenarios, and quick deployments. Use ACI for burst workloads, batch jobs, development and test environments, or task automation. Don't use ACI for complex microservices requiring orchestration, applications needing auto-scaling, or stateful applications requiring persistent volumes.

App Service Containers suits web apps with managed features like auto-scale, deployment slots, and custom domains. Use App Service for web applications, REST APIs, or when you want Azure App Service features with container flexibility. Don't use it for complex multi-container orchestration or when you need complete control over the container runtime.

Azure Kubernetes Service provides complex multi-container applications, microservices, and full orchestration. Use AKS when you need service discovery, auto-scaling with custom metrics, stateful applications, or when your team has Kubernetes expertise. Don't use AKS for simple single-container apps or when simplicity is more important than features.

The exam presents scenarios and expects you to identify the right service. Look for keywords: "simple" and "temporary" suggest ACI. "Web app" with "auto-scale" suggests App Service. "Microservices" with "orchestration" suggests AKS.

## Dockerfile Best Practices

The exam tests your knowledge of Dockerfile best practices. Use multi-stage builds with appropriate base images. For .NET, use dotnet/sdk for building and dotnet/runtime or dotnet/aspnet for running. For Node.js, use node images with specific versions. For Go, you can build with golang and run from scratch for minimal images.

Order instructions from least to most frequently changing. Put package installation before code copying. This maximizes layer caching. The COPY command should copy only necessary files, using .dockerignore to exclude unnecessary content. Combine RUN commands where possible to reduce layers. Expose ports that your application listens on. Set appropriate working directories. Use non-root users for security.

The exam might show a problematic Dockerfile and ask you to identify issues. Look for not using multi-stage builds, inefficient layer ordering, copying unnecessary files, running as root, or not exposing required ports.

## AZ-204 Exam Study Points

Let's consolidate the key points for the exam. Container images are immutable packages containing your application, runtime, and dependencies. Building a new version requires creating a new image with a new tag.

Environment variables configure containerized applications across all Azure services. Use them for all configuration, especially connection strings and secrets. In production, reference Key Vault secrets rather than hardcoding values.

Port mappings expose container endpoints. Format is host-port:container-port. Azure services handle this differently but the concept remains the same.

Multi-stage builds optimize images by using SDK images for building and runtime images for production. This reduces size, improves security, and speeds deployment.

Integration with Azure services includes Storage for persistence, Key Vault for secrets, Monitor and Application Insights for observability, and Virtual Networks for isolation.

Choosing the right service depends on complexity and requirements. ACI for simplicity, App Service for web apps with managed features, AKS for complex orchestration.

Understanding these concepts at a practical level is what the exam tests. Practice building images, running containers, and troubleshooting issues. The hands-on experience from these labs provides the real-world skills that the AZ-204 certification validates.

## Cleanup

Removing containers is straightforward with docker rm. The -f flag forces removal of running containers. Using docker ps -aq lists all container IDs which you can pipe to docker rm -f for bulk deletion. This cleanup pattern is useful for development but in production you'll use Azure services to manage container lifecycle.
