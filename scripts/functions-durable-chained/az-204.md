# Azure Durable Functions - AZ-204 Exam Focus

## Exam Relevance

Azure Durable Functions are an important topic in the AZ-204 exam under the "Implement Azure Functions" domain. You need to understand when to use durable functions, how they work, and how to implement common patterns. Let's focus on the key concepts the exam expects you to know.

## Understanding Durable Functions Architecture

For the exam, you must understand that durable functions are an extension of Azure Functions that enable stateful workflows in a serverless environment.

**Key Concept**: Regular Azure Functions are stateless and short-lived. Each execution is independent. Durable functions, however, maintain state across multiple function executions. The framework manages this state automatically using Azure Storage.

The architecture consists of three main components:

**Client Functions**: These start orchestrations. They use the DurableClient binding, which gives them access to start, query, and manage orchestration instances. Any function can be a client - HTTP triggers, timer triggers, queue triggers, whatever makes sense for your scenario.

**Orchestrator Functions**: These define the workflow logic. They use the OrchestrationTrigger binding. The orchestrator calls activities, handles their results, and determines what happens next. Crucially, orchestrators are deterministic and can be replayed.

**Activity Functions**: These perform the actual work. They use the ActivityTrigger binding and can only be called by orchestrators. Activities can do anything a normal function can do - call APIs, access databases, perform calculations.

**Exam Tip**: Know these three function types and their respective bindings. Questions might ask you to identify which binding to use for a specific scenario.

## The Chained Pattern - Exam Perspective

The chained pattern, also called function chaining, is one of five core durable function patterns you should know for the exam.

**Definition**: In function chaining, you execute a sequence of functions in a specific order. The output of one function becomes the input to the next function.

**When to Use**: Choose the chained pattern when you have a workflow where steps must execute sequentially, and each step depends on the output of the previous step. Think data processing pipelines, order fulfillment workflows, or multi-stage transformations.

**Code Pattern**: The orchestrator uses CallActivityAsync to invoke each activity in sequence. It awaits each call, gets the result, and passes it to the next activity.

*[SHOW ON SCREEN: Code example structure]*
```
var result1 = await context.CallActivityAsync<string>("Activity1", input);
var result2 = await context.CallActivityAsync<string>("Activity2", result1);
var result3 = await context.CallActivityAsync<string>("Activity3", result2);
return result3;
```

**Exam Tip**: If a question describes a scenario with sequential steps where each step needs the previous step's output, the chained pattern is likely the answer.

## Other Durable Function Patterns

The exam may test your ability to distinguish between patterns. Know all five:

**Function Chaining**: Sequential execution where output flows from one function to the next. Use for ordered workflows.

**Fan-out/Fan-in**: Execute multiple activities in parallel, then wait for all to complete before continuing. Use for parallel processing that needs to aggregate results.

**Async HTTP APIs**: Long-running operations that return a status endpoint for clients to poll. Use for workflows that take minutes or hours to complete.

**Monitoring**: Recurring process that checks conditions and takes actions. Use for polling scenarios, health checks, or waiting for state changes.

**Human Interaction**: Workflows that pause and wait for external input or approval. Use for approval workflows or processes that need human intervention.

**Exam Tip**: Scenario questions will describe a workflow. Identify whether steps are sequential, parallel, long-running, recurring, or require human input to choose the right pattern.

## Orchestrator Constraints

This is a critical exam topic. Orchestrators have strict constraints because they get replayed during execution.

**Deterministic Code Requirement**: Orchestrators must produce the same result every time they execute with the same input. Why? Because the framework replays orchestrator code from the beginning after checkpoints, skipping activities that already completed.

**What You Cannot Do in Orchestrators**:
- Don't use DateTime.Now or DateTime.UtcNow - the current time changes between replays
- Don't generate random numbers directly - they'll be different each replay
- Don't make HTTP calls directly - external systems might return different results
- Don't read from databases or external state
- Don't create Guids
- Don't use Thread.Sleep or similar blocking calls

**What You Should Do Instead**:
- Use context.CurrentUtcDateTime for the current time
- Use context.NewGuid for unique identifiers
- Call activities to perform non-deterministic operations
- Use context.CreateTimer for delays
- Move all external interactions into activity functions

**Exam Tip**: Expect questions about what code is valid in an orchestrator. If you see DateTime.Now, random numbers, or direct HTTP calls in orchestrator code, that's likely incorrect.

## Bindings and Attributes

Know these bindings for the exam:

**DurableClient**: Provides access to start and manage orchestrations. Used in client functions.

*[SHOW ON SCREEN: Example attribute]*
```
[FunctionName("StartOrchestration")]
public static async Task<HttpResponseMessage> Run(
    [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequestMessage req,
    [DurableClient] IDurableOrchestrationClient starter)
```

**OrchestrationTrigger**: Identifies a function as an orchestrator. Provides the DurableOrchestrationContext.

*[SHOW ON SCREEN: Example attribute]*
```
[FunctionName("MyOrchestrator")]
public static async Task<string> Run(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
```

**ActivityTrigger**: Identifies a function as an activity that can be called by orchestrators.

*[SHOW ON SCREEN: Example attribute]*
```
[FunctionName("MyActivity")]
public static string Run(
    [ActivityTrigger] IDurableActivityContext context)
```

**Exam Tip**: Questions might show code and ask you to identify missing or incorrect bindings. Make sure you can recognize which binding belongs with which function type.

## State Management and Durability

Understand how durable functions maintain state:

**Storage Account Requirement**: Durable functions require a storage account specified in the AzureWebJobsStorage setting. This storage holds orchestration state, execution history, and work items.

**Task Hubs**: A task hub is a logical container for durable function storage resources. Multiple function apps can share a storage account by using different task hub names. The default task hub name is derived from the function app name.

**Execution History**: The framework stores the complete execution history in Azure Storage tables. This enables replay, monitoring, and debugging. You can query the history to see what happened during an orchestration.

**Checkpointing**: After each await in an orchestrator, the framework saves a checkpoint. If the function is interrupted, it restarts from the last checkpoint rather than the beginning.

**Exam Tip**: Know that durable functions require Azure Storage and understand what's stored there. Questions might ask about configuration requirements or troubleshooting storage-related issues.

## Input and Output Management

Understand how data flows through durable functions:

**Starting Orchestrations**: When you call StartNewAsync on the client, you can pass an input object. This becomes available to the orchestrator via context.GetInput.

**Activity Inputs**: When calling CallActivityAsync, you specify the input parameter. This is passed to the activity function.

**Activity Outputs**: Activities return values using standard return statements. These become the result of the CallActivityAsync call in the orchestrator.

**Orchestrator Outputs**: Orchestrators can return values, which become the final result of the orchestration. Clients can retrieve this using GetStatusAsync.

**Data Serialization**: All inputs and outputs are serialized as JSON. Keep objects simple and serializable. Avoid complex types that don't serialize well.

**Exam Tip**: Questions might show code and ask how to pass data between functions or retrieve orchestration results. Understand the flow: client to orchestrator, orchestrator to activity, activity back to orchestrator, orchestrator to result.

## Error Handling and Retries

Durable functions provide robust error handling:

**Automatic Retries**: You can configure automatic retry policies for activities. Specify max attempts, backoff, and timeout.

*[SHOW ON SCREEN: Retry policy code structure]*
```
var retryOptions = new RetryOptions(
    firstRetryInterval: TimeSpan.FromSeconds(5),
    maxNumberOfAttempts: 3);

await context.CallActivityWithRetryAsync<string>("Activity", retryOptions, input);
```

**Exception Handling**: If an activity throws an exception without retries configured, the exception propagates to the orchestrator. You can catch and handle it with try-catch blocks.

**Compensation Logic**: In chained patterns, if a later step fails, you might need to undo earlier steps. Implement compensation by catching exceptions and calling "undo" activities.

**Exam Tip**: Know how to implement retry policies and understand when exceptions propagate versus when they're retried. Questions might present a scenario where activities occasionally fail and ask how to make the workflow resilient.

## Monitoring and Debugging

For the exam, know how to monitor and troubleshoot durable functions:

**Application Insights**: Durable functions automatically integrate with Application Insights when configured. You can see orchestration execution timelines, activity durations, and failures.

**Built-in HTTP APIs**: The DurableClient provides APIs to query orchestration status, get history, raise events, and terminate instances. These APIs follow REST patterns.

**Instance IDs**: Each orchestration instance has a unique ID. You can specify this when starting an orchestration or let the framework generate one. Use instance IDs to query status or send events.

**Portal Integration**: The Azure Portal shows durable function executions in the Monitor section. You can see orchestrators, their activities, and execution timelines.

**Exam Tip**: Know that Application Insights is the primary monitoring tool. Questions about troubleshooting or performance analysis will likely involve Application Insights integration.

## Configuration and Deployment

Understand deployment considerations:

**Function App Requirements**: Durable functions work with both Consumption and Premium plans. Premium plans provide better performance for complex orchestrations.

**Host.json Configuration**: You can configure durable function behavior in host.json, including max concurrent activities, max concurrent orchestrators, and extended sessions.

**Application Settings**: Your function app needs AzureWebJobsStorage configured. Activity functions that access other Azure services need their connection strings in app settings.

**Local Development**: Use local.settings.json for local development. This file should never be committed to source control as it contains secrets.

**Deployment**: Deploy durable functions like any other function app - using Visual Studio, VS Code, Azure CLI with func azure functionapp publish, or CI/CD pipelines.

**Exam Tip**: Questions might ask about required configuration or troubleshooting deployment issues. Know that AzureWebJobsStorage is mandatory and how to configure app settings for Azure services.

## Security Considerations

For the AZ-204 exam, understand security implications:

**Authorization Levels**: Client functions often use HTTP triggers. Set appropriate authorization levels - Function requires a function key, Admin requires the master key, Anonymous allows anyone.

**Connection String Security**: Never hardcode connection strings. Use app settings, which are stored securely in Azure and injected as environment variables.

**Managed Identities**: For production, use managed identities instead of connection strings when accessing Azure resources. Durable functions support this pattern.

**Network Isolation**: Function apps can be deployed with VNet integration for private access to resources. Durable functions work in these scenarios.

**Exam Tip**: Security questions often focus on not exposing secrets. Know to use app settings, managed identities, and appropriate authorization levels.

## Cost Considerations

Understanding costs helps with architectural decisions:

**Execution Charges**: Like all Azure Functions, you pay for execution time and executions. Orchestrators and activities each count as executions.

**Storage Costs**: Durable functions store state in Azure Storage. This includes tables for history and queues for work items. These incur standard storage costs.

**Consumption vs Premium**: Consumption plan charges per execution. Premium plan has a base cost but better performance and features like VNet integration.

**Optimization**: To reduce costs, minimize orchestrator replay by keeping orchestrators simple. Move complex logic into activities. Use single-activity replay when possible.

**Exam Tip**: Cost questions might compare durable functions to alternatives like Logic Apps or custom solutions. Know that durable functions are cost-effective for many workflows but require understanding of the execution model.

## Comparison with Logic Apps

The exam might ask when to use Durable Functions versus Logic Apps:

**Durable Functions**:
- Code-first approach with full programming language power
- Better for complex logic, custom algorithms, or when you need programmatic control
- Integrates naturally with other Azure Functions code
- Developer-friendly with standard debugging tools
- Cost-effective for high-volume workflows

**Logic Apps**:
- Designer-first approach with visual workflow design
- Better for non-developers or when visual design is preferred
- Extensive built-in connectors for SaaS applications
- Easier to modify without code changes
- Higher cost per execution but simpler to build

**Exam Tip**: Scenario questions will hint at the preferred solution. Look for keywords like "developers prefer code" or "business users need to modify" to guide your choice.

## Real-World Scenarios for the Exam

Practice identifying when durable functions are appropriate:

**Good Use Cases**:
- Multi-step data processing pipelines
- Order fulfillment workflows with multiple stages
- ETL processes that transform data through several steps
- Approval workflows that coordinate multiple approvals
- Long-running background jobs with checkpoints

**Poor Use Cases**:
- Simple request-response operations - use regular functions
- Real-time high-frequency operations - consider Event Hubs
- Simple scheduled tasks - use regular timer functions
- Workflows that never need state - use regular functions

**Exam Tip**: Scenario questions will describe requirements. Ask yourself: Is there state? Are there multiple steps? Do steps need coordination? If yes to all, durable functions are likely correct.

## Common Exam Question Patterns

Based on typical AZ-204 questions, expect these types:

**Identify the Pattern**: Given a workflow description, choose the correct durable function pattern. Look for keywords like "sequential" (chained), "parallel then aggregate" (fan-out/fan-in), "long-running" (async HTTP), "periodic checks" (monitoring), or "wait for approval" (human interaction).

**Fix the Code**: Presented with orchestrator code that violates constraints. Identify what's wrong, like using DateTime.Now instead of context.CurrentUtcDateTime.

**Choose the Binding**: Given a function type, select the correct attribute - DurableClient, OrchestrationTrigger, or ActivityTrigger.

**Configuration Problems**: Troubleshoot a deployment where durable functions aren't working. The issue is usually missing AzureWebJobsStorage or incorrect connection strings.

**Architecture Decisions**: Compare durable functions to alternatives like Logic Apps, Service Bus, or custom solutions. Choose based on requirements like developer control, cost, or complexity.

## Study Tips for the Exam

To prepare effectively:

**Hands-On Practice**: Build actual durable functions like in this lab. Understanding comes from doing, not just reading.

**Understand Constraints**: The orchestrator constraints are frequently tested. Practice identifying what's allowed and what's not.

**Know All Patterns**: Study all five patterns with examples. Be able to quickly identify which pattern fits a scenario.

**Review Bindings**: Memorize the three binding types and when to use each one.

**Practice Scenarios**: Work through scenario-based questions. Given requirements, design a solution using the appropriate pattern and configuration.

**Understand Trade-offs**: Know when durable functions are better than alternatives and when they're not the right choice.

## Final Exam Reminders

Key points to remember on exam day:

Durable functions enable stateful workflows in serverless Azure Functions. Three function types use three specific bindings: DurableClient, OrchestrationTrigger, and ActivityTrigger.

The chained pattern executes activities in sequence, passing output from one to the next. It's for ordered workflows where each step depends on previous results.

Orchestrators must be deterministic. Don't use DateTime.Now, random numbers, or direct external calls. Use context methods instead.

All durable functions require a storage account for state management. Configure this in AzureWebJobsStorage.

Know all five patterns and their use cases. Scenario questions test your ability to choose the right pattern.

Application Insights provides monitoring and debugging. This is the standard answer for observability questions.

Security uses app settings for secrets and managed identities for Azure resource access.

Compare durable functions to Logic Apps based on developer control, visual design, and use case complexity.

## Additional Resources

For deeper study, review these Microsoft Learn modules:

- Implement durable functions
- Create a long-running serverless workflow with Durable Functions
- Chain Azure Functions together using input and output bindings

Practice in the Azure Portal and with the Functions Core Tools. The more you work with durable functions, the more natural the concepts become.

## Conclusion

Durable Functions are a powerful feature for building stateful serverless workflows. For the AZ-204 exam, focus on understanding patterns, constraints, bindings, and when to use durable functions versus alternatives.

The chained pattern you practiced in this lab is foundational - it demonstrates core concepts like orchestration, activity coordination, and data flow that apply to all patterns.

With this knowledge and hands-on experience, you're well-prepared for durable functions questions on the AZ-204 exam. Good luck!
