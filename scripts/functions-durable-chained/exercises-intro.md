We've covered the chained pattern where orchestrators coordinate multiple activity functions to execute sequentially with outputs passed between steps. Now let's build a heartbeat monitoring workflow that demonstrates how function chaining works with multiple activities that depend on each other.

Working with the timer trigger with orchestration shows you a durable function that runs on a schedule using a standard timer trigger. The TimedOrchestratorStart function uses a DurableClient decorator to start the orchestrator, passing it an application status object with details about what's being monitored. This demonstrates how trigger functions can kick off orchestrations and pass initial data to them. The orchestrator itself uses an OrchestrationTrigger and runs three activities in sequence, with the output from the first WriteBlob activity becoming the input to both the NotifySubscribers and WriteLog activities that run afterwards.

When you test the function locally, you'll need to set up a Service Bus namespace in Azure since there's no local emulator for Service Bus. You'll run the Azure Storage emulator in Docker to handle the blob and table storage that the activities use. Once you create the local settings file with your Service Bus connection string, you'll start the function and watch the timer trigger fire. The orchestrator logs show each activity executing in order, with WriteBlob creating a blob in the heartbeat container, NotifySubscribers sending a message to the Service Bus queue, and WriteLog recording the activity in table storage. You can verify everything worked by checking the Service Bus Explorer for messages and querying table storage for the heartbeat entries.

When you deploy to Azure, you'll create a Function App with all the usual infrastructure, configure the app settings for your Service Bus and Storage Account connection strings, and publish the function. The interesting discovery here is that when you check the Functions list in the Portal, you only see the functions with external triggers like the timer trigger. The orchestrator and activity functions don't show up because they can only be invoked internally by the Durable Functions runtime, not directly from outside triggers.

The lab challenge explores what happens if you try to disable individual activity functions. You discover that while you can disable the timer trigger to stop the whole workflow, you cannot disable activity functions because they're not exposed as separate entities in the Portal. This demonstrates that the orchestrator is the only entry point for controlling which activities execute, and you'd need to change the orchestrator code itself to skip activities, not disable them through configuration.

Let's implement reliable sequential workflows with automatic state management!
