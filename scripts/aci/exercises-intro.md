Now that we've covered what Azure Container Instances is and when to use it, let's put that knowledge into practice with hands-on exercises.

We'll start by exploring Azure Container Instances through the Portal, where you can see all the configuration options available when creating a new container instance. You'll examine the image registry settings, whether you're pulling from Docker Hub or your own Azure Container Registry, and you'll see how to specify the container image you want to run. The compute size selection lets you choose how many CPU cores and how much memory your container needs. In the networking section, you'll discover how to publish ports to make your application accessible and choose a DNS name so people can reach your app. The advanced options reveal settings for environment variables, restart policies, and other container configuration details.

From there, we'll move into creating an ACI container with the CLI, where you'll use the az container create command to deploy a real web application. You'll work with a simple ASP.NET app, publish it on port 80, and configure a DNS name so you can browse to it. This is where you'll see how quickly ACI provisions infrastructure compared to virtual machines. The command returns an FQDN field showing you the full domain name for your application. You'll also learn how to work with the container after it's running, using commands to print logs and check the application status.

The really interesting part comes when we deploy to ACI from Docker. If you're already comfortable with Docker commands, this will feel very natural. You'll start by logging into Azure from the Docker CLI, then create an ACI context that points your Docker commands at a specific resource group in Azure. Once you've switched to that context, you can use familiar Docker commands like docker run, docker ps, and docker logs, but instead of managing containers on your local machine, they're creating and managing containers running in Azure. You'll see that not all Docker commands work with ACI, but the most common ones do, and the experience feels just like working locally.

The lab exercise challenges you to explore Windows containers versus Linux containers in ACI. You'll deploy both Windows and Linux variants of the same application image and compare how they behave. There's also an interesting experiment with architecture-specific images, where you'll see what happens when you try to run an ARM-compiled image on ACI's Intel or AMD processors. This teaches important lessons about image compatibility and platform selection.

Finally, when you're finished experimenting, the cleanup section shows you how to delete the resource group to remove all containers, including the ones you created with the Docker CLI. You'll also switch your Docker context back to the default local context and remove the ACI context you created. Let's get hands-on with Azure Container Instances!
