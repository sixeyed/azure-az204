# Azure Container Instances - AZ-204 Exam Exercises

Azure Container Instances appears in the AZ-204 exam under the containerized solutions domain, which typically accounts for ten to fifteen percent of your exam score. These exercises go beyond the basics and focus specifically on the scenarios and features you'll encounter in the exam. The AZ-204 exam tests not just your ability to create and run containers, but your understanding of production scenarios like multi-container groups, persistent storage, resource management, and security integration.

## Prerequisites

You should complete the basic ACI lab before diving into these exam-focused exercises. The fundamental concepts like container creation, port publishing, and Docker CLI integration are essential building blocks. These advanced exercises assume you're comfortable with the basics and ready to explore the features that distinguish production deployments from simple development scenarios.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of ACI capabilities. You'll need to understand container groups and how multiple containers share resources and network. Deploying with environment variables and secrets is crucial for secure configuration management. Mounting Azure Files volumes for persistent storage comes up frequently in exam scenarios. Setting resource limits for CPU and memory demonstrates understanding of cost management. Configuring restart policies shows you know how to handle different workload types. Accessing logs and executing commands is essential for troubleshooting. Pulling images from private registries addresses security requirements. Finally, you must understand when to use ACI versus Container Apps versus AKS because the exam loves decision scenarios.

## Container Groups and Multi-Container Deployments

Understanding container groups is fundamental to the AZ-204 exam because they represent how ACI handles complex applications. A container group is a collection of containers that get scheduled on the same host machine, sharing a lifecycle, resources, local network, and storage volumes. This is similar to a pod in Kubernetes, and the exam frequently tests this analogy.

Containers within a group share everything. They have the same lifecycle meaning they start and stop together. They share a network namespace so they can communicate via localhost without any special configuration. They can mount the same storage volumes for sharing data. They use the same public IP address and port namespace, which means you need to be careful about port conflicts.

The sidecar pattern is a common exam scenario where you have a main application container plus a logging or monitoring container. The ambassador pattern uses a proxy container to handle outbound connections. The adapter pattern has a container that transforms data for the main application. All these patterns work well with container groups and appear in exam questions.

When you deploy multi-container groups using YAML definitions, you specify each container's image, resources, ports, and environment variables. The group level defines the shared IP address and DNS label. Understanding this hierarchy is crucial for the exam because questions often ask about communication between containers or resource allocation within groups.

## Environment Variables and Secrets

The exam heavily emphasizes secure configuration management. Regular environment variables are visible in container properties and logs, making them suitable for non-sensitive configuration like feature flags, log levels, and public endpoints. These are straightforward to set and easy to inspect for debugging.

Secure environment variables are encrypted and never visible in container properties or CLI output. This makes them essential for passwords, API keys, and connection strings. The exam tests your knowledge of when to use secure variables versus regular variables. A common scenario describes an application needing database credentials and asks how to provide them securely.

For even better security, you should integrate with Azure Key Vault. Secure environment variables in ACI are better than hardcoding secrets, but Key Vault provides centralized secret management, access policies, and audit logging. The exam may present a scenario requiring Key Vault integration, and you need to know that ACI can reference Key Vault secrets through managed identities.

## Mounting Azure Files Volumes

Containers are stateless by default, losing all data when they stop. For persistent data, ACI supports mounting Azure Files shares as volumes. The share appears as a directory inside the container, but writes actually go to Azure Storage, persisting beyond the container lifecycle.

Creating this integration requires several steps. First you create a Storage Account and file share. Then you retrieve the storage account name and access key. In your container definition, you specify these credentials along with the share name and mount path. Multiple containers can mount the same share simultaneously, enabling data sharing patterns.

The exam tests several aspects of this functionality. Questions might ask about data persistence scenarios and expect you to identify Azure Files as the solution. Troubleshooting scenarios might involve incorrect mount paths or authentication failures. Security questions might ask about protecting storage account keys, leading to answers about Key Vault integration or managed identities.

Important exam points include understanding that ACI only supports Azure Files for persistent volumes, not Azure Disk. The volume mount path must be an absolute path inside the container. Multiple containers can share volumes for coordination. Storage account keys should be treated as secrets and stored securely.

## Resource Limits and Cost Management

ACI bills based on CPU cores and memory allocated per second of runtime. Understanding resource allocation is essential for cost optimization and exam success. You specify both CPU and memory requests, which represent the resources guaranteed to your container. These values determine your billing rate.

CPU allocation ranges from point one to four cores in point one increments. Memory allocation ranges from point five gigabytes to sixteen gigabytes. The exam tests your ability to right-size containers based on application requirements. Over-provisioning wastes money, while under-provisioning causes performance issues or failures.

A critical exam concept is that you cannot change CPU or memory for running containers. The only way to update these settings is to delete and recreate the container with new values. This is fundamentally different from virtual machines where you can resize running instances. Understanding this limitation helps you answer scenarios about container updates and resource management.

Container groups aggregate the resource requirements of all containers. If you have three containers each requesting one CPU and one gigabyte, the group needs three CPUs and three gigabytes total. The exam might present complex scenarios asking you to calculate total resource requirements for multi-container groups.

## Restart Policies

The restart policy controls container behavior when the process exits. Understanding the three policies and when to use each is essential for the exam. Always is the default policy where containers restart on any exit whether successful or failed. This is appropriate for long-running services like web servers and APIs that should always be available.

OnFailure policy restarts containers only when they exit with a non-zero exit code, indicating an error. Successful completions don't trigger restarts. This suits batch jobs that might fail due to transient errors but should retry automatically. Tasks that succeed should complete without restarting.

Never policy runs the container once and stops regardless of exit code. This is for one-time tasks like database migrations, backup jobs, or initialization scripts. Once these tasks complete, successfully or unsuccessfully, they shouldn't restart automatically.

The exam presents scenarios describing workload types and expects you to identify the appropriate restart policy. A nightly backup job uses Never. A REST API uses Always. A data processing task that might encounter temporary failures uses OnFailure.

## Container Logs and Troubleshooting

Accessing logs and executing commands in containers is crucial for troubleshooting, a common exam topic. The az container logs command retrieves stdout and stderr output from containers. For multi-container groups, you specify the container name to get logs from a specific container. The follow flag streams logs in real time, useful for watching startup or monitoring live activity.

Container logs are retained for a limited time after termination. For long-term retention and analysis, you should integrate with Log Analytics or Application Insights. The exam might ask about log retention requirements and expect you to identify the need for centralized logging.

The az container exec command runs commands in running containers. This is invaluable for troubleshooting because you can inspect the container filesystem, check running processes, test network connectivity, or view configuration files. The exam often presents debugging scenarios where exec is the solution.

Interactive shell sessions using exec provide the most comprehensive troubleshooting environment. You can run multiple commands, examine state, and understand what's happening inside the container. However, this only works with running containers. For containers that fail immediately on startup, logs are your only diagnostic tool.

## Private Container Registries

Production applications use private registries rather than public Docker Hub images. Azure Container Registry is Microsoft's private registry service that integrates seamlessly with ACI and other Azure services. Understanding authentication methods is critical for the exam.

Username and password authentication uses ACR admin credentials. This is simple but less secure because credentials must be stored in deployment templates or passed as parameters. The admin account should be limited to development and testing scenarios.

Service principals provide authentication for automation and CI/CD pipelines. You create a service principal with appropriate roles like AcrPull for read access or AcrPush for write access. Service principals have client IDs and secrets that can be rotated without affecting the registry itself. This is better than admin accounts for programmatic access.

Managed identity is the most secure authentication method and what the exam recommends for production. Container instances can use system-assigned or user-assigned managed identities to authenticate to ACR without any credentials in the deployment. Behind the scenes, Azure Active Directory handles authentication using the identity's permissions. You assign the AcrPull role to the managed identity, and the container can pull images transparently.

The exam loves questions about securing ACR access. Scenarios might describe different security requirements and ask you to choose the appropriate authentication method. Remember the hierarchy: managed identities are best for Azure services, service principals for automation, and admin accounts only for development.

## Choosing Between ACI, Container Apps, and AKS

Understanding when to use each container service is perhaps the most important exam topic because it appears in multiple scenario questions. ACI is the simplest option providing fast startup in seconds, per-second billing, no infrastructure management, and a simple deployment model. However, it lacks built-in load balancing, auto-scaling, service discovery, and advanced networking features. ACI works best for one-time jobs, simple web apps, and sidecar patterns.

Container Apps builds on ACI with added orchestration features. It provides built-in autoscaling using KEDA, ingress and traffic splitting, Dapr integration, managed load balancing, blue-green deployments, and scale to zero. However, you have less control than AKS and limited customization. Container Apps suits microservices with autoscaling, event-driven applications, HTTP-based APIs, and background processing with queues.

Azure Kubernetes Service offers full Kubernetes features and complete control. You get advanced networking with CNI and network policies, support for Helm charts and operators, StatefulSets and DaemonSets for complex workloads, and complete customization. The tradeoff is higher complexity, required Kubernetes expertise, and more management overhead. AKS is right for complex microservices architectures, applications needing full Kubernetes control, advanced networking requirements, and stateful applications.

The exam presents scenarios and you must choose. A nightly database backup job uses ACI with restart policy Never. A REST API needing autoscaling based on HTTP requests uses Container Apps. A complex e-commerce platform with fifty microservices uses AKS. A containerized test suite in a CI/CD pipeline uses ACI for fast startup and simplicity.

Understanding the migration path helps with exam scenarios. Simple apps start with ACI. Growing apps move to Container Apps when they need autoscaling and managed ingress. Enterprise apps graduate to AKS when they require full Kubernetes features. The exam might describe an application's evolution and ask when to migrate between services.

## AZ-204 Exam Study Points

Let's consolidate the key points you need to master for the exam. Container groups are collections of containers sharing IP, storage, lifecycle, and network namespace, similar to Kubernetes pods. They enable sidecar, ambassador, and adapter patterns that appear frequently in exam scenarios.

Environment variables come in two types. Regular variables are visible and suitable for non-sensitive configuration. Secure variables are encrypted and hidden, required for secrets. For production, integrate with Key Vault using managed identities for centralized secret management.

Azure Files is the only supported persistent storage option for ACI. Volumes survive container restarts and can be shared across containers. Specify storage account credentials, share name, and mount path in your container definition.

Resource management involves CPU allocation from point one to four cores and memory from point five to sixteen gigabytes. Billing is per second based on allocation. You cannot change resources for running containers, only delete and recreate.

Restart policies determine container behavior on exit. Always for long-running services, OnFailure for retry-able jobs, Never for one-time tasks. Choose based on workload type.

Authentication methods have a clear hierarchy. Managed identities are best for Azure services with no credentials to manage. Service principals work for automation and non-Azure systems. Admin accounts are acceptable only for development.

The decision between ACI, Container Apps, and AKS depends on complexity and requirements. ACI for simple containers and batch jobs. Container Apps for microservices with autoscaling. AKS for complex applications needing full Kubernetes control.

Understanding these concepts at a practical level is what separates passing from failing the exam. Microsoft tests application of knowledge, not memorization. Practice the labs, understand why each feature exists and when to use it, and you'll be well-prepared.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything including all containers, networks, and associated resources. The no-wait flag lets the deletion proceed in the background so you can continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization.
