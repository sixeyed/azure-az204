# VM Configuration Automation - AZ-204 Exam Exercises

VM configuration automation appears in the AZ-204 exam as part of the broader infrastructure as code and automation themes that Microsoft emphasizes throughout the certification. While Virtual Machines themselves aren't the primary compute focus of the exam, understanding how to automate their configuration demonstrates principles that apply across all Azure services. The exam expects you to understand when and how to use extensions, cloud-init, and run commands as part of infrastructure automation strategies.

## Prerequisites

You should complete the basic VM lab and understand how to create and connect to Virtual Machines before working through these automation exercises. These materials assume you're comfortable with VM basics and ready to explore automation patterns that eliminate manual configuration steps. Understanding how to automate configuration is crucial for building scalable, repeatable infrastructure deployments that the exam tests extensively.

## AZ-204 Exam Skills Covered

The exam tests several automation concepts through VM configuration scenarios. You need to understand VM extensions and how they run scripts or install software after VM creation. Custom script extensions for both Linux and Windows are common exam topics because they represent a universal pattern for post-deployment configuration. Cloud-init for Linux VMs appears in questions about provisioning-time configuration that must complete before the VM is fully ready. Run commands come up in troubleshooting and on-demand execution scenarios where you need to run scripts without persistent extensions. Network Security Groups and their rule configurations are fundamental to many exam questions, not just for VMs but for all network-connected resources. Understanding the declarative versus imperative configuration approaches helps you answer questions about ARM templates, Bicep, and infrastructure as code. Finally, recognizing when to use each automation mechanism based on timing requirements, persistence needs, and operating system support is essential for scenario-based questions.

## VM Extensions Overview

VM extensions are add-ons that run after the Virtual Machine is created and started. Understanding how extensions work and when to use them is important for the exam because the extension pattern appears across many Azure services, not just standalone VMs.

Extensions execute asynchronously with respect to VM creation. When you create a VM with an extension configured, Azure provisions the VM, starts it, and then begins the extension installation and execution. This means the VM might report as running before your extension has completed its work. This timing consideration comes up in exam scenarios where you need to understand when resources are actually ready for use versus when they appear ready in the portal.

The custom script extension is one of the most commonly used extensions because it provides maximum flexibility. You can run arbitrary shell scripts on Linux VMs or PowerShell scripts on Windows VMs. This allows you to install software, configure settings, download files, register the VM with external services, or perform any task you could do manually through a terminal or remote desktop session. The exam frequently presents scenarios where applications need specific software installed or configuration applied after VM creation, and custom script extensions are often the answer.

Other extensions serve specialized purposes and can appear in exam questions. The Azure Monitor Agent extension enables monitoring and logging integration. The Desired State Configuration extension applies DSC configurations on Windows VMs. The Microsoft Antimalware extension provides virus protection. The Key Vault extension retrieves certificates from Key Vault. Understanding that these specialized extensions exist helps you answer questions about monitoring, security, and integration scenarios.

Extension configuration uses JSON format with a schema that varies by extension type. At a minimum, most extensions require you to specify what they should do, such as which script to run or which settings to apply. More complex scenarios might include downloading scripts from storage accounts, passing parameters, using protected settings for sensitive data, or configuring retry behavior. The exam might show you JSON configuration and ask what it does, or describe requirements and ask you to identify the correct configuration.

Extensions can be added during VM creation using ARM templates or Bicep files, or they can be added to existing VMs using the Azure CLI, PowerShell, or portal. Understanding both approaches matters because exam questions might present either scenario. Adding extensions during creation ensures new VMs are configured consistently. Adding extensions to existing VMs allows you to update configuration or add capabilities without recreating resources.

## Custom Script Extensions

Custom script extensions deserve special attention because they're so flexible and commonly used. The exam frequently tests your understanding of how to use them effectively for different scenarios.

For Linux VMs, the custom script extension runs bash or other shell scripts. You can provide the script inline as a command string, or you can reference a script file stored in Azure Storage, GitHub, or any publicly accessible URL. The inline approach works well for simple commands like installing a package or setting a configuration value. The file-based approach is better for complex scripts or when you want to manage scripts separately from your infrastructure code.

The commandToExecute property is the key configuration element. This specifies the shell command that the extension will run. You can chain multiple commands together using shell operators like double ampersands for sequential execution or semicolons for parallel execution. The exam might present a scenario requiring multiple configuration steps and ask how to accomplish them with a custom script extension.

Error handling in custom script extensions is important to understand. If your script exits with a non-zero code, the extension reports failure. This means you need to handle errors appropriately in your scripts, using techniques like conditional execution with double ampersands or explicit error checking. The exam might ask about troubleshooting failed extensions or how to ensure critical steps complete successfully.

For Windows VMs, the custom script extension runs PowerShell scripts. The configuration schema is slightly different from the Linux version, but the concept is identical. You provide PowerShell commands or script URLs, and the extension executes them on the VM. Common scenarios include installing Windows features, configuring IIS, setting registry values, or installing applications using package managers like Chocolatey.

Protected settings allow you to pass sensitive information to custom script extensions without exposing it in plain text. This matters for scenarios where your script needs credentials to access storage accounts, download from authenticated URLs, or perform operations requiring secrets. The exam emphasizes secure handling of credentials, and protected settings represent the appropriate pattern for extension configuration.

One limitation to understand is that custom script extensions typically run with a timeout, usually around ninety minutes. For very long-running installation or configuration tasks, you might need alternative approaches like having the script trigger background jobs or using Desired State Configuration for Windows. The exam might present a scenario with extensive configuration requirements and expect you to recognize timing constraints.

## Cloud-init for Linux

Cloud-init provides a different approach to Linux VM configuration that's important to distinguish from extensions. Understanding when to use cloud-init versus custom script extensions is a key exam skill.

Cloud-init runs during the VM provisioning process, not after the VM is created. This timing difference is crucial. With cloud-init, the configuration executes as part of the boot sequence, before the VM reports as fully running. This means you can use cloud-init for configuration that must complete before applications start or before the VM is considered ready. Custom script extensions, by contrast, run after the VM is up, which means there's a window where the VM is running but not yet configured.

The configuration format for cloud-init uses YAML rather than JSON, following the cloud-init standard that works across cloud providers. This cross-platform compatibility is part of cloud-init's appeal. If you're familiar with cloud-init from other clouds or on-premises deployments, the same configuration works on Azure VMs. The exam might present cloud-init YAML and ask what it does, or ask you to identify the correct syntax for specific configuration tasks.

Cloud-init can perform many configuration tasks through its declarative syntax. You can install packages by listing them in the packages section. You can write files to disk by providing paths and contents. You can run arbitrary shell commands in the runcmd section. You can configure users, set up SSH keys, manage services, or perform system configuration. The declarative nature of cloud-init makes it powerful for expressing desired state rather than imperative steps.

One important consideration is that cloud-init only runs once, during the first boot of the VM. If you redeploy or restart the VM, cloud-init doesn't run again unless you explicitly reset it. This makes cloud-init ideal for initial provisioning but less suitable for ongoing configuration management. The exam might ask about updating VM configuration after creation, where you'd need to use extensions or other tools rather than cloud-init.

Error handling in cloud-init affects VM availability. If critical cloud-init steps fail, the VM might not complete its boot process or might boot into a degraded state. This is different from extension failures, which don't prevent the VM from running. Understanding this difference helps you answer exam questions about reliability and availability requirements.

The exam often presents scenarios like "ensure a web server is installed and running before the VM is marked as ready" or "configure the system before any applications start." These scenarios point toward cloud-init rather than extensions because of the timing requirement. Recognizing these timing clues is essential for choosing the right automation approach.

## Run Commands

Run commands provide on-demand script execution without installing persistent extensions. This capability is particularly useful for troubleshooting, debugging, and one-time configuration tasks, making it a valuable tool that appears in exam scenarios.

Unlike extensions which persist as resources attached to your VM, run commands execute once and don't leave any installed components. You invoke a run command, it executes on the VM, returns output, and that's the end of it. If you want to run the same command again, you invoke it again. This ephemeral nature makes run commands perfect for interactive scenarios or automation that doesn't need persistence.

The command-id parameter specifies what type of script you're running. RunShellScript executes bash commands on Linux VMs, while RunPowerShellScript executes PowerShell on Windows VMs. These built-in command IDs provide the foundation for running arbitrary scripts. Azure also provides some predefined run commands for common tasks, but the custom script command IDs are what you'll use most often.

You can provide scripts inline as parameters or reference local script files using the @ syntax with the scripts parameter. The inline approach works well for simple commands or when embedding scripts in automation. The file reference approach is convenient when working from the CLI and you have scripts stored locally. The exam might show either syntax and expect you to understand what happens.

Output from run commands returns through the CLI or API that invoked them. This makes run commands useful for gathering information from VMs without logging in. You can run commands to check log files, inspect running processes, test network connectivity, or query system state. The exam might present troubleshooting scenarios where run commands provide the solution without requiring RDP or SSH access.

Security considerations for run commands include understanding that they execute with administrative privileges on the VM. Anyone with contributor access to the VM can run commands, which means they can execute arbitrary code on your VMs. This is why proper role-based access control is important. The exam emphasizes security, and understanding the permissions required for run commands helps you answer questions about access control and least privilege.

Run commands have execution time limits, typically shorter than extension timeouts. This makes them unsuitable for very long-running operations. For tasks that might take many minutes or hours, extensions or other approaches work better. The exam might describe a long-running configuration task where run commands aren't appropriate.

Common exam scenarios involving run commands include "how can you quickly test network connectivity between VMs without logging in," "what's the fastest way to gather diagnostic information from a running VM," or "how do you execute a one-time script without installing an extension." These scenarios point toward run commands as the answer.

## Network Security Groups

Network Security Groups appear throughout the exam, not just in VM scenarios, but understanding them in the context of VM configuration is important. NSGs control network traffic using rules that allow or deny connections based on various criteria.

Default security rules for VMs typically allow outbound internet access but deny inbound access from the internet. This security-first approach means you must explicitly allow any inbound connections you need. The exam frequently tests whether you understand what traffic is blocked by default and how to open access appropriately. A common scenario describes a web server that's been deployed but isn't accessible, with the answer being that you need to add an NSG rule allowing inbound HTTP or HTTPS traffic.

NSG rules have priority numbers ranging from one hundred to four thousand ninety-six. Lower numbers have higher priority, meaning they're evaluated first. Azure's default rules have priorities starting at sixty-five thousand, which ensures custom rules take precedence over defaults. When you create a rule to allow specific traffic, you typically use a low priority number like one hundred or one thousand to ensure it's evaluated before the default deny rule. The exam might ask about rule processing order or why a custom rule isn't taking effect, where understanding priority is crucial.

Rules specify source and destination using IP addresses, CIDR ranges, or service tags. Service tags like Internet, VirtualNetwork, and AzureLoadBalancer provide convenient ways to reference groups of IP addresses without listing them individually. Understanding service tags helps you write more maintainable rules and is important for exam questions about connectivity scenarios.

Port specifications in NSG rules can be single ports, port ranges, or multiple ports separated by commas. Rules also specify the protocol as TCP, UDP, or Any. For common services, knowing the standard ports is important. HTTP uses port eighty, HTTPS uses port four hundred forty-three, SSH uses port twenty-two, and RDP uses port three thousand three hundred eighty-nine. The exam might describe a scenario where you need to allow specific types of traffic and expect you to configure the correct ports.

Application Security Groups provide a way to group VMs and reference those groups in NSG rules. Instead of using IP addresses, you can create ASGs representing tiers of your application like web servers, application servers, and database servers. Then your NSG rules reference these groups, making the rules more maintainable and understandable. The exam might present multi-tier application scenarios where ASGs simplify network security configuration.

Diagnostic capabilities for NSG include NSG flow logs and the network watcher connection troubleshoot feature. Flow logs show which traffic was allowed or denied by NSG rules, helping you understand what's happening with network security. Connection troubleshoot helps diagnose connectivity issues by checking NSG rules along the network path. The exam might ask about troubleshooting network connectivity problems where these diagnostic tools provide answers.

## Declarative vs Imperative Configuration

Understanding the difference between declarative and imperative approaches to infrastructure configuration is important for the exam because Azure supports both patterns, and you need to know when each is appropriate.

Declarative configuration describes the desired end state without specifying the steps to achieve it. ARM templates and Bicep files are declarative. You define what resources you want with what properties, and Azure figures out how to create them. Cloud-init is largely declarative. You specify which packages should be installed and which files should exist, and cloud-init handles the how. This approach is powerful because it's idempotent. Running the same declarative configuration multiple times produces the same result, making it safe to reapply.

Imperative configuration specifies the exact steps to perform. Custom script extensions are typically imperative. Your script contains commands that execute in sequence, performing actions. Run commands are definitely imperative. You tell the VM exactly what to do step by step. This approach gives you complete control and works well for complex logic or situations where the declarative abstraction doesn't fit your needs.

The exam presents scenarios where you must choose between these approaches. Questions might describe requirements for "ensuring infrastructure always matches a defined state" pointing toward declarative approaches like ARM templates. Or they might describe "performing a specific series of configuration steps" suggesting imperative scripts. Recognizing these patterns helps you select appropriate tools.

Idempotency is a key concept related to this distinction. Declarative configurations are typically idempotent, meaning you can apply them repeatedly without causing problems. Imperative scripts might not be idempotent unless you explicitly code them that way. The exam might ask about reapplying configuration or ensuring consistency across multiple deployments, where idempotency matters.

## Integration Patterns

VM configuration automation integrates with broader Azure patterns that appear throughout the exam. Understanding these integration points helps you answer questions about complete solutions, not just isolated VM configuration.

ARM templates and Bicep files can include VM extensions, allowing you to define both infrastructure and configuration in a single deployment. This pattern ensures every VM created from your template includes the necessary configuration automatically. The exam might show you ARM template JSON or Bicep syntax including extension definitions and expect you to understand what gets deployed.

Azure DevOps pipelines and GitHub Actions can trigger VM configuration updates using the Azure CLI or PowerShell to add or update extensions. This enables continuous deployment patterns where code changes trigger infrastructure configuration updates. The exam might describe CI/CD scenarios where VM configuration needs to update automatically.

Azure Automation and Desired State Configuration provide ongoing configuration management for Windows VMs beyond one-time extensions. DSC ensures VMs maintain desired state over time, automatically correcting drift. The exam might contrast one-time configuration using extensions with ongoing management using DSC.

VM Scale Sets apply extensions to all instances in the set, ensuring consistent configuration across scaled VMs. When you define an extension in a scale set model, every VM created by the scale set gets that extension automatically. This pattern is crucial for applications that scale horizontally. The exam frequently asks about scale sets and expects you to understand how configuration applies across instances.

Azure Policy can enforce requirements like "all VMs must have monitoring agent installed" by deploying extensions automatically through policy remediation. This governance pattern ensures compliance across large environments. The exam might describe compliance scenarios where policy-driven extension deployment provides the solution.

## Troubleshooting Configuration

Understanding how to troubleshoot VM configuration issues is important for exam scenarios involving problems or failures. Microsoft expects you to diagnose and resolve common configuration problems.

Extension logs on the VM provide detailed information about what happened during execution. On Linux, extension logs typically appear in the /var/log/azure directory. On Windows, they're in the C:\WindowsAzure\Logs\Plugins directory. Knowing where to look for logs helps you troubleshoot failed extensions. The exam might describe an extension failure and ask how to investigate the cause.

Extension status appears in the Azure Portal under the VM's Extensions blade, showing whether the extension succeeded or failed. The CLI commands az vm extension list and az vm extension show provide the same information programmatically. Understanding how to check extension status is important for automation and monitoring scenarios.

Common extension failures include network connectivity issues preventing downloads, permission problems accessing storage accounts or URLs, script errors causing non-zero exit codes, or timeout issues for long-running operations. The exam might describe symptoms and expect you to identify the likely cause and resolution.

Run commands provide a way to investigate VM state when configuration has failed. You can use run commands to check log files, verify which software is installed, test network connectivity, or gather diagnostic information without logging into the VM. This troubleshooting technique appears in exam scenarios.

NSG flow logs help diagnose network connectivity issues by showing which traffic was allowed or denied. If your extension can't download files or your web server isn't accessible, flow logs reveal whether NSG rules are blocking the traffic. The exam might describe connectivity problems where flow logs provide the diagnostic data you need.

## Exam Study Points

Several key concepts about VM configuration automation deserve special attention for the AZ-204 exam. Understanding the differences between extensions, cloud-init, and run commands is fundamental because exam scenarios hinge on choosing the right automation mechanism. Extensions run after VM creation and persist as installed components, making them suitable for standard configuration applied to many VMs. Cloud-init runs during provisioning before the VM is fully ready, making it ideal for configuration that must complete before applications start. Run commands execute on-demand without persistence, perfect for troubleshooting and one-time operations.

Custom script extensions for both Linux and Windows are among the most commonly tested topics because they provide maximum flexibility for configuration automation. Know how to specify commands inline versus referencing external scripts. Understand that scripts run with administrative privileges and exit codes determine success or failure.

Timing considerations matter throughout the exam. Extensions run asynchronously with VM creation, meaning the VM might appear running before configuration completes. Cloud-init runs synchronously during boot, blocking VM availability until it completes. This timing difference determines which tool is appropriate for different scenarios.

Network Security Groups control traffic to VMs and many other resources. Remember that inbound internet traffic is denied by default, requiring explicit allow rules. NSG rule priority determines evaluation order, with lower numbers evaluated first. Service tags provide convenient ways to reference groups of addresses. Common ports like twenty-two for SSH, three thousand three hundred eighty-nine for RDP, eighty for HTTP, and four hundred forty-three for HTTPS appear frequently.

Declarative versus imperative configuration represents a broader theme in Azure. Declarative approaches describe desired state and are typically idempotent. Imperative approaches specify exact steps and require careful coding for idempotency. Know when each approach is appropriate.

Troubleshooting failed configuration requires knowing where to look for information. Extension logs appear in specific directories on the VM. Extension status shows in the portal and CLI. Run commands provide a way to investigate without logging in. NSG flow logs reveal network connectivity issues.

Integration patterns including ARM templates with extensions, VM Scale Sets with consistent configuration, and Azure Policy enforcing extensions through remediation all appear in exam scenarios. Understanding how VM configuration fits into larger solutions helps you answer questions about complete architectures.

Security best practices include using protected settings for sensitive extension configuration, leveraging managed identities for authentication instead of storing credentials, and following least privilege principles for NSG rules. The exam emphasizes security throughout, and these patterns apply to VM configuration scenarios.

The exam tests practical application through scenario-based questions. You'll see descriptions of requirements like "deploy web servers with software pre-installed" or "troubleshoot why a configured service isn't accessible" and need to identify appropriate solutions. Understanding not just individual tools but when to use each one based on requirements is what separates good answers from great answers.

## Cleanup

When you're finished with VM configuration exercises, deleting the resource group removes all resources including the VMs, extensions, disks, network interfaces, NSGs, public IPs, and virtual networks. Using the yes flag skips confirmation prompts, and the no-wait flag allows deletion to proceed in the background. This cleanup is important for cost management because VMs and associated resources continue to incur charges until deleted. The exam sometimes includes questions about proper resource lifecycle management and avoiding unnecessary costs, where understanding cleanup procedures demonstrates good operational practices.
