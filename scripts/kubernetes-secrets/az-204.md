# Kubernetes Secrets - AZ-204 Exam Exercises

Kubernetes Secrets appear in the AZ-204 exam under the "Implement containerized solutions" objective, specifically focusing on secure configuration management in Azure Kubernetes Service. The exam tests your understanding of when to use Secrets versus ConfigMaps, how to integrate with Azure Key Vault for enterprise-grade secret management, and best practices for protecting sensitive data in containerized applications. These exercises go beyond basic Secret creation to explore encryption at rest, Azure-specific integrations, and security patterns that distinguish passing candidates from those who merely memorize syntax.

## Secrets Versus ConfigMaps - The Security Distinction

Understanding the fundamental distinction between Secrets and ConfigMaps is critical for the AZ-204 exam because many questions test whether you can identify appropriate tools for different scenarios. ConfigMaps are for non-sensitive configuration data like API endpoints, feature flags, and general application settings. Secrets are for sensitive information including credentials, connection strings, API keys, certificates, and tokens. Both use similar APIs and can be consumed as environment variables or volume mounts, but Secrets include additional security features that ConfigMaps lack.

Secrets are base64-encoded when stored and retrieved through kubectl, which provides basic obfuscation but not encryption. This encoding is not a security measure - anyone with cluster access can decode Secrets easily. The real security comes from Kubernetes RBAC which can restrict who can read Secrets, and from encryption at rest which can be enabled in the cluster to encrypt Secret values in etcd. ConfigMaps have none of these protections - they're always stored and displayed as plain text.

An exam question might present a scenario describing an application that needs database credentials and ask you to choose between ConfigMap and Secret. If the data includes credentials, connection strings, API keys, or certificates, the answer is Secret. If it's general application settings like feature flags or environment names, the answer is ConfigMap. The exam expects you to make this distinction quickly and accurately.

The exam also tests your understanding that base64 encoding is not encryption. A common mistake is thinking Secrets are encrypted by default - they're not. You need to explicitly enable encryption at rest in your cluster configuration, and even then, the encryption happens at the storage layer in etcd, not at the API level. For production workloads on Azure, the exam expects you to know about Azure Key Vault integration which provides proper encryption, access controls, and audit logging.

## Creating Secrets Through Multiple Methods

You need to know three ways to create Secrets for the exam, and understand when to use each approach. First is the imperative method using kubectl create secret from literal values or files. This is quick for testing and development but doesn't provide version control or easy reproducibility. You'd use this for one-off Secrets or when you need to quickly test something, but never for production deployments that require proper change management.

Second is the declarative method using YAML with base64-encoded values in the data field. This can be version controlled and follows infrastructure-as-code practices, but encoding is cumbersome and error-prone. More importantly, storing encoded values in Git doesn't provide any security - anyone with repository access can decode them. This method works when your YAML files are already secured through repository access controls and encryption at rest.

Third is the declarative method using YAML with plain text values in the stringData field. Kubernetes automatically encodes these when storing the Secret in etcd. This is cleaner for version-controlled configurations that are already secured through other means like encrypted Git repositories or secrets management systems. The exam expects you to recognize all three approaches and understand their trade-offs.

An exam question might show you YAML with either data or stringData fields and ask what will happen when you apply it. You need to know that data values must be base64-encoded before applying, while stringData values will be encoded automatically. You also need to understand that after creation, kubectl will show both as base64-encoded data - the stringData is just a convenience at creation time.

## Consuming Secrets in Pod Specifications

There are two primary ways to consume Secrets in your applications, and the exam expects you to recognize both patterns in YAML and understand when to use each. The first method uses environment variables, where you reference the Secret using envFrom with secretRef to load all Secret values as environment variables, or use valueFrom with secretKeyRef to load specific values selectively. The Secret values appear as plain text environment variables inside the container, which means your application code accesses them like any other environment variable.

The second method uses volume mounts, where you define a volume with a secret source in the Pod spec, then mount it in your container. Each Secret key becomes a file in the mount path, and the files contain the decoded plain text values. This approach is more secure because the Secret values are only visible to processes that read those specific files, not to every process that can access the environment.

Environment variables are simpler and work well for applications designed to read configuration from the environment. Volume mounts are better for applications that expect configuration files, for Secrets with complex structured data, and for security-conscious applications where you want to limit Secret exposure. The exam might present a scenario and ask you to choose the appropriate consumption method based on requirements like security constraints or application architecture.

An important exam point is understanding Secret updates. If you're using environment variables, updating the Secret doesn't change the values in running Pods - you must restart Pods to pick up new values. If you're using volume mounts, Kubernetes updates the files automatically after a short delay, but your application must reload the configuration. Some applications watch for file changes and reload automatically, others require a restart. Knowing this distinction is essential for answering questions about configuration updates and rolling changes.

## Azure Key Vault Integration for Production Secrets

The AZ-204 exam strongly emphasizes Azure Key Vault integration with Azure Kubernetes Service because it represents Microsoft's recommended approach for production secret management. Azure Key Vault provides proper encryption, access controls, audit logging, secret rotation, and integration with Azure's broader security infrastructure. The Secrets Store CSI driver enables AKS pods to mount Key Vault secrets as volumes, keeping sensitive data entirely outside Kubernetes.

When you configure the CSI driver, pods can reference Key Vault secrets using SecretProviderClass custom resources. The driver authenticates to Key Vault using managed identities, retrieves secrets at pod startup, and mounts them as files in the container filesystem. Your application reads these files just like any other mounted volume, but the secrets never exist as Kubernetes Secret objects where they could be accidentally exposed.

The exam expects you to understand several benefits of this approach. First, secrets are encrypted at rest in Key Vault using FIPS 140-2 compliant encryption, far stronger than Kubernetes encryption at rest. Second, Key Vault access policies and RBAC provide fine-grained control over who can read secrets. Third, Key Vault audit logs track every secret access, providing compliance and security monitoring. Fourth, Key Vault supports secret rotation through versioning and expiration, enabling automated credential rotation without application changes.

Exam questions might present scenarios involving compliance requirements, audit logging, or enterprise security policies and ask you to choose the appropriate secret management approach. When you see requirements like "must meet FIPS 140-2 compliance" or "requires detailed audit logging of secret access," Azure Key Vault integration is the answer. When you see "simple development environment" or "no compliance requirements," Kubernetes Secrets might be sufficient.

## Encryption at Rest and Security Best Practices

Understanding encryption at rest for Kubernetes Secrets is important for exam questions about security hardening and compliance. By default, Secrets are stored unencrypted in etcd, which means anyone with access to the etcd datastore can read all Secrets. Kubernetes supports encryption at rest through encryption providers configured in the API server, but this must be explicitly enabled and is not the default.

The exam expects you to know that encryption at rest encrypts Secret values before storing them in etcd, using encryption keys managed outside the cluster. Azure Kubernetes Service supports this through integration with Azure Key Management Service, where encryption keys are stored in Key Vault or HSM. This provides defense in depth - even if someone gains access to etcd backups, they can't read the Secrets without the encryption keys.

Best practices for the exam include never hardcoding secrets in container images, never committing secrets to source control in plain text, using Secrets instead of ConfigMaps for sensitive data, restricting RBAC permissions to limit who can read Secrets, enabling encryption at rest in production clusters, using Azure Key Vault for production secrets that require strong security, rotating secrets regularly using automated processes, and auditing secret access through Azure Monitor and Key Vault logs.

The exam might present a scenario where secrets were accidentally committed to a Git repository and ask how to prevent this. Answers include using Secret scanning tools, implementing pre-commit hooks that detect credential patterns, using stringData fields with encrypted repository access, or preferably, using external secret management like Azure Key Vault that never stores secrets in Git at all.

## Azure-Specific Integration Patterns

For the AZ-204 exam, you need to understand how Secrets integrate with other Azure services beyond just Key Vault. Managed identities are critical - pods can use Azure managed identities to authenticate to Key Vault without storing credentials anywhere. The workload identity feature in AKS provides this capability, where you assign an Azure identity to a Kubernetes service account, and pods using that service account automatically get the associated identity.

Azure Monitor integration lets you track secret usage and detect anomalies. You can create alerts for unusual secret access patterns, track which applications are using which secrets, and monitor for potential security incidents. This observability is essential for production environments and appears in exam scenarios involving security monitoring and incident response.

Azure Policy integration enables governance at scale. You can create policies that enforce secret management best practices across your AKS clusters, such as requiring Key Vault integration for production namespaces, enforcing encryption at rest, or preventing the use of Secrets for certain types of data. The exam tests whether you understand how to implement organization-wide security standards through Azure Policy.

Container Insights provides visibility into secret consumption patterns, helping you understand which pods are using secrets and identify potential security risks like overly permissive RBAC policies. The exam might ask you to diagnose security issues or recommend monitoring approaches, and understanding these integration points is essential for comprehensive answers.

## Common Exam Scenarios and Troubleshooting

The exam tests practical troubleshooting skills through scenarios involving Secret problems. Common issues include pods failing to start because referenced Secrets don't exist, secrets being in different namespaces than the pods trying to use them, incorrect base64 encoding causing application errors, RBAC policies preventing pods from reading Secrets, and Key Vault integration failing due to identity or networking issues.

When troubleshooting Secret problems, you need to know the right kubectl commands. Use kubectl get secret to verify secrets exist, kubectl describe secret to check metadata without exposing values, kubectl get secret with jsonpath to extract encoded values for debugging, and kubectl exec to verify environment variables or mounted files inside containers. Understanding these diagnostic techniques is essential for scenario-based exam questions.

The exam might present a scenario where an application is failing with authentication errors and ask you to diagnose the issue. You need to check whether the Secret exists, whether it's in the correct namespace, whether the Pod has RBAC permissions to read it, whether the Secret contains the expected keys, and whether the application is reading the Secret correctly from environment variables or volumes. Working through this diagnostic flow systematically is key to answering these questions correctly.

Security-related scenarios are common. You might be asked to identify security issues in YAML like Secrets stored in ConfigMaps, plain text credentials in environment variables defined directly in pod specs, overly permissive RBAC allowing all users to read Secrets, or lack of encryption at rest in production clusters. The exam expects you to recognize these anti-patterns and recommend proper solutions.

## Cleanup

When you're finished with these exercises, removing Secrets is straightforward using kubectl delete. In production environments, Secrets should be managed through infrastructure-as-code and external secret management systems like Azure Key Vault, where lifecycle management is automated and audited. Understanding proper secret lifecycle management including creation, rotation, and deletion demonstrates the operational maturity that the exam values and that production environments require.
