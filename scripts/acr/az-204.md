# Azure Container Registry - AZ-204 Exam Exercises

Azure Container Registry appears in the AZ-204 exam under the containerized solutions domain, which typically accounts for ten to fifteen percent of your exam score. These exercises go beyond the basics and focus specifically on the advanced features and scenarios you'll encounter in the exam. The AZ-204 exam tests not just your ability to create and use a registry, but your understanding of production scenarios like geo-replication, security features, and integration with various Azure services.

## Prerequisites

You should complete the basic ACR lab before diving into these exam-focused exercises. The fundamental concepts like registry creation, authentication, and image operations are essential building blocks. These advanced exercises assume you're comfortable with the basics and ready to explore the features that distinguish enterprise deployments from simple development scenarios.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of ACR capabilities. You'll need to understand the differences between service tiers and know which features require Premium SKU. Building images using ACR Tasks is crucial because it represents the cloud-native approach to CI/CD. Geo-replication comes up frequently in scenarios involving global applications. Webhooks are essential for automation and integration with deployment pipelines. Content trust and vulnerability scanning address security requirements, which are increasingly important in the exam. Finally, you must know how to integrate ACR with Container Instances, Container Apps, and Kubernetes Service because ACR rarely exists in isolation.

## ACR Service Tiers

Understanding the three service tiers is fundamental to the AZ-204 exam because many scenarios hinge on choosing the right tier. The exam will present requirements and expect you to recommend the appropriate SKU.

Basic tier is your entry point for development and testing scenarios. It gives you ten gigabytes of storage and limited throughput, but it includes all the core registry functionality you need for learning and building proof-of-concept applications. The cost is minimal, making it perfect for non-production workloads.

Standard tier represents the production baseline. You get a hundred gigabytes of storage and significantly better throughput compared to Basic. Most production workloads that don't require advanced enterprise features will use Standard. It supports webhooks for automation, making it suitable for CI/CD pipelines.

Premium tier unlocks the enterprise features that appear frequently in exam scenarios. You get five hundred gigabytes of storage and the highest throughput, but more importantly, you gain access to geo-replication, content trust for image signing, private link connectivity, availability zone support, and customer-managed encryption keys. When an exam scenario mentions global distribution, high security requirements, or private network connectivity, Premium is almost always the answer.

An important exam point is that you can upgrade tiers but you cannot downgrade. Once you move from Basic to Standard or from Standard to Premium, you're committed. This is why understanding the tier features upfront is so important for making the right architectural decisions.

When you create registries with different tiers, you'll notice that the CLI options are identical except for the SKU parameter. This uniformity is by design - Microsoft wants you to be able to start with Basic and upgrade as your needs grow without having to rebuild your registry or migrate your images.

The exercises walk you through creating registries with each tier so you can explore their capabilities directly. You'll see how to check what features are available in your registry and practice the upgrade commands. The exam might present a scenario where you need to enable geo-replication or configure a private endpoint, and you'll need to recognize that Premium tier is required.

## Build Images with ACR Tasks

ACR Tasks represents a paradigm shift from traditional container image building. Instead of requiring Docker on your local machine or build server, ACR Tasks builds images directly in Azure. This is a critical exam topic because it demonstrates Microsoft's cloud-first approach to containerization.

The quick build functionality lets you run one-time image builds using the az acr build command. You point it at your source code directory or a Git repository, and ACR handles the entire build process in the cloud. The build runs on Azure infrastructure, and the resulting image goes directly into your registry without ever touching your local Docker daemon. This is perfect for scenarios where developers don't have Docker installed or when you're building from a CI/CD pipeline that doesn't want to manage Docker infrastructure.

Automated build tasks take this further by triggering builds automatically. You can set up tasks that run whenever code is pushed to your Git repository. Even more interesting for the exam, you can configure tasks that rebuild your images automatically when base images are updated. This addresses the critical security scenario where a base image vulnerability is patched, and you need to rebuild all your dependent images. ACR Tasks can detect base image updates and trigger rebuilds automatically.

Multi-step tasks let you define complex workflows that go beyond simple image builds. You can build an image, run tests against it, and only push it to the registry if tests pass. You can build multiple related images in sequence. You can even call custom scripts as part of your build process. The exam might present a scenario requiring this kind of sophisticated CI/CD workflow, and you need to recognize that multi-step ACR Tasks provide this capability.

Scheduled tasks let you run builds on a timer, perfect for nightly builds or periodic security scans. You define the schedule using cron syntax, and ACR handles the execution automatically.

The exercises guide you through creating different types of tasks. You'll start with a quick build to understand the basic mechanics. Then you'll create an automated task that triggers on Git commits. You'll build a multi-step task that includes testing logic. Throughout these exercises, pay attention to how the tasks integrate with the registry - images built by tasks are immediately available in your repository, and tasks can trigger webhooks, creating a complete automated deployment pipeline.

The exam loves scenarios where someone doesn't have Docker installed locally but needs to build container images. Your answer: ACR Tasks. When you see a requirement for automatic rebuilds triggered by code changes or base image updates, think ACR Tasks. When a multi-stage build and test workflow is described, ACR Tasks with multi-step task definitions is the solution.

## Geo-Replication

Geo-replication is a Premium-tier feature that appears frequently in exam scenarios involving globally distributed applications. Understanding how it works and when to use it is crucial for the AZ-204 exam.

The core concept is simple but powerful - you create a single registry that automatically replicates to multiple Azure regions. When you push an image to your registry, ACR automatically synchronizes it to all replica locations. When someone pulls an image, they automatically get it from the nearest replica. This reduces latency because images don't have to travel across the world, and it reduces your network egress costs because data transfer within a region is less expensive than cross-region transfers.

From a management perspective, geo-replication is elegant. You have one registry name, one set of credentials, one place to push images. The replication happens behind the scenes. Developers and deployment systems don't need to know about replica locations - they just use the registry, and Azure routes their requests to the optimal location.

High availability is another benefit. If one region experiences an outage, pulls can continue from other replicas. Your registry doesn't have a single point of failure. This resilience is important for production applications that can't tolerate registry unavailability.

The exercises demonstrate how to enable geo-replication by adding replicas in different regions. You'll push an image and verify that it appears in all replica locations. You'll see how pulls automatically use the nearest replica. The exam might ask you to design a solution for a globally distributed application, and geo-replication should be part of your answer when container registries are involved.

Important exam details: geo-replication requires Premium tier, each replica incurs separate costs, you can't delete the home region without deleting the entire registry, and images are replicated automatically but there's a brief delay as synchronization occurs.

## Webhooks for CI/CD Integration

Webhooks provide the integration glue between ACR and your deployment automation. When images are pushed to or deleted from your registry, webhooks can notify external systems, triggering automated deployments or other workflows.

A webhook is essentially an HTTP POST to a URL of your choice. You configure the webhook with a target URI, specify which actions should trigger it, and optionally define a scope to filter which repositories and tags you care about. When the triggering event occurs, ACR sends a JSON payload to your webhook URL with details about what happened.

The scope filtering is powerful and shows up in exam scenarios. You might want a webhook that only fires for production-tagged images, or only for a specific repository. You can use wildcards in your scope definitions to match patterns. This lets you create targeted automation - your production deployment webhook fires only for production tags, your test environment webhook fires only for test tags.

Actions determine what triggers your webhook. Push events are most common, used to trigger deployments when new images arrive. Delete events let you clean up deployed containers when images are removed. Quarantine events can trigger security workflows when vulnerable images are detected.

Custom headers let you pass authentication tokens or other metadata to your webhook endpoint. Your deployment system might require a bearer token or API key, and you can configure webhooks to include these headers in every request.

The exercises walk you through creating webhooks with different configurations. You'll create a basic webhook and test it with the ping command. You'll create a webhook with scope filtering to see how pattern matching works. You'll observe webhook events in the Azure CLI to understand what data gets sent. The exam might describe an automated deployment requirement and expect you to identify webhooks as the integration mechanism.

Important exam points: webhook URIs must be publicly accessible HTTPS endpoints, webhooks can trigger on multiple event types, scope patterns use wildcards to match repositories and tags, and custom headers enable authentication with external systems.

## Content Trust (Image Signing)

Content trust addresses the security question of how you know an image hasn't been tampered with and really comes from who you think it comes from. This Premium-tier feature implements image signing and verification, ensuring that only authorized publishers can push images and that images haven't been modified since signing.

The underlying technology is Docker Content Trust, which uses digital signatures to verify image integrity and publisher identity. When you enable content trust on your registry and on your Docker client, every push operation signs the image, and every pull operation verifies the signature. If an image isn't signed or the signature doesn't verify, the operation fails.

The signing process involves two types of keys. The root key is your master trust key - you generate it once and keep it secure, ideally offline. The repository key is specific to each repository and is used for actual image signing. This two-tier system provides security and flexibility - you can rotate repository keys without affecting your root key, and you can have different repository keys for different projects or teams.

Enabling content trust transforms your registry from accepting any image to requiring signed images. This is crucial for high-security environments where you must ensure that only vetted, approved images can be deployed. Combined with admission controllers in Kubernetes, content trust can enforce policies that prevent unsigned images from running.

The exercises guide you through enabling content trust on your registry and configuring Docker Content Trust on your client. You'll push a signed image and see the key generation process. You'll try to pull an unsigned image and see it fail. You'll use Docker trust commands to inspect signatures and understand what metadata is involved.

For the exam, remember that content trust requires Premium tier, it's based on Docker Content Trust and Notary, it prevents deployment of unsigned or tampered images, and it's often used together with admission controllers in orchestration platforms for policy enforcement.

## Vulnerability Scanning

Security vulnerabilities in container images are a significant concern, and Azure provides vulnerability scanning through Microsoft Defender for Containers. This capability scans your container images for known vulnerabilities and reports findings through Azure Security Center.

The scanning process happens automatically when you push images to your registry, and it also runs periodically to detect newly discovered vulnerabilities. Defender analyzes your images against databases of known CVEs - Common Vulnerabilities and Exposures. It identifies vulnerable packages, exposed secrets, and potential malware.

Results are categorized by severity - critical, high, medium, and low. Critical vulnerabilities require immediate attention, while lower-severity findings can be addressed through normal patching cycles. The scan results integrate with Azure Security Center, giving you a centralized view of security issues across your entire Azure environment, not just your container registries.

Quarantine functionality lets you prevent vulnerable images from being pulled. This is essential when a critical vulnerability is discovered - you can quarantine affected images immediately, preventing any new deployments until the vulnerability is addressed. Existing running containers continue running, but new deployments are blocked.

The exercises show you how to enable Microsoft Defender for Containers and configure vulnerability scanning. You'll push images and view the scan results. You'll see how to interpret severity levels and understand the remediation recommendations. You'll experiment with quarantine to see how it blocks image pulls.

Exam scenarios involving security compliance or vulnerability management should trigger thoughts of vulnerability scanning. Know that it's an automatic process that requires Microsoft Defender for Containers, that it scans on push and periodically thereafter, that results appear in Security Center, and that quarantine can prevent deployment of vulnerable images.

## Integration with Azure Services

ACR rarely exists in isolation - it's almost always used in conjunction with compute services that run your containers. The exam tests your knowledge of how to authenticate and integrate ACR with Azure Container Instances, Container Apps, and Azure Kubernetes Service.

Azure Container Instances is the simplest integration. You can use admin credentials for quick development scenarios, but the exam will expect you to recommend managed identities for production. With managed identity, the container instance authenticates to ACR using its Azure identity, with no credentials to manage or rotate. You assign the AcrPull role to the managed identity, and the container instance can pull images seamlessly.

Container Apps follows a similar pattern. You can provide registry credentials when creating the container app, but managed identity is the preferred approach. Container Apps makes it easy to update to new image versions - you just update the app with the new image tag, and the platform handles the rollout.

Azure Kubernetes Service has the best-integrated ACR support. The attach-acr parameter during cluster creation automatically configures the authentication between AKS and ACR. Behind the scenes, this grants the AKS kubelet identity the AcrPull role on your registry. Pods can reference ACR images in their manifests without any additional configuration or secrets. This seamless integration is a huge operational advantage.

Service principals provide another authentication option, particularly for services that don't support managed identities or for external systems that need to access your registry. You create a service principal with the appropriate role - AcrPull for read access, AcrPush for write access, or both for CI/CD systems. The service principal has a client ID and secret that can be used like traditional credentials.

The exercises walk you through all these integration patterns. You'll deploy containers to ACI using both admin credentials and managed identities, seeing the difference in complexity and security. You'll create a Container App that pulls from ACR. You'll create an AKS cluster with ACR integration and deploy applications that reference your registry images. You'll create a service principal and use it for authentication.

The exam loves to test authentication methods. Know that managed identity is best for Azure services because it has no credentials to manage, service principals work for automation and external systems, admin accounts are convenient but less secure and should be limited to development, and AKS has special attach-acr functionality for seamless integration.

## AZ-204 Exam Study Points

Let's consolidate the key points you need to master for the exam. ACR service tiers determine what features are available - Basic for development with minimal storage, Standard for production workloads needing more capacity, and Premium for enterprise features like geo-replication and content trust. You can upgrade tiers but never downgrade. Many exam scenarios hinge on recognizing when Premium is required.

ACR Tasks provides cloud-based image building without requiring Docker locally. Quick builds handle one-time image creation, task objects enable automated builds triggered by code commits or base image updates or schedules, and multi-step tasks support complex workflows with testing and conditional logic. When you see a scenario describing automated image building or rebuilding, think ACR Tasks.

Geo-replication is Premium-only and addresses global distribution scenarios. A single registry with multiple regional replicas reduces latency and costs while maintaining simple management. Images replicate automatically, and pulls use the nearest replica transparently.

Webhooks integrate ACR with external systems by posting HTTP requests when images are pushed or deleted. Scope filtering and custom headers provide precise control over when webhooks fire and how they authenticate. Webhooks are the glue between your registry and your deployment automation.

Content trust ensures image integrity and publisher authenticity through digital signatures. It requires Premium tier and is based on Docker Content Trust. Root keys and repository keys provide security and flexibility. Unsigned or tampered images are rejected when content trust is enabled.

Vulnerability scanning through Microsoft Defender for Containers automatically identifies CVEs and security issues in your images. Scans run on push and periodically thereafter. Quarantine functionality can prevent deployment of vulnerable images. Security Center provides centralized viewing of vulnerabilities.

Authentication methods have a clear hierarchy for the exam - managed identities are best for Azure services because there are no credentials to manage, service principals work for automation and non-Azure systems, and admin accounts are acceptable for development but not recommended for production. AKS has special integration through the attach-acr parameter.

Understanding these concepts at a practical level is what separates passing from failing the exam. Microsoft tests application of knowledge, not memorization. Practice the labs, understand why each feature exists and when to use it, and you'll be well-prepared.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything - all registries, all replicas, all images, and all associated resources. The no-wait flag lets the deletion proceed in the background so you can continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization.
