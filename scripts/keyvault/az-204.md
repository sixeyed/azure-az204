# Azure Key Vault - AZ-204 Exam Exercises

Azure Key Vault appears in the AZ-204 exam under the "Implement Azure Security" domain, which represents fifteen to twenty percent of your exam score. This is a critical topic because Key Vault is the foundation of secure application development in Azure. The exam tests not just your ability to use Key Vault, but your understanding of how to integrate it into applications using managed identities and the Azure SDK. These exercises go beyond the basics and focus specifically on the scenarios and integration patterns you'll encounter in the exam.

## Prerequisites

You should complete the basic Key Vault lab before diving into these exam-focused exercises. The fundamental concepts like vault creation, secret management, and CLI operations are essential building blocks. These advanced exercises assume you're comfortable with the basics and ready to explore the integration patterns that distinguish production applications from simple demonstrations.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of Key Vault capabilities. You need to understand how to secure application configuration data using Key Vault, going beyond simple storage to implement proper secret references and rotation. Developing code that uses keys, secrets, and certificates is crucial because the exam will show you code snippets and expect you to identify issues or complete implementations. Implementing Managed Identities for passwordless authentication is perhaps the most important skill, as Microsoft emphasizes this as the secure way to authenticate to Azure services. Using the Azure SDK to interact with Key Vault programmatically appears frequently in code-based questions. Choosing between access policies and RBAC for authorization requires understanding when each model is appropriate and what the trade-offs are. Finally, implementing secret rotation and versioning strategies is essential for production scenarios where credentials must be updated without downtime.

## Working with Secrets

Let's start with a comprehensive look at secrets, which are the most commonly used Key Vault objects in real applications.

We're creating the environment by setting up a resource group named labs-keyvault-az204 in the East US region, then creating a Key Vault with the enable-rbac-authorization flag set to false. Note that this creates a Key Vault using the classic access policy model rather than RBAC. We'll explore RBAC later, but access policies are still widely used and appear on the exam.

In real applications, you'll store various types of sensitive data as secrets. Let's explore examples of each common type. For database connection strings, we're storing the full connection string including server, database, user, and password as a single secret with a content-type of "connection-string". It's important for the exam to know that you should always use content-type to document what the secret contains because this helps with management and auditing at scale.

For API keys, we're storing the key value with a content-type of "api-key". This metadata becomes crucial when you have dozens or hundreds of secrets in a vault and need to understand what each one represents. For complex configuration, you can even store JSON as a secret value. We're creating an AppConfig secret containing a JSON object with feature flags, retry counts, and timeout values. Your application can parse the JSON after retrieval, making secrets a flexible way to store structured configuration data.

Retrieving secret values efficiently requires understanding the query parameter. We're using the keyvault secret show command with the query parameter set to "value" and output format set to tsv to get just the value in plain text, perfect for storing in environment variables or passing to other commands. You can also retrieve metadata about the secret by querying for specific fields like name, contentType, created, updated, and enabled status. Know how to use the query parameter with JMESPath syntax because it appears frequently on the exam.

Understanding versioning is crucial for the exam. Every time you update a secret using keyvault secret set, a new version is created automatically. We're listing all versions with keyvault secret list-versions to see the complete history. Each version has a unique ID, but when you reference a secret by name only without specifying a version, you always get the latest version. This is a critical exam concept - applications should always reference secrets by name without specifying a version, which enables transparent secret rotation. You update the secret in Key Vault, and applications automatically get the new value on their next retrieval without any code changes or restarts.

Production secrets should have expiration dates to force regular rotation. We're calculating an expiration date thirty days from now and using keyvault secret set-attributes with the expires parameter to set it. After expiration, the secret cannot be retrieved, which enforces security policies and prevents stale credentials from being used indefinitely.

## Working with Keys

Keys are fundamentally different from secrets in how they're used. The important distinction for the exam is that secrets store sensitive data that applications need to read directly, like passwords and connection strings. Keys perform cryptographic operations without exposing the key material - your application sends data to Key Vault for encryption or decryption, and the key itself never leaves the vault.

We're creating an RSA key for encryption using keyvault key create with a key type of RSA, size of 2048 bits, and operations limited to encrypt and decrypt. The ops parameter specifies allowed operations, and by limiting operations, you reduce the attack surface. We're also creating an Elliptic Curve key for signing operations with a curve of P-256 and operations limited to sign and verify.

You need to know the key types for the exam. RSA Keys come in sizes of 2048, 3072, or 4096 bits and support operations including encrypt, decrypt, sign, verify, wrapKey, and unwrapKey. They're most common for general-purpose encryption. Elliptic Curve keys use curves P-256, P-384, P-521, or P-256K and support sign and verify operations. They offer smaller key sizes with equivalent security, making them better for signing scenarios. Symmetric keys using the oct type come in sizes of 128, 192, or 256 bits and support encrypt, decrypt, wrapKey, and unwrapKey operations. They're faster than RSA but require secure key distribution.

An important exam tip is that the key material itself never leaves Key Vault. Applications send data to Key Vault for encryption or decryption operations, and Key Vault returns the result. This means even if an attacker compromises your application, they can't extract the encryption keys themselves.

## Working with Certificates

Certificates combine cryptographic keys with identity metadata in X.509 format. They're used for TLS and SSL, authentication, and code signing. Certificates require a policy that defines their properties, which you specify in JSON format.

We're creating a certificate policy that specifies the issuer name as "Self" for a self-signed certificate. In production, you'd specify a certificate authority name instead. The key properties include exportable set to true so the private key can be downloaded, keySize of 2048 bits, and keyType of RSA. We're specifying that the key should not be reused. The secret properties set the contentType to PKCS12 format. The X.509 certificate properties include the subject as CN equals myapp.azurewebsites.net, validity of twelve months, and subject alternative names listing additional domain names the certificate covers.

The key policy elements for the exam are the issuerParameters.name which is "Self" for self-signed or a CA name for production certificates, keyProperties.exportable which determines whether the private key can be exported, keyProperties.keyType which is usually RSA or EC, the x509CertificateProperties.subject which is the certificate's distinguished name, validityInMonths which sets the certificate lifetime, and subjectAlternativeNames which lists additional domain names the certificate covers.

We're creating the certificate using keyvault certificate create with the policy parameter pointing to the JSON file. Certificate creation can take a few seconds as Key Vault generates the key pair and creates the certificate structure. We're downloading it in PEM format, which is text-based and includes the certificate chain, using keyvault certificate download with encoding set to PEM.

An important exam tip is that when you create a certificate in Key Vault, it automatically creates three objects. It creates a certificate object that combines the key and metadata, a key object containing the private key, and a secret object containing the full certificate with private key in PKCS12 format. This means you can access the certificate through multiple interfaces depending on your needs - as a certificate for management operations, as a key for cryptographic operations, or as a secret to retrieve the full certificate bundle.

## Managed Identities - Critical for AZ-204

Managed Identities are one of the most important concepts for the AZ-204 exam, appearing in scenarios across multiple domains. The key concept is that a Managed Identity is an identity in Azure AD that Azure manages for you. Your application can use this identity to authenticate to Azure services without storing any credentials in code or configuration.

System-assigned identities are tied to a specific Azure resource. When you delete the resource, the identity is automatically deleted. We're creating an App Service with a system-assigned managed identity by using the assign-identity parameter set to system during webapp create. This creates an identity that's managed by Azure and tied to this specific web app.

We're getting the identity's principal ID using webapp identity show with a query for principalId. This ID is what we'll use to grant permissions. Now we're granting this identity access to Key Vault using keyvault set-policy with the object-id set to the principal ID and secret-permissions set to get and list. What we've accomplished here is critical - we've created a web app with a managed identity, granted that identity permission to read secrets from Key Vault, and now code running in this web app can access Key Vault without any credentials stored in the code or configuration.

User-assigned identities have an independent lifecycle. They can be shared across multiple resources and aren't deleted when resources are deleted. We're creating a user-assigned managed identity using identity create, which gives us a standalone identity resource. We're getting both the identity ID, which is the Azure resource ID used for assignments, and the principal ID, which is used for permission grants. We're assigning it to the web app using webapp identity assign and granting it Key Vault access using keyvault set-policy just like we did with the system-assigned identity.

A common exam question pattern is "You need to allow multiple App Services to access the same Key Vault, and the solution must ensure identities persist even if individual apps are deleted. What should you do?" The answer is to use a user-assigned managed identity shared across all apps, because it has an independent lifecycle and won't be deleted when individual apps are removed.

## Access Policies vs Azure RBAC

Understanding both permission models is important for the exam because you'll encounter scenarios using each approach.

Access policies are configured at the Key Vault level and specify what each identity can do with secrets, keys, and certificates separately. We're granting comprehensive secret permissions to a user with permissions including get, list, set, delete, backup, restore, recover, and purge. For applications, we're typically more restrictive, granting only get and list permissions. The advantages of access policies are fine-grained control over individual operations, separate permissions for secrets, keys, and certificates, and no additional Azure RBAC configuration needed. The disadvantages are that it's a different permission model than other Azure resources, management is only at the vault level, and it doesn't integrate with Azure management group policies.

The RBAC model uses standard Azure role assignments and is now the recommended approach for new Key Vaults. We're creating a Key Vault with the enable-rbac-authorization flag set to true. Once RBAC is enabled, we're assigning built-in roles using role assignment create with a scope parameter pointing to the specific Key Vault resource.

The Key Vault RBAC roles you must know for the exam are Key Vault Administrator which provides full access to all operations, Key Vault Secrets Officer which provides full management of secrets including create, read, update, and delete, Key Vault Secrets User which provides read access to secret values only, Key Vault Crypto Officer which provides full management of keys, Key Vault Crypto User which allows using keys for cryptographic operations like encrypt, decrypt, sign, and verify, Key Vault Certificates Officer which provides full management of certificates, and Key Vault Reader which provides read access to metadata but not secret or key values.

An important exam tip is that when RBAC is enabled, access policies are ignored completely. You must choose one model or the other, not both. Trying to use access policies on an RBAC-enabled vault won't work.

## Using Key Vault in Application Code

This is the most important section for the AZ-204 exam because you need to know how to write code that uses Key Vault. The pattern you need to know involves using the Azure SDK's SecretClient with DefaultAzureCredential. DefaultAzureCredential automatically uses the managed identity when running in Azure, making your code work seamlessly across environments.

The critical exam concept about DefaultAzureCredential is that it tries multiple authentication methods in a specific order. First, it checks for EnvironmentCredential which looks for service principal credentials in environment variables like AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_CLIENT_SECRET or AZURE_CLIENT_CERTIFICATE_PATH. Second, it uses ManagedIdentityCredential which detects system or user-assigned managed identities. Third, it checks SharedTokenCacheCredential for Visual Studio credentials. Fourth, it uses VisualStudioCodeCredential for VS Code Azure Account extension credentials. Fifth, it uses AzureCliCredential which relies on az login credentials. Sixth, it checks AzurePowerShellCredential for Connect-AzAccount credentials. Finally, it falls back to InteractiveBrowserCredential for browser-based login.

This chain means the same code works in production using managed identity, in development using your local Azure CLI credentials, and in CI/CD pipelines using service principal credentials from environment variables. This pattern appears frequently on the exam, and you need to understand why DefaultAzureCredential is the recommended approach.

App Service has a special feature for Key Vault integration using Key Vault references. We're setting an app setting where the value starts with @Microsoft.KeyVault followed by the SecretUri parameter. Here's how this works - the setting value starts with @Microsoft.KeyVault which App Service recognizes as a special reference. App Service uses the app's managed identity to retrieve the secret from Key Vault automatically. Your application code reads the setting as normal and just sees the secret value, not the Key Vault URI. App Service automatically refreshes the value when the secret changes, typically within 24 hours. The exam tip here is that the app's managed identity must have Get permission on the secret for this to work.

Common exam scenarios involve identifying what's wrong with code. Missing using or import statements for Azure.Identity and Azure.Security.KeyVault.Secrets are common issues. Using a specific credential type instead of DefaultAzureCredential when the code should work across environments is another. Hardcoded vault URLs instead of reading from configuration violates best practices. Not using async and await properly in async contexts will cause runtime errors.

## Backup, Recovery, and Soft Delete

Understanding data protection is important for production scenarios that appear on the exam. We're backing up a secret to a file using keyvault secret backup. The backup file is encrypted and can only be restored to a Key Vault in the same Azure geography, which is an important limitation to know. We're restoring from backup using keyvault secret restore. An exam tip is that backups include all versions of the secret, not just the current version.

Soft delete is enabled by default on new Key Vaults. We're configuring it explicitly using keyvault update with enable-soft-delete set to true and retention-days set to 90. When you delete a secret, it enters a "deleted" state but can be recovered during the retention period. We're deleting a secret with keyvault secret delete, listing deleted secrets with keyvault secret list-deleted, and recovering a deleted secret with keyvault secret recover.

Purge protection prevents permanent deletion during the retention period. We're enabling it using keyvault update with enable-purge-protection set to true. Important to know is that once enabled, purge protection cannot be disabled - this is a one-way operation. With purge protection enabled, deleted secrets can be recovered but not purged during retention. This prevents accidental or malicious permanent deletion and is required for some compliance scenarios.

A common exam scenario is "You need to ensure deleted secrets can be recovered but prevent administrators from permanently deleting secrets immediately. What should you do?" The answer is to enable both soft delete and purge protection.

## Secret vs Key vs Certificate

This distinction appears frequently on the exam, and you need to understand when to use each type. Secrets are for storing passwords, connection strings, and API keys with a maximum size of 25 KB. The operations are set, get, list, and delete. Use secrets when applications need to read the value directly. Keys are for storing RSA, EC, or symmetric cryptographic keys. The operations are encrypt, decrypt, sign, verify, wrap, and unwrap. Use keys when performing cryptographic operations without exposing key material. Certificates are for storing X.509 certificates with private keys. The operations are create, import, update, delete, and download. Use certificates for TLS and SSL, authentication, or code signing. Key Vault can automatically renew certificates from supported certificate authorities.

## Managed Identity Decision Tree

A common exam question asks which type of managed identity to use. Use system-assigned when the identity is needed for a single resource, the identity should be deleted when the resource is deleted, and you want simpler setup with just one command. Use user-assigned when the identity needs to be shared across multiple resources, the identity should persist beyond resource lifecycle, you need to pre-configure permissions before attaching to resources, or you're managing multiple environments with reusable identities.

## Common Exam Scenarios and Solutions

Scenario one presents a web app that needs database credentials deployed to Azure App Service, asking for the most secure approach. The solution is to store the connection string in Key Vault as a secret, enable system-assigned managed identity on the App Service, grant the managed identity Get permission on the secret, use a Key Vault reference in app settings with the @Microsoft.KeyVault syntax, and let the app code read from configuration without being aware of Key Vault.

Scenario two involves an API key that needs rotation every thirty days without application downtime. The solution is to store the API key in Key Vault as a secret, set an expiration date thirty days from now, have the application reference the secret by name without specifying a version, create a new version of the secret when rotation is needed which automatically becomes current, let the application get the new key on next retrieval, and set up Azure Monitor alerts for approaching expiration.

Scenario three describes multiple Azure Functions needing the same database connection with functions in different resource groups. The solution is to create a user-assigned managed identity, grant it access to Key Vault secrets, assign the same user-assigned identity to all Function Apps, have functions use DefaultAzureCredential to access Key Vault, and rely on the identity persisting even if individual functions are deleted or recreated.

Scenario four asks how a developer can test Key Vault integration locally without deploying to Azure. The solution is to use DefaultAzureCredential in code, ensure the developer has appropriate Key Vault permissions through Azure RBAC role or access policy, run az login locally before testing, and let DefaultAzureCredential automatically use Azure CLI credentials. The same code works in both local development and Azure production.

Scenario five requires preventing accidental permanent deletion of production secrets. The solution is to enable soft-delete with 90-day retention, enable purge-protection, use Azure RBAC with least-privilege roles, allow deleted secrets to be recovered within 90 days, and prevent anyone from purging permanently during the retention period.

## Best Practices Summary

For the exam, you need to know the best practices. Never hardcode secrets - always use Key Vault. Always use Managed Identities in Azure - never store credentials for Key Vault access. Use DefaultAzureCredential because it works across development, test, and production. Reference secrets by name and never specify version in application code. Enable soft-delete and purge protection to protect against accidental deletion. Set expiration dates to force regular secret rotation. Use Azure RBAC for new vaults because it's simpler and more consistent. Use Key Vault references in App Service for automatic secret resolution and refresh. Separate Key Vaults by environment with different vaults for dev, test, and production. Monitor and alert by tracking access and expiration with Azure Monitor.

## Authentication Methods Priority

Know when to use each authentication method. Managed Identity is recommended for any Azure resource like App Service, Functions, VMs, or Containers. The advantages are no credentials to manage, automatic rotation, and it's the most secure. Service Principal with Certificate is the second choice for non-Azure resources and hybrid scenarios. It's more secure than secret-based authentication but requires certificate management. Service Principal with Secret is for CI/CD pipelines and non-Azure automation. It's simpler than certificate-based but the secret must be stored securely and rotated. User credentials are for local development only and should never be used in production.

## DefaultAzureCredential Chain Details

Memorize this order for the exam. First, EnvironmentCredential checks for service principal credentials in environment variables AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_CLIENT_SECRET or AZURE_CLIENT_CERTIFICATE_PATH. Second, ManagedIdentityCredential uses system or user-assigned managed identity. Third, SharedTokenCacheCredential uses Visual Studio credentials. Fourth, VisualStudioCodeCredential uses VS Code Azure Account extension. Fifth, AzureCliCredential uses az login credentials. Sixth, AzurePowerShellCredential uses Connect-AzAccount credentials. Seventh, InteractiveBrowserCredential falls back to browser-based login.

## Practice Questions Style

The exam will test you with different question types. Choose correct code questions ask which code correctly retrieves a secret from Key Vault using managed identity. Identify error questions show code that throws an authentication exception and ask what the cause is. Complete the solution questions ask you to configure an App Service to read a database password from Key Vault and require you to list three actions in sequence. Choose best practice questions ask which approach follows Microsoft's security best practices for accessing Key Vault from Azure Functions.

## Final Exam Tips

Understanding the SDK and knowing the basic code patterns for getting, setting, and deleting secrets is essential. Managed Identities are key because most secure solution questions involve them. Know the RBAC roles so you can choose the right role for scenarios. Understand versioning where applications reference by name and operations can specify version. DefaultAzureCredential understanding includes its credential chain and why it's recommended. Key Vault references require knowing the @Microsoft.KeyVault syntax for App Service. Soft delete versus purge protection requires understanding what each protects against. Permissions knowledge includes what permissions are needed for common operations.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything using az group delete with the yes and no-wait flags. The no-wait flag lets the deletion proceed in the background so you can continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization.
