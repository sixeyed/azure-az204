# Azure Key Vault - AZ-204 Exam Preparation Narration Script

## Introduction

Welcome to the AZ-204 exam preparation for Azure Key Vault. This lab covers the "Implement Azure Security" domain, which represents 15-20% of the exam.

Key Vault is a critical topic for the AZ-204 exam because it's the foundation of secure application development in Azure. You need to understand not just how to use Key Vault, but how to integrate it into applications using managed identities and the Azure SDK.

Make sure you've completed the basic Key Vault lab first, as we'll build on those fundamentals.

## AZ-204 Focus Areas

The exam tests your ability to:

1. **Secure application configuration data** using Key Vault
2. **Develop code** that uses keys, secrets, and certificates
3. **Implement Managed Identities** for passwordless authentication
4. **Use the Azure SDK** to interact with Key Vault programmatically
5. **Choose between access policies and RBAC** for authorization
6. **Implement secret rotation** and versioning strategies

## Exercise 1: Working with Secrets

Let's start with a comprehensive look at secrets, which are the most commonly used Key Vault objects.

### Create the Environment

```bash
az group create -n labs-keyvault-az204 --tags courselabs=azure -l eastus

az keyvault create \
  -g labs-keyvault-az204 \
  -n <keyvault-name> \
  -l eastus \
  --enable-rbac-authorization false
```

Note the `--enable-rbac-authorization false` flag. This creates a Key Vault using the classic access policy model. We'll explore RBAC later.

### Store Different Types of Secrets

In real applications, you'll store various types of sensitive data. Let's add examples of each:

**Database Connection String:**

```bash
az keyvault secret set \
  --vault-name <keyvault-name> \
  --name "DatabaseConnectionString" \
  --value "Server=tcp:<server-name>.database.windows.net;Database=<db-name>;User ID=<user>;Password=<password>;" \
  --content-type "connection-string"
```

**Important for the exam:** Always use content-type to document what the secret contains. This helps with management and auditing.

**API Key:**

```bash
az keyvault secret set \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  --value "<api-key-value>" \
  --content-type "api-key"
```

**JSON Configuration:**

```bash
az keyvault secret set \
  --vault-name <keyvault-name> \
  --name "AppConfig" \
  --value '{"feature1":true,"maxRetries":3,"timeout":30}' \
  --content-type "application/json"
```

You can store complex configuration as JSON strings in Key Vault. Your application can parse the JSON after retrieval.

### Retrieve Secret Values

Get just the value using query and output parameters:

```bash
az keyvault secret show \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  --query value -o tsv
```

Get metadata about the secret:

```bash
az keyvault secret show \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  --query '{name:name, contentType:contentType, created:attributes.created, updated:attributes.updated, enabled:attributes.enabled}'
```

**Exam tip:** Know how to use the `--query` parameter with JMESPath syntax. It appears frequently on the exam.

### Secret Versioning and Rotation

Understanding versioning is crucial for the exam. Here's how it works:

Every time you update a secret, a new version is created:

```bash
az keyvault secret set \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  --value "<new-api-key-value>"
```

List all versions to see the history:

```bash
az keyvault secret list-versions \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  -o table
```

Each version has a unique ID, but when you reference by name only, you always get the latest version.

**Critical exam concept:** Applications should always reference secrets by name without specifying a version. This enables transparent secret rotation - you update the secret in Key Vault, and applications automatically get the new value on the next retrieval.

### Set Expiration Dates

Production secrets should have expiration dates to force regular rotation:

```bash
# Calculate expiration date (30 days from now)
EXPIRY_DATE=$(date -u -d "+30 days" '+%Y-%m-%dT%H:%M:%SZ')

az keyvault secret set-attributes \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey" \
  --expires "$EXPIRY_DATE"
```

After expiration, the secret cannot be retrieved. This enforces security policies and prevents stale credentials from being used.

## Exercise 2: Working with Keys

Keys are different from secrets - they're cryptographic keys used for encryption, decryption, signing, and verification operations.

**Important distinction for the exam:**
- **Secrets**: Store sensitive data that applications need to read (passwords, connection strings)
- **Keys**: Perform cryptographic operations without exposing the key material

### Create Cryptographic Keys

Create an RSA key for encryption:

```bash
az keyvault key create \
  --vault-name <keyvault-name> \
  --name "app-encryption-key" \
  --kty RSA \
  --size 2048 \
  --ops encrypt decrypt
```

The `--ops` parameter specifies allowed operations. By limiting operations, you reduce the attack surface.

Create an Elliptic Curve key for signing:

```bash
az keyvault key create \
  --vault-name <keyvault-name> \
  --name "document-signing-key" \
  --kty EC \
  --curve P-256 \
  --ops sign verify
```

### Key Types - Exam Knowledge

Know these key types for the exam:

**RSA Keys:**
- Sizes: 2048, 3072, 4096 bits
- Operations: encrypt, decrypt, sign, verify, wrapKey, unwrapKey
- Most common for general-purpose encryption

**EC (Elliptic Curve) Keys:**
- Curves: P-256, P-384, P-521, P-256K
- Operations: sign, verify
- Smaller key size with equivalent security, better for signing

**oct (Symmetric) Keys:**
- Sizes: 128, 192, 256 bits
- Operations: encrypt, decrypt, wrapKey, unwrapKey
- Faster but requires secure key distribution

### View Key Details

```bash
az keyvault key list \
  --vault-name <keyvault-name> \
  -o table
```

```bash
az keyvault key show \
  --vault-name <keyvault-name> \
  --name "app-encryption-key"
```

**Exam tip:** The key material itself never leaves Key Vault. Applications send data to Key Vault for encryption/decryption operations.

## Exercise 3: Working with Certificates

Certificates combine cryptographic keys with identity metadata (X.509 format). They're used for TLS/SSL, authentication, and code signing.

### Create a Certificate Policy

Certificates require a policy that defines their properties:

```bash
cat > cert-policy.json << 'EOF'
{
  "issuerParameters": {
    "name": "Self"
  },
  "keyProperties": {
    "exportable": true,
    "keySize": 2048,
    "keyType": "RSA",
    "reuseKey": false
  },
  "secretProperties": {
    "contentType": "application/x-pkcs12"
  },
  "x509CertificateProperties": {
    "subject": "CN=myapp.azurewebsites.net",
    "validityInMonths": 12,
    "subjectAlternativeNames": {
      "dnsNames": [
        "myapp.azurewebsites.net",
        "www.myapp.azurewebsites.net"
      ]
    }
  }
}
EOF
```

**Key policy elements for the exam:**

- **issuerParameters.name**: "Self" for self-signed, or a CA name for production certificates
- **keyProperties.exportable**: Whether the private key can be exported
- **keyProperties.keyType**: RSA (most common) or EC
- **x509CertificateProperties.subject**: The certificate's distinguished name (DN)
- **validityInMonths**: Certificate lifetime
- **subjectAlternativeNames**: Additional domain names the certificate covers

### Create the Certificate

```bash
az keyvault certificate create \
  --vault-name <keyvault-name> \
  --name "app-certificate" \
  --policy @cert-policy.json
```

Certificate creation can take a few seconds as Key Vault generates the key pair and creates the certificate.

### Download Certificate

Download in PEM format (text-based, includes certificate chain):

```bash
az keyvault certificate download \
  --vault-name <keyvault-name> \
  --name "app-certificate" \
  --file app-cert.pem \
  --encoding PEM
```

**Exam tip:** When you create a certificate in Key Vault, it automatically creates three objects:
1. A certificate object (combines key and metadata)
2. A key object (the private key)
3. A secret object (the full certificate with private key in PKCS12 format)

This means you can access the certificate through multiple interfaces depending on your needs.

## Exercise 4: Managed Identities - Critical for AZ-204

Managed Identities are one of the most important concepts for the AZ-204 exam. They eliminate the need to store credentials in your code.

**Key concept:** A Managed Identity is an identity in Azure AD that Azure manages for you. Your application can use this identity to authenticate to Azure services without storing any credentials.

### System-Assigned Managed Identity

System-assigned identities are tied to a specific Azure resource. When you delete the resource, the identity is automatically deleted.

Create an App Service with a system-assigned managed identity:

```bash
# Create App Service Plan
az appservice plan create \
  -g labs-keyvault-az204 \
  -n keyvault-plan \
  --sku B1

# Create Web App with managed identity
az webapp create \
  -g labs-keyvault-az204 \
  -p keyvault-plan \
  -n <webapp-name> \
  --runtime "DOTNET:6.0" \
  --assign-identity [system]
```

The `--assign-identity [system]` flag creates a managed identity for this web app.

Get the identity's principal ID:

```bash
PRINCIPAL_ID=$(az webapp identity show \
  -g labs-keyvault-az204 \
  -n <webapp-name> \
  --query principalId -o tsv)

echo "Managed Identity Principal ID: $PRINCIPAL_ID"
```

Now grant this identity access to your Key Vault:

```bash
az keyvault set-policy \
  --name <keyvault-name> \
  --object-id $PRINCIPAL_ID \
  --secret-permissions get list
```

**What we've done:**
1. Created a web app with a system-assigned managed identity
2. Granted that identity permission to read secrets from Key Vault
3. Now code running in this web app can access Key Vault without any credentials in the code

### User-Assigned Managed Identity

User-assigned identities have an independent lifecycle. They can be shared across multiple resources and aren't deleted when resources are deleted.

Create a user-assigned managed identity:

```bash
az identity create \
  -g labs-keyvault-az204 \
  -n myUserIdentity
```

Get the identity details:

```bash
USER_IDENTITY_ID=$(az identity show \
  -g labs-keyvault-az204 \
  -n myUserIdentity \
  --query id -o tsv)

USER_PRINCIPAL_ID=$(az identity show \
  -g labs-keyvault-az204 \
  -n myUserIdentity \
  --query principalId -o tsv)
```

Assign it to the web app:

```bash
az webapp identity assign \
  -g labs-keyvault-az204 \
  -n <webapp-name> \
  --identities $USER_IDENTITY_ID
```

Grant Key Vault access:

```bash
az keyvault set-policy \
  --name <keyvault-name> \
  --object-id $USER_PRINCIPAL_ID \
  --secret-permissions get list
```

**Exam question pattern:** "You need to allow multiple App Services to access the same Key Vault. The solution must ensure identities persist even if individual apps are deleted. What should you do?"
- **Answer:** Use a user-assigned managed identity shared across all apps.

## Exercise 5: Access Policies vs Azure RBAC

Understanding both permission models is important for the exam.

### Access Policies (Classic Model)

Access policies are configured at the Key Vault level and specify what each identity can do with secrets, keys, and certificates separately.

Grant comprehensive secret permissions:

```bash
az keyvault set-policy \
  --name <keyvault-name> \
  --upn <user@example.com> \
  --secret-permissions get list set delete backup restore recover purge
```

Grant limited permissions for an application:

```bash
az keyvault set-policy \
  --name <keyvault-name> \
  --object-id <app-object-id> \
  --secret-permissions get list
```

**Advantages:**
- Fine-grained control over individual operations
- Separate permissions for secrets, keys, and certificates
- No additional Azure RBAC configuration needed

**Disadvantages:**
- Different permission model than other Azure resources
- Management at the vault level only
- Doesn't integrate with Azure management group policies

### Azure RBAC Model (Recommended)

The RBAC model uses standard Azure role assignments. This is now the recommended approach for new Key Vaults.

Create a Key Vault with RBAC enabled:

```bash
az keyvault create \
  -g labs-keyvault-az204 \
  -n <keyvault-rbac-name> \
  --enable-rbac-authorization true
```

Assign a built-in role:

```bash
az role assignment create \
  --role "Key Vault Secrets User" \
  --assignee <user@example.com> \
  --scope "/subscriptions/<subscription-id>/resourceGroups/labs-keyvault-az204/providers/Microsoft.KeyVault/vaults/<keyvault-rbac-name>"
```

**Key Vault RBAC roles you must know for the exam:**

1. **Key Vault Administrator** - Full access to all Key Vault operations
2. **Key Vault Secrets Officer** - Full management of secrets (create, read, update, delete)
3. **Key Vault Secrets User** - Read secret values only
4. **Key Vault Crypto Officer** - Full management of keys
5. **Key Vault Crypto User** - Use keys for cryptographic operations (encrypt, decrypt, sign, verify)
6. **Key Vault Certificates Officer** - Full management of certificates
7. **Key Vault Reader** - Read metadata but not secret/key values

**Exam tip:** When RBAC is enabled, access policies are ignored. You must choose one model or the other, not both.

## Exercise 6: Using Key Vault in Application Code

This is the most important section for the AZ-204 exam. You need to know how to write code that uses Key Vault.

### .NET SDK with Managed Identity

Here's the pattern you need to know:

```csharp
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;

// DefaultAzureCredential automatically uses the managed identity
var client = new SecretClient(
    new Uri("https://<keyvault-name>.vault.azure.net/"),
    new DefaultAzureCredential());

// Get a secret
KeyVaultSecret secret = await client.GetSecretAsync("DatabaseConnectionString");
Console.WriteLine($"Connection string: {secret.Value}");

// Set a secret
await client.SetSecretAsync("NewApiKey", "<api-key-value>");

// Delete a secret
await client.StartDeleteSecretAsync("OldApiKey");
```

**Critical exam concept - DefaultAzureCredential:**

DefaultAzureCredential tries multiple authentication methods in order:
1. **Environment variables** - Checks for service principal credentials
2. **Managed Identity** - Uses system or user-assigned managed identity
3. **Visual Studio** - Uses your VS credentials
4. **Azure CLI** - Uses your `az login` credentials
5. **Azure PowerShell** - Uses your PowerShell credentials
6. **Interactive browser** - Falls back to browser-based auth

This means the same code works:
- In production (uses managed identity)
- In development (uses your local Azure CLI credentials)
- In CI/CD pipelines (uses service principal credentials from environment variables)

### Integration with App Service Configuration

App Service has a special feature for Key Vault integration:

```bash
az webapp config appsettings set \
  -g labs-keyvault-az204 \
  -n <webapp-name> \
  --settings \
    "DatabaseConnection=@Microsoft.KeyVault(SecretUri=https://<keyvault-name>.vault.azure.net/secrets/DatabaseConnectionString/)"
```

**How this works:**
1. The setting value starts with `@Microsoft.KeyVault(`
2. App Service recognizes this as a Key Vault reference
3. It uses the app's managed identity to retrieve the secret
4. Your application code reads the setting as normal - it just sees the secret value, not the Key Vault URI
5. App Service automatically refreshes the value when the secret changes (within 24 hours)

**Exam tip:** The app's managed identity must have Get permission on the secret for this to work.

### Python SDK Example

The pattern is similar across languages:

```python
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

credential = DefaultAzureCredential()
client = SecretClient(
    vault_url="https://<keyvault-name>.vault.azure.net/",
    credential=credential
)

# Get secret
secret = client.get_secret("DatabaseConnectionString")
print(f"Secret value: {secret.value}")

# Set secret
client.set_secret("NewApiKey", "<api-key-value>")
```

**Exam pattern:** You'll see code snippets and need to identify what's wrong or what's missing. Common issues:
- Missing using/import statements
- Wrong credential type (using a specific credential instead of DefaultAzureCredential)
- Hardcoded vault URLs instead of configuration
- Not using async/await properly in async contexts

## Exercise 7: Backup, Recovery, and Soft Delete

Understanding data protection is important for production scenarios.

### Backup and Restore

Backup a secret to a file:

```bash
az keyvault secret backup \
  --vault-name <keyvault-name> \
  --name "DatabaseConnectionString" \
  --file secret-backup.blob
```

The backup file is encrypted and can only be restored to a Key Vault in the same Azure geography.

Restore from backup:

```bash
az keyvault secret restore \
  --vault-name <keyvault-name> \
  --file secret-backup.blob
```

**Exam tip:** Backups include all versions of the secret.

### Soft Delete

Soft delete is enabled by default on new Key Vaults:

```bash
az keyvault update \
  -g labs-keyvault-az204 \
  -n <keyvault-name> \
  --enable-soft-delete true \
  --retention-days 90
```

When you delete a secret, it enters a "deleted" state but can be recovered:

```bash
# Delete a secret
az keyvault secret delete \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey"

# List deleted secrets
az keyvault secret list-deleted \
  --vault-name <keyvault-name>

# Recover a deleted secret
az keyvault secret recover \
  --vault-name <keyvault-name> \
  --name "ExternalApiKey"
```

### Purge Protection

Purge protection prevents permanent deletion during the retention period:

```bash
az keyvault update \
  -g labs-keyvault-az204 \
  -n <keyvault-name> \
  --enable-purge-protection true
```

**Important:** Once enabled, purge protection cannot be disabled.

With purge protection:
- Deleted secrets can be recovered but not purged during retention
- This prevents accidental or malicious permanent deletion
- Required for some compliance scenarios

**Exam scenario:** "You need to ensure deleted secrets can be recovered but prevent administrators from permanently deleting secrets immediately. What should you do?"
- **Answer:** Enable both soft delete and purge protection.

## AZ-204 Exam Study Points

### Secret vs Key vs Certificate

This distinction appears frequently on the exam:

**Secrets:**
- Store: Passwords, connection strings, API keys
- Max size: 25 KB
- Operations: Set, get, list, delete
- Use when: Applications need to read the value directly

**Keys:**
- Store: RSA, EC, or symmetric cryptographic keys
- Operations: Encrypt, decrypt, sign, verify, wrap, unwrap
- Use when: Performing cryptographic operations without exposing key material

**Certificates:**
- Store: X.509 certificates with private keys
- Operations: Create, import, update, delete, download
- Use when: TLS/SSL, authentication, code signing
- Key Vault can automatically renew from supported CAs

### Managed Identity Decision Tree

**Question:** Which type of managed identity should I use?

**System-assigned when:**
- Identity is needed for a single resource
- Identity should be deleted when resource is deleted
- Simpler setup (one command)

**User-assigned when:**
- Identity needs to be shared across multiple resources
- Identity should persist beyond resource lifecycle
- Need to pre-configure permissions before attaching to resources
- Managing multiple environments with reusable identities

### Common Exam Scenarios and Solutions

**Scenario 1:** "A web app needs database credentials. The app is deployed to Azure App Service. What is the most secure approach?"

**Solution:**
1. Store connection string in Key Vault as a secret
2. Enable system-assigned managed identity on the App Service
3. Grant the managed identity Get permission on the secret
4. Use Key Vault reference in app settings: `@Microsoft.KeyVault(SecretUri=...)`
5. App code reads from configuration (not aware of Key Vault)

**Scenario 2:** "An API key needs to be rotated every 30 days without application downtime."

**Solution:**
1. Store API key in Key Vault as a secret
2. Set expiration date 30 days from now
3. Application references secret by name (no version specified)
4. When rotation is needed, create new version of secret
5. New version becomes current automatically
6. Application gets new key on next retrieval
7. Set up Azure Monitor alert for approaching expiration

**Scenario 3:** "Multiple Azure Functions need the same database connection. Functions are in different resource groups."

**Solution:**
1. Create a user-assigned managed identity
2. Grant it access to Key Vault secrets
3. Assign the same user-assigned identity to all Function Apps
4. Functions use DefaultAzureCredential to access Key Vault
5. Identity persists even if individual functions are deleted/recreated

**Scenario 4:** "Developer needs to test Key Vault integration locally without deploying to Azure."

**Solution:**
1. Use DefaultAzureCredential in code
2. Ensure developer has appropriate Key Vault permissions (Azure RBAC role or access policy)
3. Run `az login` locally before testing
4. DefaultAzureCredential automatically uses Azure CLI credentials
5. Same code works in both local development and Azure production

**Scenario 5:** "Prevent accidental permanent deletion of production secrets."

**Solution:**
1. Enable soft-delete with 90-day retention
2. Enable purge-protection
3. Use Azure RBAC with least-privilege roles
4. Deleted secrets can be recovered within 90 days
5. No one can purge (permanently delete) during retention period

### Best Practices Summary

For the exam, know these best practices:

1. **Never hardcode secrets** - Always use Key Vault
2. **Always use Managed Identities** in Azure - Never store credentials for Key Vault access
3. **Use DefaultAzureCredential** - Works across dev, test, and production
4. **Reference secrets by name** - Never specify version in application code
5. **Enable soft-delete and purge protection** - Protect against accidental deletion
6. **Set expiration dates** - Force regular secret rotation
7. **Use Azure RBAC** for new vaults - Simpler and more consistent
8. **Use Key Vault references** in App Service - Automatic secret resolution and refresh
9. **Separate Key Vaults** by environment - Different vaults for dev/test/prod
10. **Monitor and alert** - Track access and expiration with Azure Monitor

### Authentication Methods Priority

Know when to use each authentication method:

1. **Managed Identity** (Recommended)
   - Use for: Any Azure resource (App Service, Functions, VMs, Containers)
   - Advantages: No credentials to manage, automatic rotation, most secure

2. **Service Principal with Certificate** (Second choice)
   - Use for: Non-Azure resources, hybrid scenarios
   - Advantages: More secure than secret-based
   - Disadvantages: Certificate management required

3. **Service Principal with Secret**
   - Use for: CI/CD pipelines, non-Azure automation
   - Advantages: Simpler than certificate
   - Disadvantages: Secret must be stored securely and rotated

4. **User credentials**
   - Use for: Local development only
   - Never use in production

### DefaultAzureCredential Chain Details

Memorize this order for the exam:

1. **EnvironmentCredential** - Service principal from environment variables:
   - AZURE_TENANT_ID
   - AZURE_CLIENT_ID
   - AZURE_CLIENT_SECRET or AZURE_CLIENT_CERTIFICATE_PATH

2. **ManagedIdentityCredential** - System or user-assigned managed identity

3. **SharedTokenCacheCredential** - Visual Studio credentials

4. **VisualStudioCodeCredential** - VS Code Azure Account extension

5. **AzureCliCredential** - `az login` credentials

6. **AzurePowerShellCredential** - `Connect-AzAccount` credentials

7. **InteractiveBrowserCredential** - Browser-based login

## Practice Questions Style

The exam will test you with questions like:

**Question Type 1: Choose correct code**
"Which code correctly retrieves a secret from Key Vault using managed identity?"

**Question Type 2: Identify error**
"The following code throws an authentication exception. What is the cause?"

**Question Type 3: Complete the solution**
"You need to configure an App Service to read a database password from Key Vault. Which three actions should you perform in sequence?"

**Question Type 4: Choose best practice**
"Which approach follows Microsoft's security best practices for accessing Key Vault from Azure Functions?"

## Cleanup

Remove all resources when you're done:

```bash
az group delete -y -n labs-keyvault-az204 --no-wait
```

## Final Exam Tips

1. **Understand the SDK** - Know the basic code patterns for getting, setting, and deleting secrets
2. **Managed Identities are key** - Most secure solution questions involve managed identities
3. **Know the RBAC roles** - Be able to choose the right role for scenarios
4. **Understand versioning** - Applications reference by name, operations can specify version
5. **DefaultAzureCredential** - Understand its credential chain and why it's recommended
6. **Key Vault references** - Know the `@Microsoft.KeyVault()` syntax for App Service
7. **Soft delete vs purge protection** - Understand what each protects against
8. **Permissions** - Know what permissions are needed for common operations

Good luck with your AZ-204 exam preparation!
