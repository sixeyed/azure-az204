# Multi-Stage Builds - AZ-204 Exam Exercises

Multi-stage Docker builds appear throughout the AZ-204 exam in the containerized solutions domain. The exam expects you to understand how to create optimized production images, and multi-stage builds are the industry standard approach. These exercises go beyond basic Docker concepts to focus on the build optimization techniques and patterns that appear in real-world Azure deployments.

## Prerequisites

You should complete the basic Docker 101 lab before working on multi-stage builds. Understanding how Docker images and containers work, how Dockerfiles are structured, and how the docker build command operates are essential foundations. These advanced exercises assume you're comfortable with single-stage builds and ready to explore production-optimized image creation.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate several advanced capabilities with Docker builds. You'll need to master multi-stage build syntax using multiple FROM instructions and understand how to copy artifacts between stages. BuildKit optimization with parallel stage execution and intelligent stage skipping is important for efficient builds. Using the target flag to build specific stages appears in CI/CD scenarios. Understanding the dramatic difference between SDK and runtime image sizes helps you optimize deployments. Creating language-specific build patterns for .NET, Go, Node, and Java shows practical competence. Finally, you must understand how layer caching works and how to structure Dockerfiles for optimal build performance.

## Image Size and Security

Understanding why multi-stage builds matter is crucial for the exam. A 300MB SDK image versus a 10MB production image represents more than just storage savings. The exam tests your understanding of the broader implications.

Deployment speed improves dramatically with smaller images. In Azure Container Instances, faster image pulls mean faster container startup. In Azure App Service, smaller images deploy more quickly. In AKS, node scaling is faster when images are small. Every byte matters when you're pulling images across networks.

Network costs decrease with smaller images. Azure Container Registry charges for storage and egress. Pulling a 10MB image to hundreds of container instances costs far less than pulling 300MB images. For high-traffic applications, these savings compound quickly.

Security posture improves with minimal images. SDK images contain compilers, debuggers, and development tools that represent potential attack vectors. Each additional package is another possible CVE. Production images should contain only the runtime and your application code. The exam frequently asks about security best practices, and minimal images are part of the answer.

## Multi-Stage Build Patterns

The exam tests your knowledge of multi-stage build patterns across different languages and frameworks. Understanding the general pattern helps you adapt to any technology stack.

For .NET applications, the builder stage uses mcr.microsoft.com/dotnet/sdk to compile the application. The production stage uses mcr.microsoft.com/dotnet/runtime for console apps or mcr.microsoft.com/dotnet/aspnet for web applications. You copy only the published output from the builder, not the source code or SDK tools.

For Go applications, the builder stage uses golang to compile the binary. The production stage can use scratch, an empty image with literally nothing in it, because compiled Go binaries are static. This creates the absolute minimal image possible. Alternatively, use distroless images that include only system libraries without package managers or shells.

For Node.js applications, the builder stage runs npm install to download dependencies and optionally runs build steps for TypeScript or bundling. The production stage installs only production dependencies with npm install production and copies built artifacts. This excludes development dependencies that aren't needed at runtime.

For Java applications, the builder stage uses Maven or Gradle images to compile and package the application. The production stage uses JRE images rather than JDK, copying only the JAR or WAR file. This excludes the compiler and build tools from production.

The exam presents scenarios describing applications in different languages and asks you to identify the appropriate base images or build strategy. Understanding the pattern of SDK for building and runtime for production helps you answer these questions regardless of the specific technology.

## BuildKit Advantages

BuildKit is Docker's modern build engine that the exam expects you to understand. The performance improvements are significant, and knowing when and how to use BuildKit helps you answer optimization questions.

Parallel stage execution means independent stages run simultaneously. In a multi-stage build, if the test stage doesn't depend on anything after the build stage, BuildKit can run testing in parallel with later stages. This can dramatically reduce total build time for complex applications.

Intelligent stage skipping analyzes the Dockerfile dependency graph. If a stage's output isn't used anywhere, BuildKit skips it entirely. In the lab, the test stage was skipped automatically during normal builds because nothing copied from it. This optimization happens without any special flags or configuration.

Better caching with build cache mounts and secret mounts improves build performance. BuildKit can mount external caches for package managers like npm or Maven, avoiding repeated downloads. Secret mounts provide build-time secrets without leaving them in image layers, improving security.

The exam might present scenarios requiring build optimization. Look for keywords like "reduce build time" or "optimize CI/CD pipeline," and consider BuildKit features as part of your answer. Enabling BuildKit is as simple as setting the DOCKER_BUILDKIT environment variable to 1.

## Using Build Targets

The target flag lets you build up to a specific stage, which appears in several exam scenarios. Understanding when and why to use targets is important.

In CI/CD pipelines, you might build a test target that includes testing frameworks and runs automated tests. The pipeline builds to this target, runs tests, and only proceeds to building the production image if tests pass. This pattern provides fast feedback while keeping production images minimal.

For different deployment environments, you might have separate final stages for development and production. The development target includes debugging tools and verbose logging. The production target is minimal. Using targets lets one Dockerfile support multiple scenarios without duplication.

For troubleshooting, building intermediate stages helps debug build failures. If your production build fails, build the builder target to examine what's in that stage. You can run a container from the intermediate image to inspect the environment and diagnose issues.

The exam presents scenarios requiring different image variants or testing during builds. The target flag is often part of the solution. Remember the syntax is docker build target stage-name.

## Layer Caching Optimization

Understanding Docker layer caching is essential for the exam because it directly affects build performance. The exam tests this through scenarios about slow builds or questions about Dockerfile best practices.

Docker caches each layer created by Dockerfile instructions. When you rebuild, Docker reuses cached layers until it encounters a change. Everything after the change must rebuild. This means instruction order matters significantly.

Copy dependencies first before copying application code. For .NET, copy the csproj file and run dotnet restore before copying source code. For Node, copy package.json and run npm install before copying the application. This pattern ensures dependency installation layers cache and rebuild only when dependencies change, not when code changes.

Combine commands carefully to balance layer count and caching. Multiple RUN commands create multiple layers, increasing image size. Combining commands reduces layers but means the entire combined operation reruns if anything changes. The best practice is to group operations that change together.

Use dockerignore to exclude unnecessary files from the build context. If your build context contains gigabytes of files that aren't needed, Docker must send all that data to the build engine. The dockerignore file works like gitignore, excluding files from the build context.

The exam presents scenarios about slow builds or asks you to optimize a Dockerfile. Look for opportunities to reorder instructions for better caching, exclude unnecessary files with dockerignore, or combine operations appropriately.

## Integration with Azure Services

Multi-stage builds integrate with Azure services that appear on the AZ-204 exam. Understanding these connections helps you answer integration questions.

Azure Container Registry supports ACR Tasks, which can build images directly in Azure using your Dockerfile. You push source code to ACR and it builds the image using your multi-stage Dockerfile. This eliminates the need for build infrastructure and leverages Azure's compute for building. The az acr build command triggers builds, and ACR handles the entire build process.

Azure DevOps pipelines and GitHub Actions use multi-stage Dockerfiles in CI/CD workflows. The pipeline builds images and pushes them to ACR for deployment. Understanding how multi-stage builds fit into automated pipelines helps you answer DevOps questions on the exam.

Azure Container Instances and Azure App Service deploy images built with multi-stage Dockerfiles. The smaller production images from multi-stage builds deploy faster and start more quickly. The exam may ask about improving deployment performance, and optimized images are part of the answer.

Azure Kubernetes Service benefits from multi-stage builds through faster node scaling and reduced image pull times. When AKS scales out, it pulls images to new nodes. Smaller images mean faster scaling.

## AZ-204 Exam Study Points

Let's consolidate the key points for the exam. Multi-stage builds use multiple FROM instructions to create separate build and runtime stages. Each stage can use different base images optimized for that purpose.

Image size matters for deployment speed, network costs, and security. Production images should contain only runtime dependencies and application code. SDK tools and build dependencies should remain in builder stages.

BuildKit provides parallel stage execution and intelligent stage skipping. Enable it by setting DOCKER_BUILDKIT=1. It's the default in recent Docker versions but understanding the advantages helps answer optimization questions.

Build targets let you build specific stages with the target flag. Use this for testing during CI/CD, creating different image variants, or troubleshooting build failures.

Layer caching optimization involves ordering Dockerfile instructions from least to most frequently changing. Copy dependencies before code, use dockerignore to exclude unnecessary files, and combine commands appropriately.

Integration with Azure services means understanding ACR Tasks for cloud-based builds, DevOps pipelines that build and deploy images, and how container services benefit from optimized images.

Understanding these concepts at a practical level is what the exam tests. Practice creating multi-stage builds for different languages, optimize build performance, and understand the benefits beyond just smaller images. The hands-on experience from these labs provides the foundation for the AZ-204 certification.

## Cleanup

Removing containers with docker rm -f cleans up your environment. The pattern of piping docker ps -aq to docker rm -f removes all containers at once. This cleanup is straightforward for local development, while Azure services handle container lifecycle management automatically in production.
