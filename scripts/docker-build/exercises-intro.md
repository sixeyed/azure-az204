We've covered multi-stage builds as the pattern for creating optimized production-ready images. Now let's see dramatic image size reductions in action and understand why this approach is the industry standard.

You'll start by looking at the reference documentation including multi-stage build docs and sample Dockerfiles in different languages. Then you'll work with multi-stage Dockerfiles using the original build engine so it's clear what's happening in the build. You'll build a simple multi-stage Dockerfile with base, build, test, and final stages. Each stage uses a different FROM instruction where the base stage simulates adding dependencies, the build stage builds on the base and simulates an app build, the test stage starts from the build output and simulates automated testing, and the final stage starts from base and copies in the build output. All the stages run but the final app image only has content explicitly added from earlier stages. Build tools stay in intermediate stages and never make it to production.

Next, you'll explore BuildKit and build targets which is an alternative build engine in Docker. BuildKit is heavily optimized for multi-stage builds running stages in parallel and skipping stages if the output isn't used. You'll switch to BuildKit by setting an environment variable and repeat the build to see output from different stages at the same time. If you look closely you'll see the test stage is skipped because none of the output is used in later stages. You can explicitly build an image up to a specific stage with the target flag where Docker will build all stages up to and including the named one. This image is the output of that stage not the final stage. This single Dockerfile serves both development and production needs.

After that, you'll build a simple Go application to see real multi-stage builds in action. The pattern uses an SDK image to compile the app in the build stage and a smaller runtime image with no build tools to package the compiled app. The images you use and the commands you run are different for each language but you'll find official images on Docker Hub for all major platforms. SDK images are typically very large having the whole build toolset, so you don't want to use an SDK image in your final stage otherwise you'll have all that stuff in your app image. When you compare sizes, the SDK image is over 300MB while the app image is under 10MB. That's a 97 percent reduction. Smaller images mean faster pushes to Azure Container Registry, faster pulls when deploying, and lower storage costs.

The lab exercise tackles the challenge of configuring application arguments in multi-stage builds. Apps need special Linux permissions to listen on the standard HTTP ports even inside a container. You'll run the app using an application argument to listen on a specific port and see what happens when you run a container with the publish-all option. This teaches you important patterns for flexible configurable containers. Finally, you'll look at cleanup procedures to remove all containers. Let's optimize Docker images with multi-stage builds!
