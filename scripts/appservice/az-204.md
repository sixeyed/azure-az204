# App Service for Web Apps - AZ-204 Exam Exercises

Azure App Service is a critical topic for the AZ-204 certification exam, appearing throughout the exam objectives and typically accounting for fifteen to twenty percent of your exam score. This service appears particularly in the "Implement Azure App Service web apps" domain, and these exercises focus specifically on the production scenarios and advanced features you'll encounter in the exam. The AZ-204 exam tests not just your ability to create and use App Service, but your understanding of deployment strategies, scaling approaches, and integration patterns.

## Prerequisites

You should complete the basic App Service lab before diving into these exam-focused exercises. The fundamental concepts like resource creation, basic deployment, and Git integration are essential building blocks. These advanced exercises assume you're comfortable with the basics and ready to explore the features that distinguish enterprise deployments from simple development scenarios.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of App Service capabilities. You'll need to understand how to create and configure Azure App Service web apps, which includes choosing the right pricing tier and configuring the compute resources appropriately. Implementing continuous deployment scenarios is crucial because modern development relies heavily on automated build and deployment pipelines. Configuring web app settings including connection strings and app settings appears frequently because proper configuration management is fundamental to cloud applications. Enabling diagnostic logging is essential for troubleshooting and monitoring production applications. Configuring and implementing autoscaling ensures your applications can handle varying loads cost-effectively. Finally, you must understand App Service plans deeply because they define the infrastructure that runs your applications.

## Understanding App Service Plans

App Service Plans are fundamental to the AZ-204 exam because many scenarios hinge on understanding what they are and how they work. The App Service Plan isn't just a pricing tier - it's the actual unit of compute that runs your web apps. Think of it as the virtual machine or set of virtual machines that host your applications. This distinction is important because multiple apps can run on the same App Service Plan, sharing the compute resources. The plan defines the region where your apps run, which is significant because you cannot move apps between regions without recreating them in a different plan. The SKU determines the available features and capacity, affecting everything from the number of instances you can scale to, to advanced features like deployment slots and VNet integration. You can scale up by changing the SKU to get more CPU and memory, or scale out by adding more instances to handle more concurrent requests.

Understanding the pricing tiers is critical for exam success. The Free and Shared tiers provide shared infrastructure suitable only for development and testing. These tiers have no SLA, limited resources, and don't support custom domains with SSL. Basic tier gives you dedicated compute with three SKU options. It's suitable for low-traffic production apps and supports manual scaling, but lacks autoscaling and deployment slots. Standard tier represents the production baseline with three SKU options providing more resources. This tier supports autoscale, staging slots for zero-downtime deployments, and daily backups. Most production workloads that don't require advanced enterprise features will use Standard. Premium tier unlocks enhanced performance with three versions available. You get more storage, more instances, better performance, and additional staging slots. This tier is ideal for high-traffic applications requiring maximum performance. Isolated tier provides dedicated virtual network isolation with maximum scale and performance. This is for scenarios requiring complete network isolation and the highest levels of compute resources.

An important exam point that catches many candidates is that you can upgrade tiers but you cannot downgrade. Once you move from Basic to Standard or from Standard to Premium, you're committed. This is why understanding the tier features upfront is so important for making the right architectural decisions. The exam might present a scenario where you need to enable deployment slots or configure autoscaling, and you'll need to recognize that certain tiers are required for these features.

## Deployment Methods

The exam covers multiple deployment scenarios extensively, and you need to understand when each approach is appropriate. Local Git deployment, which we demonstrated in the lab, allows App Service to act as a Git remote. You push your code, and Azure builds and deploys it automatically. This is simple for learning but not recommended for production due to security concerns with embedded credentials in the URL. However, you absolutely need to know how to configure it for the exam because scenarios may specifically ask about Git deployment.

External Git repositories provide more robust options. You can configure continuous deployment from GitHub, which is increasingly common in enterprise environments. Azure Repos integration works seamlessly if you're using Azure DevOps for your source control. Bitbucket is also supported for teams using that platform. Each of these can be configured for either manual deployment, where you trigger builds explicitly, or continuous deployment, where pushes to specific branches automatically trigger builds and deployments.

Container deployments represent another major category. App Service supports deploying from Azure Container Registry, which is the typical choice for containerized applications in Azure. Docker Hub works for public images or if you have Docker Hub credentials configured. Private registries can also be used if you're running your own container registry infrastructure. Understanding when to use container-based deployment versus source-based deployment is an important exam skill.

Other deployment methods include FTP and FTPS for traditional file transfer-based deployment, though this is falling out of favor. OneDrive and Dropbox integration exists for simple scenarios but isn't recommended for production. ZIP deploy provides a quick way to package and deploy your application. Azure DevOps pipelines offer the most comprehensive CI/CD solution with full control over build and release processes. For the exam, you should know the appropriate use cases for each method and understand their trade-offs in terms of automation, security, and complexity.

## Application Settings and Configuration

This is a heavily tested area on the AZ-204 exam, and understanding configuration management is critical. Application settings are essentially environment variables that your application can read at runtime. They override settings in your configuration files like web.config for .NET Framework apps or appsettings.json for .NET Core apps. This override behavior is crucial to understand because it allows you to deploy the same code to different environments with environment-specific configuration. Settings can be marked as slot-specific for staging scenarios, meaning they stay with the deployment slot during a swap operation rather than moving with the code. Common uses include feature flags that enable or disable functionality, API endpoints that differ between environments, and non-sensitive configuration values that need to change between development, staging, and production.

Connection strings receive special handling in App Service. They're specifically designed for database connections and Azure encrypts them at rest for security. Connection strings can also be marked as slot-specific or not, depending on whether you want them to swap with the code. The system supports different types including SQLServer for on-premises SQL Server, SQLAzure for Azure SQL Database, Custom for other database types, and several other specialized types. Understanding when to use connection strings versus app settings is important for the exam.

Configuration precedence is a concept that appears frequently in exam scenarios. App Settings in Azure take precedence over values in application configuration files. This means if you have a setting named ConnectionString in your appsettings.json with value "localhost", but you configure an App Setting named ConnectionString with value "production-server", your application will use "production-server". This precedence enables the twelve-factor app principle of configuration, where the same code runs everywhere but behavior changes based on environment configuration.

Slot settings add another layer of sophistication. When you mark a setting as a "deployment slot setting," it stays with the slot during a swap operation. This is critical for scenarios where staging and production need different database connections or API keys. During a swap, the slot-sticky settings remain with their respective slots while non-sticky settings move with the code. Understanding this behavior is essential for zero-downtime deployment scenarios that appear frequently on the exam.

## Deployment Slots

Deployment slots are a Standard tier feature and above, and they're heavily tested on the AZ-204 exam. The purpose is straightforward but powerful: test changes in a staging environment before production, perform zero-downtime deployments by warming up the new version before swapping, and enable easy rollback if issues are detected after deployment. Each slot is essentially a separate app with its own hostname, so you can test thoroughly before making changes visible to users.

Understanding how swapping works is critical for exam success. The swap operation exchanges the content and certain configuration between slots. Before the swap completes, Azure warms up the target slot by sending requests to it, ensuring that all instances are initialized and ready to serve traffic. This eliminates cold start delays that could impact users. Auto-swap can be configured for continuous deployment scenarios where you want new code automatically deployed to production after it's successfully deployed and tested in staging.

Slot-specific settings determine what stays with the slot versus what moves during a swap. Connection strings and app settings can be marked as slot-specific. When marked this way, they don't move during a swap - staging keeps the staging database connection, and production keeps the production database connection, even after the code is swapped. Most other configuration moves with the code during a swap. Understanding which settings stay and which move is a common exam question.

The exam loves scenarios involving deployment slots because they test multiple concepts simultaneously. You need to know the tier requirements, understand the swap behavior, recognize when to use slot-specific settings, and be able to design deployment workflows that leverage slots for zero-downtime deployments. Practice creating slots, configuring them differently, deploying to them, and swapping them until the workflow becomes second nature.

## Diagnostic Logging

For the AZ-204 exam, you need to understand the different types of logging that App Service provides. Application logging captures log messages generated by your application code. You can send these logs to the filesystem for temporary storage, where they're automatically deleted after a period, or to blob storage for permanent retention. Different log levels are available including Verbose for everything, Information for general informational messages, Warning for things that might need attention, and Error for actual problems. Choosing the right log level affects both the volume of logs and the storage costs.

Web server logging provides raw HTTP request logs stored in W3C extended log format. This captures every HTTP request with details like the URL, response code, response time, and client information. These logs are invaluable for understanding traffic patterns and diagnosing HTTP-level issues. The exam might present scenarios where you need to troubleshoot why certain requests are failing, and web server logs would be the appropriate diagnostic tool.

Detailed error messages provide detailed HTML error pages for HTTP errors with status codes of 400 or higher. These pages include information about what went wrong and can help diagnose issues. Failed request tracing goes even deeper, providing detailed tracing for failed requests including information about IIS modules that processed the request. This is particularly useful for diagnosing performance problems or understanding complex request processing scenarios.

Deployment logging is automatically enabled and records details of application deployments. This includes information about what was deployed, when, and whether the deployment succeeded or failed. The exam might ask you how to determine when a deployment occurred or what version is currently deployed, and deployment logs provide this information.

Understanding which log type to use for different troubleshooting scenarios is an important exam skill. Application issues typically require application logs. HTTP errors need web server logs or detailed error messages. Performance problems might need failed request tracing. Deployment issues obviously require deployment logs. Know the characteristics and use cases for each type.

## Scaling Strategies

The AZ-204 exam tests your understanding of both scaling approaches thoroughly. Scale up, also called vertical scaling, means changing to a higher or lower pricing tier to get more or less resources. When you scale up from Basic to Standard, you get more CPU, more memory, and additional features like deployment slots and autoscale. This requires an app restart because you're moving to different underlying infrastructure. In the lab, if we wanted better performance or more features, scaling up from B1 to S1 would provide those benefits.

Scale out, also called horizontal scaling, means adding more instances of your application. Each instance is a separate server running your code, and Azure's load balancer distributes incoming requests across all healthy instances. You can scale out manually by specifying the number of instances, or automatically based on metrics or schedules. Scaling out doesn't require an app restart because you're just adding more of the same infrastructure. In the lab, we configured two worker instances, which provided redundancy and increased capacity. If we needed even more capacity, scaling out to three or five instances would handle more concurrent users.

Autoscaling is available in Standard tier and above and is a major exam topic. You can scale based on metrics, where Azure monitors things like CPU percentage, memory percentage, or HTTP queue length and automatically adds or removes instances to keep these metrics within acceptable ranges. You can also scale based on schedule, where you define rules that say "scale up during business hours and scale down at night" or "scale up before a known high-traffic event." Understanding how to configure autoscale rules is essential, including concepts like the cool-down period that prevents rapid scaling changes and the minimum and maximum instance counts that define boundaries for scaling.

The exam frequently presents scenarios where you need to choose between scaling up and scaling out. Generally, scaling out is preferred for handling increased load because it provides redundancy and can be done without downtime. Scaling up is appropriate when you need features from a higher tier or when your application has resource-intensive operations that benefit from more powerful individual instances. Understanding the trade-offs and knowing which approach fits different scenarios is critical for exam success.

## Built-in Authentication

App Service provides built-in authentication, often called Easy Auth, which appears on the exam in scenarios involving securing applications. The platform supports multiple identity providers including Microsoft Identity Platform for Azure AD authentication, Facebook for social login, Google for social login, Twitter for social login, Apple for iOS app authentication, and any OpenID Connect provider for custom identity solutions.

Key exam points include understanding how to enable authentication without writing code. The platform handles all the authentication flow for you, including redirecting users to the identity provider, handling the callback, and establishing the authenticated session. Anonymous request handling options let you control what happens when an unauthenticated user accesses your app - you can either allow the request and let your application handle authentication, or automatically redirect to the identity provider. The token store functionality automatically captures and stores identity provider tokens that your application can use to call other APIs on behalf of the user.

The authentication flow differs between web apps and APIs, and understanding this difference is important. For web apps, the typical flow involves redirecting the user to the identity provider's login page, the user authenticates there, and then redirects back to your app with an authentication token. For APIs, the client typically obtains a token directly from the identity provider and includes it in API requests, and Easy Auth validates the token before allowing access to your API endpoints.

## Networking Features

The exam tests your knowledge of App Service networking capabilities, which enable you to integrate your applications with virtual networks and control both inbound and outbound traffic. Inbound features control how traffic reaches your application. The app-assigned address is the public IP that Azure provides by default. Access restrictions let you limit access based on IP addresses or virtual network subnets, useful for creating applications that are only accessible from specific locations or from within your Azure network. Service endpoints provide secure, direct connectivity from your VNet to Azure services. Private endpoints, available in Premium tier, give your app a private IP address in your VNet, completely removing it from the public internet.

Outbound features control how your application connects to other resources. Hybrid connections allow your app to connect to on-premises resources through a lightweight agent, without requiring VPN or Express Route. VNet integration lets your application make outbound calls to resources in a VNet, essential for accessing private Azure resources like databases or VMs that aren't exposed to the internet. Gateway-required VNet integration provides similar functionality but requires a VNet gateway, offering more control over the connection.

Understanding when to use each networking feature is important for the exam. Scenarios involving security requirements, private connectivity, or hybrid cloud architectures will test your knowledge of these capabilities.

## AZ-204 Exam Study Points

Let's consolidate the key points you need to master for exam success. App Service Plans define the compute resources, region, and features available to your applications. Understanding the tier differences is fundamental - Basic for development with limited features, Standard for production workloads with autoscale and slots, Premium for high-performance requirements, and Isolated for network isolation. You can upgrade but never downgrade, which affects your architectural decisions.

Deployment methods each have specific use cases. Know when to use local Git for quick development, GitHub integration for team development, containers for containerized applications, and Azure Pipelines for comprehensive CI/CD. Understanding the trade-offs in security, automation, and complexity helps you answer scenario questions correctly.

Application settings and connection strings override configuration files and enable environment-specific behavior. Settings can be slot-specific or not, affecting swap behavior. Understanding configuration precedence ensures you know which value your application will actually use.

Deployment slots enable zero-downtime deployments and easy rollback. They require Standard tier or above. Slot-specific settings stay with slots during swaps while other configuration moves with the code. The swap operation warms up the target slot before completing to eliminate cold starts.

Diagnostic logging provides multiple log types for different troubleshooting scenarios. Application logs for application issues, web server logs for HTTP-level problems, failed request tracing for performance issues, and deployment logs for deployment tracking. Know which type to use when.

Scaling includes both vertical scaling by changing tiers and horizontal scaling by adding instances. Autoscaling enables automatic response to load based on metrics or schedules. Understanding when to scale up versus scale out, and how to configure autoscale rules, is essential.

Authentication integrates with multiple identity providers without code changes. Understanding the authentication flow, token management, and configuration options ensures you can secure applications appropriately.

Networking features enable private connectivity, access restrictions, and hybrid scenarios. Know the difference between inbound features like private endpoints and outbound features like VNet integration, and when each is appropriate.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything including all app service plans, web apps, and their configurations. The no-wait flag lets the deletion proceed in the background so you can continue working. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization. Understanding when and how to clean up resources demonstrates mature cloud operations knowledge.
