# Virtual Machine Scale Sets - Linux - AZ-204 Exam Exercises

This lab directly supports several key objectives in the AZ-204 Microsoft Azure Developer Associate certification exam, specifically within the Infrastructure as a Service solutions domain. Virtual Machine Scale Sets represent a critical component for building scalable Azure applications, and understanding how to configure, manage, and update them is essential for exam success.

## Prerequisites

You should be comfortable with basic Azure CLI commands and understand fundamental VM concepts before diving into these exam-focused exercises. Understanding networking fundamentals, particularly load balancers and health probes, will help you work through these scenarios more effectively. These advanced exercises assume you've completed the basic VMSS lab and are ready to explore the features and decisions that appear in AZ-204 exam questions.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across several VMSS-related areas. You'll need to understand how to provision and configure VM Scale Sets programmatically, including creating instances with specific configurations, understanding instance count and capacity management, and performing scaling operations to adjust the number of instances. The relationship between VMSS, load balancers, and public IPs appears frequently in exam scenarios because Azure creates supporting resources automatically but doesn't fully configure them.

Custom data and cloud-init for Linux VM configuration is crucial for the exam. You must understand how to use custom data to pass initialization scripts to VMs, how the cloud-init system works for Linux VM configuration, and how to automate software installation and configuration during provisioning. The exam tests your knowledge of the difference between Windows Custom Script Extensions and Linux cloud-init, and when to use each approach.

Load balancer configuration forms a significant portion of exam questions. You need to know how to create health probes to monitor backend instance health, configure load balancer rules to distribute traffic, understand the relationship between frontend ports, backend ports, and probes, and how load balancers work with VMSS backend pools. These concepts appear in scenario-based questions where you must design or troubleshoot load balancing solutions.

The VMSS model and update process is a frequently tested concept. You must understand the VMSS model as the desired state for instances, the difference between updating the model and updating instances, the latestModelApplied flag for tracking instance state, and the implications of manual versus automatic update policies. Many candidates miss questions about this because they don't understand that model changes don't automatically apply to running instances.

## Virtual Machine Scale Sets Fundamentals

The AZ-204 exam tests your understanding of what VMSS provides and when to use it instead of individual VMs. Virtual Machine Scale Sets let you manage multiple VM instances from a single resource, providing benefits that individual VMs cannot offer. When you need multiple VM instances running the same workload, VMSS simplifies management by letting you configure all instances through a single definition instead of managing each VM separately.

Creating a VMSS automatically creates supporting infrastructure including a load balancer and public IP address. This is important for the exam because many scenarios involve troubleshooting why VMSS instances aren't receiving traffic. The answer often relates to incomplete load balancer configuration. Azure creates the load balancer but doesn't configure the rules, leaving that for you to complete based on your application's requirements.

The instance count parameter determines how many VMs run initially, and you can adjust this later through scaling operations. VMSS supports both Windows and Linux operating systems, and the exam may present scenarios where you need to choose between them based on application requirements. Understanding the configuration differences between Windows and Linux instances helps you answer these questions correctly.

VMSS instances don't have individual public IP addresses by default. Instead, they share a single public IP through the load balancer, which distributes incoming traffic across healthy instances. This architecture is fundamental to how VMSS provides high availability and load distribution. The exam may test whether you understand this shared IP model and how it differs from individual VMs.

## Custom Data and Cloud-Init

The exam frequently tests custom data and cloud-init because they represent best practices for VM configuration automation. Custom data provides a mechanism for passing initialization scripts to VMs during creation, eliminating the need for manual configuration after provisioning. Understanding when and how to use custom data is essential for exam success.

For Linux VMs, cloud-init is the standard approach for initialization. Cloud-init is an industry-standard tool that runs during VM provisioning, processing your initialization script before the VM becomes available. This timing is crucial - cloud-init runs once during initial provisioning, not during subsequent updates or restarts. The exam tests whether you understand this limitation and its implications for update scenarios.

Cloud-init scripts can perform any operation you'd normally do manually, including updating package repositories, installing software, creating files with specific content, configuring services, and creating users. The exam may present scenarios requiring specific initialization tasks, and you need to recognize that cloud-init is the appropriate solution for Linux VMs.

In Azure CLI commands, you reference local files containing cloud-init scripts using the @ symbol followed by the file path. This syntax tells Azure CLI to read the file contents and pass them as the custom-data parameter value. The exam may include code snippets where you need to identify correct or incorrect file reference syntax.

Custom data is processed only at provisioning time, not during updates. This is a critical exam concept that appears in scenarios about updating running instances. If you change the custom data in the VMSS model, existing instances don't automatically reprocess it. New instances created after the change will use the updated custom data, but existing instances continue with their original configuration. Understanding this behavior helps you answer questions about update strategies and instance management.

Custom data is passed as Base64-encoded content in the VM profile. When updating custom data through the Azure CLI, you must manually encode the file contents to Base64 before passing it to the update command. This requirement appears in exam questions about updating VMSS configurations programmatically.

## Load Balancer Configuration

Understanding load balancer configuration is essential for the AZ-204 exam because VMSS deployments almost always involve load balancing. The exam tests your knowledge of how to properly configure load balancers to distribute traffic to VMSS instances.

When Azure creates a VMSS, it automatically creates a load balancer and associates it with a public IP address. The load balancer has a backend pool that automatically includes all VMSS instances. However, Azure doesn't create any load balancer rules by default. Without rules, the load balancer receives traffic but doesn't know how to forward it, so the VMSS instances remain inaccessible despite being healthy and running. This is a common exam scenario where you must identify that missing load balancer rules are the problem.

Health probes are how load balancers monitor backend instance health. Before creating load balancer rules, you must create health probes because rules reference specific probes. Health probes periodically check whether instances can handle traffic, and the load balancer only forwards requests to instances that pass the health check. Health probes use protocols like TCP or HTTP to perform checks. TCP probes simply verify that the port is open, while HTTP probes make actual HTTP requests and check the response status code.

Load balancer rules connect frontend listeners to backend targets through health probes. A rule specifies the frontend port where the load balancer listens for incoming traffic, the backend port where VMSS instances receive the forwarded traffic, the protocol to use, and which health probe determines instance health. The exam tests whether you understand all these components and how they connect.

The order of operations matters when configuring load balancers. You must create health probes before creating load balancer rules that reference them. Attempting to create a rule without the referenced probe existing will fail. The exam may present scenarios where you need to identify the correct sequence of operations.

VMSS instances are automatically added to and removed from the load balancer backend pool as the scale set scales up or down. This automatic management is one of the key benefits of VMSS compared to managing individual VMs. When new instances are created, they automatically join the pool once they pass health checks. When instances are removed, they're automatically removed from the pool. The exam tests your understanding of this automatic behavior and how it affects scaling operations.

## VMSS Model and Updates

The VMSS model concept appears frequently in AZ-204 exam questions because it's often misunderstood. Understanding how the model works and how it relates to instance updates is crucial for exam success.

The VMSS model stores the desired state for instances, including which image to use, what VM size to provision, what extensions to install, and what custom data to provide. When you create a VMSS, the initial model defines these settings for all instances. The model acts as a template that Azure uses when creating new instances.

Updating the VMSS model changes the desired state but doesn't automatically change existing instances. This separation between model and instance state gives you control over when updates roll out, which is crucial for managing service availability during updates. The exam frequently tests whether you understand this separation and its implications.

The latestModelApplied flag in instance information indicates whether an instance matches the current model. When all instances show true for this flag, they're all running the current model's configuration. When instances show false, they're running an older model version, indicating they were created before a model update or haven't been updated since the model changed.

To apply model changes to existing instances, you must explicitly update them using the az vmss update-instances command. This command can target specific instances by ID or all instances using the asterisk wildcard. Running this command brings instance configurations in line with the current model. However, for settings like custom data that only process at provisioning time, updating instances changes their configuration metadata without reprocessing the initialization scripts.

New instances created through scaling operations always use the latest model. This behavior means that scaling up after a model update creates instances with the new configuration while existing instances retain the old configuration. This can result in a mixed-state deployment where some instances differ from others. The exam tests whether you recognize this situation and know how to resolve it.

Reimaging instances differs from updating them. Reimaging recreates instances from scratch using the current model, which reprocesses custom data and fully applies all model settings. The az vmss reimage command performs this operation. Understanding when to update versus reimage instances helps you answer exam questions about update strategies.

Update policies determine how model changes propagate to instances. Manual policy requires explicit action to update instances, giving you complete control over the update process. Rolling policy automatically updates instances in batches, waiting for health checks before proceeding to the next batch. Automatic policy immediately updates all instances when the model changes. The exam tests your understanding of when each policy is appropriate based on application requirements.

## Run Commands and Troubleshooting

The ability to execute commands on VM instances without direct SSH or RDP access is a valuable troubleshooting tool that appears in exam scenarios. Understanding run commands helps you answer questions about VM management and troubleshooting.

The az vm run-command invoke feature executes scripts on VMs through the Azure management plane without requiring direct network connectivity to the VM. This capability is useful when troubleshooting VMs that aren't accessible through normal means or when you need to perform operations without setting up SSH keys or managing credentials.

For Linux VMs, you use the RunShellScript command ID to execute shell commands. This runs commands with root privileges, allowing you to perform any operation you could do through an SSH session. The exam may present scenarios where you need to troubleshoot or verify VM configuration, and run commands provide a solution that works even when networking issues prevent normal access.

Accessing log files through run commands is particularly useful for verifying initialization script execution. Cloud-init writes detailed logs to standard locations, and you can cat these log files through run commands to verify successful execution. The exam may ask how to verify custom data execution, and run commands combined with log file access provide the answer.

Run commands work with both individual VMs and VMSS instances. For VMSS, you can target specific instances or use extensions to run commands across all instances. Understanding how to use run commands at scale helps you answer questions about managing large deployments.

## Exam-Style Scenarios

Understanding how these concepts combine in real scenarios is crucial for exam success. When you see a scenario stating that a VMSS with a public IP isn't receiving web traffic, immediately think about load balancer rules. The most likely cause is missing load balancer rules or health probes. The solution involves creating health probes for the application port and load balancer rules that forward traffic to backend instances.

When the exam presents a scenario about deploying an application that requires specific software installed before it can run, recognize that custom data with cloud-init scripts for Linux or Custom Script Extensions for Windows provide the solution. The script should install all prerequisites during VM provisioning so instances are ready when they join the load balancer pool.

If you see a scenario where VMSS model updates don't appear to affect running instances, remember that model changes don't automatically propagate. The solution depends on the specific setting being changed. For most configuration settings, updating instances with az vmss update-instances applies the changes. For custom data changes, you must reimage instances with az vmss reimage because custom data only processes during initial provisioning.

When the exam asks about ensuring all VMSS instances run identical application versions, think about the model and instance update process. The solution involves updating the model with the new configuration and then either updating or reimaging all existing instances depending on what changed. For custom data changes, reimaging is necessary.

## Integration with Other Azure Services

VMSS doesn't exist in isolation, and the exam tests your knowledge of how VMSS integrates with other Azure services to create complete solutions.

Azure Monitor and Log Analytics provide observability for VMSS deployments. You can collect metrics and logs from all instances, enabling centralized monitoring and alerting. The exam may ask about monitoring solutions for VMSS, and Azure Monitor with custom metrics and Log Analytics for log aggregation provide the answer.

Azure Application Insights can monitor applications running on VMSS instances, providing detailed performance metrics and dependency tracking. Understanding when to use Application Insights versus Azure Monitor helps you answer questions about monitoring strategies.

Azure Load Balancer provides basic load distribution based on network-level health checks, while Azure Application Gateway provides application-level load balancing with features like SSL termination and URL-based routing. The exam tests whether you understand the difference and can select the appropriate load balancer for described requirements.

Azure Automation and Desired State Configuration can manage VMSS instance configuration over time, ensuring instances remain in the desired state even if configuration drift occurs. Understanding these tools helps you answer questions about long-term configuration management.

## Best Practices and Summary

For exam success with VMSS topics, focus on understanding the complete lifecycle of VM Scale Sets from creation through configuration to updates. Remember that Azure creates supporting infrastructure like load balancers but doesn't fully configure them, requiring you to complete the setup. Understand that custom data processes only at provisioning time, affecting update strategies. Know the difference between updating the VMSS model and updating instances, and recognize that model changes don't automatically propagate to existing instances.

Practice creating VMSS with both Windows and Linux images to understand configuration differences. Work with different update policies and understand their implications for application availability during updates. Create load balancer configurations from scratch to understand the relationship between health probes, rules, frontend ports, and backend ports. Practice troubleshooting VMSS issues using run commands and understand when to update versus reimage instances.

The exam emphasizes scenario-based questions that require applying multiple concepts together. Understanding individual concepts is necessary but not sufficient - you must recognize how they combine in real-world scenarios. Focus on the why behind each feature and when to use it, not just the how. This contextual understanding is what separates passing from failing the exam.
