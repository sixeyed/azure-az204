We've covered the power of cloud-init for automated deployment and why it's a flexible approach for VM Scale Sets. Now let's use cloud-init scripts to deploy and configure applications automatically across multiple Linux instances.

Creating a VM with cloud-init helps you understand the automation system before scaling up to multiple instances. You create a single VM from the UbuntuLTS image, passing a cloud-init script as custom data using the at symbol syntax with file path. The script installs Nginx automatically during provisioning. When the VM is created, you run a command to print the output of the cloud-init script from the log file at the standard path, and you see the install log for Nginx. You test the web server with another run command using curl localhost to confirm it's listening.

Using cloud-init for Linux VMSS applies the same approach at scale. You have a more interesting setup script that installs Nginx and writes a custom HTML page, using cloud-init's ability to inject variables into files like putting the VM host name into the web page. You create a VM Scale Set from the Ubuntu image with 3 instances, passing the cloud-init file as custom data. The VMSS is created with a PIP and load balancer, but the load balancer rules aren't configured so traffic doesn't go anywhere yet. You create a health probe for port 80 first, then create a load balancer rule forwarding port 80 and referencing the health probe. When you browse to the PIP, you see the custom HTML page showing the machine's local name, and repeating curl requests show responses from all 3 instances demonstrating load balancing.

Updating VMSS reveals important model and instance behavior. The VMSS model stores the desired state of instances, and you check the latestModelApplied field to see if instances are up to date. You update the VMSS with a change to the desired VM state by changing the custom data to use a different cloud-init script. This changes the model and makes existing VMs out of date, but changes to the model are not automatically applied to existing VMs. You update all instances using az vmss update-instances with wildcard for instance ids. The instances show they're using the latest model, but the HTML page hasn't changed because custom data files are only processed at provisioning time. When you scale up with az vmss scale, the new instances come online using the new model and provision the new content. Making curl requests shows different responses from old and new machines.

The VMSS model is the desired state, but changes don't automatically apply to running instances. You control when updates roll out, which is crucial for managing service availability during deployments.
