We've covered the human interaction pattern where orchestrations pause to wait for external human input with timeouts. Now let's build a two-factor authentication system using SMS that demonstrates how durable functions can wait for external events.

Working through the pre-requisites has you set up a Twilio account and phone number for sending SMS messages. Twilio provides a simple API for programmable communications that integrates nicely with Azure Functions through a dedicated binding. This gives you real SMS capability without building your own telecom infrastructure. Once you have your Twilio credentials, you're ready to examine the code structure with an HTTP trigger to start authentication, an SmsVerify orchestrator that coordinates the process, and an SmsChallenge activity that sends the verification code.

Understanding the HTTP trigger with orchestration shows how the orchestrator uses two key durable functions features. WaitForExternalEvent pauses the orchestration until receiving the verification code from the user via the raiseEvent endpoint. CreateTimer implements a timeout so users can't take forever to respond. The orchestrator races these two tasks using Task.WhenAny where whichever completes first determines the outcome. If the event arrives first, authentication succeeds. If the timer fires first, authentication fails due to timeout.

When you test the function locally, you'll configure local settings with your Twilio credentials including the account SID and auth token to enable SMS sending. Then you'll test the workflow by triggering authentication via HTTP which sends you an SMS with a verification code on your phone. You respond via curl to the raiseEvent endpoint with the code you received. If you respond within the timeout period, verification succeeds. Wait too long, and the timer fires first, causing verification to fail. This demonstrates how orchestrations can wait for unpredictable human input while still enforcing time limits.

After deployment to Azure, you'll test the production workflow using the Function App's public endpoint. The lab challenge asks about replacing polling where the client repeatedly checks status with queue-based notifications where the server pushes completion events to a queue. This teaches you about different patterns for notifying clients of long-running operation completion, helping you design better asynchronous workflows.

The key learning is that external events enable orchestrations to pause indefinitely or until timeout without consuming resources. The orchestration checkpoints its state and goes to sleep, not holding any server resources or HTTP connections. When the event arrives via the raiseEvent endpoint, it wakes up and continues exactly where it left off with all its state intact.

Let's implement human interaction workflows!
