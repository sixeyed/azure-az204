# Azure Durable Functions: Human Interaction Pattern - AZ-204 Exam Focus

## Exam Preparation Narration Script

---

## Introduction to Exam Coverage

Welcome to the AZ-204 exam-focused session on the Human Interaction pattern in Azure Durable Functions. If you're preparing for the Microsoft Azure Developer Associate certification, this pattern is one you need to understand deeply. It combines several exam objectives including durable functions orchestration, event-driven architecture, and state management in serverless applications.

Let's break down exactly what you need to know for the exam and how to recognize when this pattern is the right solution.

---

## Exam Topic: Durable Functions Patterns

For the AZ-204 exam, Microsoft expects you to know the five main durable function patterns. The Human Interaction pattern is one of these five, and it's often tested through scenario-based questions.

*[SHOW ON SCREEN: List of five durable function patterns]*

When you see exam questions about workflows that require approval, verification, or any form of human input before proceeding, that's your signal that the Human Interaction pattern is likely the answer. The key differentiator is that unlike the fan-out fan-in pattern which waits for multiple parallel activities, or the chaining pattern which executes in sequence, the human interaction pattern specifically waits for an external signal that may or may not arrive.

---

## External Events - Core Exam Concept

One of the most important concepts you'll be tested on is external events. In your orchestrator function, you use the WaitForExternalEvent method to pause execution until a specific named event arrives.

*[SHOW ON SCREEN: Code snippet showing WaitForExternalEvent]*

For the exam, understand that external events have names - these are case-sensitive strings that must match exactly when you send the event. The orchestrator can specify a return type for the event payload, allowing strongly-typed event handling.

You might see questions asking how to send events to orchestrations. Remember, it's done through the HTTP management API, specifically the raiseEvent endpoint. The client needs the instance ID and the event name, and posts the event data as JSON in the request body.

---

## Durable Timers - Understanding Timeouts

The second critical exam topic is durable timers. These are created using the CreateTimer method in your orchestrator function.

*[SHOW ON SCREEN: Code snippet showing CreateTimer]*

Key points for the exam: durable timers are different from Thread.Sleep or Task.Delay. Those block a thread, which is expensive in a serverless environment. Durable timers actually stop the function execution and schedule a restart. No compute resources are consumed while waiting.

Timers can be cancelled, which is important when implementing race conditions. In the human interaction pattern, you typically wait for whichever comes first - the external event or the timer. This uses Task.WhenAny to race the two operations.

*[SHOW ON SCREEN: Code showing Task.WhenAny with timer and event]*

If you see exam questions about implementing timeouts in durable functions, or about efficient long-running waits, durable timers are always the answer.

---

## HTTP Management API - Orchestration Control

The AZ-204 exam tests your knowledge of the HTTP management API that durable functions expose. When you start an orchestration, you get back a set of URLs for managing that instance.

*[SHOW ON SCREEN: JSON response showing management URLs]*

You need to know what each URL does:

- statusQueryGetUri - checks the current status of the orchestration
- sendEventPostUri - sends an external event to the orchestration
- terminatePostUri - forcefully terminates a running orchestration
- rewindPostUri - rewinds a failed orchestration to try again
- purgeHistoryDeleteUri - removes the history for a completed orchestration

For exam scenarios involving checking orchestration status or sending events, you'll need to identify which URL to use. The sendEventPostUri is particularly important for the human interaction pattern.

---

## Integration with Bindings - Twilio Example

The exam may test your understanding of how durable functions work with input and output bindings. In our lab, we use the Twilio binding to send SMS messages.

*[SHOW ON SCREEN: Twilio binding attribute in code]*

Key exam points: bindings like Twilio are used in activity functions, not in the orchestrator. The orchestrator should remain deterministic - it shouldn't make external calls directly. Instead, it calls activity functions that use bindings.

For binding configuration, remember that sensitive values like API keys should be stored in application settings, not hard-coded. You'll reference them using percent signs in the binding attribute, like %TwilioAuthToken%.

*[SHOW ON SCREEN: Binding attribute with configuration reference]*

The exam might ask where credentials should be stored - the answer is application settings or Azure Key Vault, never in code or configuration files that get deployed.

---

## Scenario: When to Use Human Interaction Pattern

Let's practice with exam-style scenarios. I'll describe situations, and you should think about whether the human interaction pattern is appropriate.

Scenario one: An expense report workflow that requires manager approval before processing payment. The manager needs to review the report and either approve or reject it.

*[PAUSE]*

Yes, this is perfect for human interaction. The workflow waits for an external event - the manager's decision - with a timeout in case they don't respond promptly.

Scenario two: Processing uploaded images by generating multiple thumbnail sizes in parallel, then combining them into a gallery.

*[PAUSE]*

No, this is fan-out fan-in pattern. Multiple parallel activities with no human interaction required.

Scenario three: A password reset flow that sends a code to the user's email and waits for them to enter it on a webpage.

*[PAUSE]*

Yes, human interaction pattern. Waiting for external input from the user, with a timeout for security.

---

## State Management and Checkpointing

For the AZ-204 exam, understand how durable functions manage state during long waits. This is called checkpointing.

*[SHOW ON SCREEN: Diagram of checkpointing process]*

When an orchestrator calls WaitForExternalEvent or CreateTimer, it checkpoints its state to Azure Storage, then the function execution stops. No compute is running. When the event arrives or the timer fires, the runtime reads the checkpoint and recreates the execution context exactly where it left off.

This is why sensitive data in orchestrator variables is safer than storing it in a database - it's only in memory during execution, and the checkpoints are internal to the functions runtime.

Exam questions might ask about the security benefits of durable functions, or about how state is preserved during waits. Checkpointing is the mechanism behind both.

---

## Error Handling and Compensation

Understanding error handling in the human interaction pattern is exam-relevant. What happens if the external event never arrives? What if the activity function that sends the notification fails?

*[SHOW ON SCREEN: Try-catch block in orchestrator]*

Activity functions can be configured with automatic retry policies. This is specified in the ActivityTrigger attribute options. For exam questions about reliability, remember that automatic retries are available and should be configured for transient failure scenarios.

For the timeout case - when the timer expires before receiving the external event - your orchestrator code should handle this gracefully. Maybe it sends an escalation notification, or logs the timeout and returns a failure result. The exam might test your knowledge of appropriate error handling strategies.

---

## Performance and Scaling Considerations

The exam may include questions about performance and scaling of durable functions. Here's what you need to know for the human interaction pattern.

*[SHOW ON SCREEN: Architecture diagram showing multiple concurrent orchestrations]*

Each orchestration instance is independent. You can have thousands of users going through the two-factor authentication workflow simultaneously. Each gets their own orchestration instance with its own state.

The consumption plan automatically scales based on the number of orchestrations needing processing. During wait periods - when all orchestrations are paused waiting for external events - you're paying almost nothing because no compute is running.

For exam scenarios asking about cost-effective solutions for workflows with human interaction, durable functions on consumption plan is often the right answer. Compare this to keeping VMs or App Service instances running continuously.

---

## Storage Requirements

A topic that sometimes appears in exam questions is the storage dependency of durable functions. All durable functions require an Azure Storage account for maintaining orchestration state and work queues.

*[SHOW ON SCREEN: Storage account in Azure Portal]*

The storage account holds control queues, work item queues, history tables, and the lease blob container. For production workloads, using a standard storage account is sufficient, but premium storage accounts provide better performance for high-throughput scenarios.

Key exam point: when planning a durable functions deployment, you must provision a storage account. It's not optional. The AzureWebJobsStorage connection string is required configuration.

---

## Integration with Other Azure Services

For comprehensive exam preparation, understand how the human interaction pattern integrates with other Azure services you might be tested on.

*[SHOW ON SCREEN: Integration architecture diagram]*

Azure Storage Queues - orchestrators can trigger activity functions that write to queues, allowing other components to react to workflow state changes.

Azure Event Grid - you can publish custom events when orchestrations complete, enabling event-driven architectures.

Azure Service Bus - for more complex messaging scenarios with topics and subscriptions, activity functions can publish messages that other services consume.

Azure Key Vault - for storing sensitive configuration like API keys and tokens used in bindings.

Exam questions might describe an architecture requiring multiple services. Know how durable functions fit into the larger ecosystem.

---

## Monitoring and Application Insights

The AZ-204 exam covers monitoring Azure solutions. For durable functions, Application Insights integration is automatic if configured.

*[SHOW ON SCREEN: Application Insights dashboard with durable function telemetry]*

Each orchestrator and activity function execution is logged. You can track orchestration duration, success rates, and failure patterns. The Application Map shows the relationships between functions.

For exam questions about troubleshooting or monitoring durable functions, remember these capabilities:
- Distributed tracing across orchestrator and activities
- Custom telemetry using ILogger in your function code
- Metrics on orchestration duration and throughput
- Alerting on failures or timeouts

---

## Security Best Practices

Security is a key exam domain. For the human interaction pattern, several security considerations are testable.

*[SHOW ON SCREEN: Security checklist]*

First, the HTTP management API includes security codes in the URLs. These should be kept secure - they provide access to control orchestrations. In production, you'd typically wrap these APIs behind your own authenticated endpoints.

Second, input validation. Any data coming from external events should be validated before use. Don't trust that clients will send well-formed data.

Third, timeout configuration. Always implement timeouts for security. A verification code should expire. An approval request shouldn't wait indefinitely.

Fourth, credential management. Use managed identities where possible. Store secrets in Key Vault. Never hard-code credentials in function code.

---

## Common Exam Mistakes to Avoid

Let's talk about mistakes candidates commonly make on AZ-204 questions related to this pattern.

*[SHOW ON SCREEN: Common mistakes list]*

Mistake one: Confusing external events with HTTP triggers. HTTP triggers start orchestrations. External events control running orchestrations. They're different mechanisms.

Mistake two: Thinking you can call Thread.Sleep or Task.Delay in orchestrators. You cannot. Use durable timers instead. The orchestrator must be deterministic.

Mistake three: Not understanding the difference between activity functions and orchestrators. Activities do the work and can have side effects. Orchestrators coordinate and must be deterministic.

Mistake four: Forgetting that the sendEventPostUri requires the exact event name. The orchestrator's WaitForExternalEvent and the raiseEvent call must use matching names.

---

## Practice Exam Scenario

Let's work through a complete exam-style scenario.

*[SHOW ON SCREEN: Exam scenario text]*

"Your company needs to implement a document approval workflow. When a document is uploaded, it must be reviewed by a compliance officer within 72 hours. If approved, it publishes to the company website. If rejected or not reviewed within 72 hours, it's archived. The solution should minimize cost and be scalable. Which Azure services would you use?"

Think through this systematically.

*[PAUSE]*

The answer uses durable functions with the human interaction pattern. Here's why:

An HTTP or blob trigger starts an orchestration when a document is uploaded. The orchestrator calls an activity to notify the compliance officer - maybe sending an email or adding to a review queue. Then it uses WaitForExternalEvent to wait for the approval decision, racing against a 72-hour durable timer.

If the external event arrives first with an approval, an activity function publishes the document. If it's rejected or the timer expires, a different activity archives it. The orchestration handles all three outcomes.

This minimizes cost because nothing runs during the wait period. It scales automatically because each document gets its own orchestration instance. And it uses the human interaction pattern specifically designed for this scenario.

---

## Key Takeaways for the Exam

Let's summarize the absolutely critical points you must know for the AZ-204 exam regarding the human interaction pattern.

*[SHOW ON SCREEN: Key takeaways list]*

One: External events are sent to running orchestrations using the raiseEvent HTTP endpoint. The event name must match what the orchestrator is waiting for.

Two: Durable timers don't block threads. They checkpoint state and release resources. This makes them cost-effective for long waits.

Three: Use Task.WhenAny to race a timer against an external event, implementing timeouts for human interaction scenarios.

Four: Activity functions handle external integrations and bindings. Orchestrators coordinate but remain deterministic.

Five: All durable functions require Azure Storage for state management. This storage holds orchestration history and work queues.

Six: The human interaction pattern is the right choice when workflows need to wait for external input with timeouts, like approvals or verifications.

---

## Final Exam Preparation Tips

As you continue studying for AZ-204, make sure you can:

*[SHOW ON SCREEN: Study checklist]*

Explain the difference between all five durable function patterns and when to use each.

Write orchestrator code that waits for external events and implements timeouts using durable timers.

Describe how to send external events to running orchestrations via the HTTP management API.

Configure durable function applications including storage accounts, application settings, and bindings.

Troubleshoot durable function issues using Application Insights telemetry.

Design architectures that combine durable functions with other Azure services like Storage Queues, Service Bus, and Key Vault.

The human interaction pattern specifically appears in scenario questions about workflows requiring human decisions, approvals, or verification. When you see those scenarios, think external events and durable timers.

---

## Conclusion

The Human Interaction pattern is one of the most practical and testable concepts in the durable functions domain of the AZ-204 exam. Master external events, durable timers, and the HTTP management API, and you'll be well-prepared for any questions in this area.

Remember to practice building these workflows hands-on. The exam may include questions where you need to identify correct code snippets or appropriate APIs. Hands-on experience makes those questions much easier.

Good luck with your exam preparation!
