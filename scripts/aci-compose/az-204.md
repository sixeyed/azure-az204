# Distributed Apps on Azure Container Instances - AZ-204 Exam Exercises

Distributed applications on Azure Container Instances appear in the AZ-204 exam under the containerized solutions domain. These exercises extend beyond simple single-container deployments to focus on multi-container applications, storage integration, and deployment patterns that appear in production scenarios. The exam tests your understanding of container groups, configuration management, and integration with Azure services like Storage Accounts.

## Prerequisites

You should complete the basic ACI lab and the distributed apps lab before tackling these exam-focused exercises. Understanding container basics, networking, and the Docker CLI integration are essential foundations. These advanced exercises assume you're comfortable with single containers and ready to explore multi-container patterns and storage integration.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate several advanced ACI capabilities. You'll need to master container groups and understand how the YAML specification defines multi-container deployments. The Docker Compose integration with ACI is important because it shows how familiar tools work in Azure. Storage integration with both Blob Storage and Azure Files appears frequently in exam scenarios. Understanding configuration updates and the desired-state deployment model is crucial. Finally, you must recognize the limitations of ACI for production scaling and know when to migrate to Container Apps or AKS.

## Container Groups with ACI YAML

The ACI YAML format is Azure's custom specification for defining container groups, and understanding its structure is essential for the exam. This format looks similar to Docker Compose but has ACI-specific requirements like mandatory CPU and memory specifications. The exam tests your knowledge of these requirements and how they differ from Docker Compose where resource limits are optional.

Container groups in ACI share a network space, which means containers communicate via localhost without any special configuration. This is a critical concept because exam scenarios often describe services that need to communicate, and you must recognize that putting them in the same container group enables localhost communication. The environment variables configure communication URLs using localhost addresses instead of external domains or IP addresses.

Public services in a container group require port specification at two levels. Each container defines which ports it exposes internally, and the IP address level defines which ports are published externally. Understanding this hierarchy helps you answer exam questions about networking and port conflicts. Only one container in a group can publish a given external port, but different containers can use the same internal port because they have separate network namespaces within the shared group network.

Updating container configuration demonstrates the desired-state approach. When you deploy an updated YAML specification, ACI compares the current state with the desired state. Containers whose configuration hasn't changed remain running, while containers with changes get recreated. The exam tests this concept because it's fundamentally different from virtual machine updates where you can modify running instances. Container configuration is immutable, requiring recreation for any changes.

## Docker Compose Integration

The Docker Compose specification provides a simpler way to define multi-container applications when you don't need ACI-specific features. The Docker ACI integration automatically handles details like CPU and memory defaults, networking configuration, and port exposure. This abstraction makes Compose attractive for developers familiar with Docker but new to Azure.

The Docker CLI with ACI contexts lets you use familiar docker compose commands to deploy to Azure. Creating an ACI context links your Docker CLI to an Azure resource group. Switching contexts changes where Docker commands execute, from local Docker Desktop to Azure Container Instances in the cloud. The commands look identical, but they're creating real Azure resources instead of local containers.

An interesting detail for the exam is the sidecar container that Docker ACI integration adds automatically. When you deploy a Compose file with two containers, you see three containers in the Portal. The additional container handles networking and communication between containers in the group. Understanding this implementation detail helps you answer questions about unexpected containers or resource consumption.

The exam might present scenarios where you need to choose between ACI YAML and Docker Compose. ACI YAML gives you access to all ACI features and explicit control over every setting. Docker Compose provides developer familiarity and simpler syntax but abstracts away some Azure-specific capabilities. For production deployments requiring specific resource limits or advanced networking, ACI YAML is more appropriate. For development workflows where teams already use Compose, the integration provides a path to Azure without learning new tools.

## Storage Integration Patterns

Azure Storage integration with ACI appears frequently in exam scenarios because containers are stateless by default and production applications need persistent data. Understanding both Blob Storage and Azure Files integration patterns is essential.

Blob Storage integration uses connection strings in environment variables. The application code uses Azure SDK or REST APIs to read and write blobs. This pattern requires no special ACI configuration beyond passing the connection string. The data persists in Azure Storage completely independent of the container lifecycle. Multiple containers can access the same storage account simultaneously, and the data remains available even when all containers are deleted.

Azure Files integration mounts file shares as volumes in the container filesystem. This is more transparent to applications because they just read and write to what looks like a local directory. Behind the scenes, all operations go to Azure Files. The integration requires storage account credentials in the container group definition, specifying the account name, key, share name, and mount path.

The exam tests several scenarios involving these patterns. A common question describes an application that needs to persist data and asks which approach to use. If the application already uses file I/O and you don't want to modify code, Azure Files mounting is the answer. If the application can use Azure SDK or you need advanced blob features like versioning and lifecycle management, Blob Storage with connection strings is better.

Security questions often involve storage account keys. The exam expects you to recognize that keys should be treated as secrets, stored in Azure Key Vault, and referenced through managed identities rather than hardcoded in YAML files or passed as plain environment variables. This leads to the broader principle that production containers should use managed identities for all Azure service authentication.

## Configuration Management and Updates

Managing configuration for distributed applications involves both environment variables and secrets. Regular environment variables work for non-sensitive settings like feature flags, log levels, and public endpoints. Secure environment variables or secrets are required for connection strings, API keys, and credentials.

The desired-state deployment model is crucial for understanding ACI updates. When you redeploy with an updated specification, ACI intelligently determines what needs to change. The API container with unchanged configuration keeps running. The web container with new environment variables gets recreated. This selective update minimizes downtime and resource churn.

Understanding what triggers container recreation helps you answer exam scenarios. Any change to environment variables, resource limits, volume mounts, or container images requires recreation. Simply restarting a container doesn't pick up configuration changes. This is fundamentally different from application servers or VMs where configuration reloads are possible without complete replacement.

## Limitations and Migration Scenarios

The exam frequently tests your understanding of when ACI is appropriate and when to migrate to other services. ACI lacks built-in horizontal scaling, so you cannot automatically spawn multiple container groups based on load. Load balancing between multiple ACI instances requires additional infrastructure like Azure Load Balancer or Application Gateway. High availability across regions needs manual deployment to multiple regions. Service discovery between container groups requires DNS or configuration management.

These limitations point to when Container Apps or AKS become necessary. If an exam scenario describes needs for autoscaling, built-in load balancing, or complex service meshes, ACI is not the right choice. Container Apps provides these features with managed infrastructure. AKS offers complete Kubernetes capabilities for maximum flexibility at the cost of complexity.

Migration scenarios appear in exam questions. An application starts simple on ACI. Growth brings scaling requirements that ACI cannot meet. The exam asks what service to migrate to and why. Understanding the feature progression from ACI to Container Apps to AKS helps you answer these questions correctly.

## AZ-204 Exam Study Points

Let's consolidate what you need to master for the exam. Container groups are the fundamental unit in ACI for multi-container applications, sharing network, lifecycle, and storage. The ACI YAML format requires explicit resource specifications and supports all ACI features. Docker Compose integration provides familiar tooling but with some abstraction of Azure-specific capabilities.

Storage integration follows two patterns. Blob Storage uses connection strings and Azure SDK in application code. Azure Files mounts shares as volumes transparently to applications. Both patterns persist data beyond container lifecycle but suit different application architectures.

Configuration management uses environment variables for non-sensitive settings and secure variables or Key Vault for secrets. Updates follow a desired-state model where ACI recreates only containers with changed configuration.

The limitations of ACI include no built-in autoscaling, no automatic load balancing, and limited service discovery. These limitations drive migration to Container Apps for managed orchestration or AKS for complete Kubernetes control.

Understanding these concepts at a practical level is what the exam tests. Practice the labs, understand why each pattern exists and when to use it, and you'll be well-prepared for the distributed applications portion of the AZ-204 exam.

## Cleanup

When you're finished with these exercises, deleting the resource group removes all containers, networks, and storage resources. The no-wait flag lets deletion proceed in the background. This cleanup is important both for cost management and because the exam includes questions about proper resource lifecycle and cost optimization practices.
