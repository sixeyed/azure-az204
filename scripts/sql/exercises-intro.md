We've covered the multiple SQL Server options in Azure: serverless databases for intermittent usage, managed SQL databases as fully managed database-as-a-service, SQL Managed Instances for near-complete SQL Server compatibility, and SQL Virtual Machines for complete feature parity. Now let's work with Azure SQL databases hands-on.

We'll start by exploring Azure SQL in the portal where you'll search to create a new Azure SQL resource and see the different types of service available. There's SQL databases, SQL managed instances, and SQL virtual machines. You need to think about which you'd choose for a new app that has occasional SQL usage versus why you might need the Virtual Machine option which gives you complete control. When you select the SQL databases option to create a single database, you'll see that a SQL database belongs to a SQL Server instance, which belongs in a resource group. The portal lets you create dependent resources directly. You'll follow the link to create a new SQL Server and see that you need a server name and location, and the name must be globally unique. You also need to select authentication types, and the default is SQL authentication rather than Windows authentication, which makes more sense in the cloud where you don't have Active Directory domain controllers managing everything.

Next you'll create a SQL Server with the CLI by first creating a resource group, then using the sql server create command. You'll need to find a globally unique name for the server because it gets used as the public DNS name. The required parameters include resource group, location, server name, administrator account name, and administrator password which must meet the password policy. Creating a new SQL Server takes a few minutes, and while it's running you can check the docs to find out that a SQL Server with no databases has no running cost at all. The server is just a logical container.

Once you have a SQL Server, you'll create a SQL database using the sql db create command. You supply the SQL Server name, resource group, and database name. This also takes a couple of minutes, and you can check the portal to see the status. The database uses the same admin credentials as the server, so you don't need to supply them again. The default size follows the pricing tier you select, which can range from basic to business critical.

When the database is created, you'll connect to the database using a SQL client. The portal view for SQL Databases shows connection strings in different formats. You can use Visual Studio, SQL Server Management Studio, the SQL Server Extension for VS Code, or a simple client like Sqlectron. When you try to connect with your SQL Server credentials, you'll see an error because SQL Server has an IP block and you need to explicitly allow access to clients based on the originating IP address. In the portal, you'll open the SQL Server instance and find the firewall settings where you can easily add your own IP address to the rules, then try the connection again.

Once you successfully connect to query the database, you're using the administrator credentials so you can run DDL and DML statements. You'll create tables, insert data, and select results, just like any SQL Server database. You could use an empty database with any application that uses an ORM like Entity Framework or Hibernate, setting the connection string in config and having the database schema automatically created when the app first runs.

For the lab challenge, you'll use the CLI to delete the SQL database and see if you can retrieve data from the deleted database when the server still exists. Then you'll delete the resource group and see what happens to the SQL Server. This explores Azure SQL's backup and recovery capabilities and the cascade behavior of resource deletion. When you're done, you'll clean up by deleting the resource group.
