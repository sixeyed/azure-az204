# App Service Configuration and Administration - AZ-204 Exam Exercises

App Service configuration and management appears in the AZ-204 exam under the Azure Compute solutions domain, which typically accounts for twenty-five to thirty percent of your exam score. These exercises go beyond basic deployment and focus specifically on the operational features and monitoring capabilities you'll encounter in the exam. The AZ-204 exam tests not just your ability to create and deploy web apps, but your understanding of production scenarios like health monitoring, scaling, and automatic recovery from failures.

## Prerequisites

You should complete the basic App Service deployment labs before diving into these configuration-focused exercises. Understanding how to create and deploy web apps is essential. These exercises assume you're comfortable with the fundamentals and ready to explore the operational features that distinguish production deployments from simple development scenarios.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across a wide range of App Service operational capabilities. You'll need to understand how application settings override configuration files and how to manage environment-specific configuration without changing code. Health checks are crucial because they represent Azure's approach to automated monitoring and high availability. Scaling concepts appear frequently in scenarios requiring you to understand both vertical and horizontal scaling approaches. Auto-heal capabilities address production requirements for automatic recovery from failures. Finally, you must understand how these features work together to create resilient, self-healing applications in production environments.

## Application Settings and Configuration

Understanding how application settings work is fundamental to the AZ-204 exam because proper configuration management is essential for production applications. The exam will present scenarios where you need to manage environment-specific settings.

App settings in Azure function as environment variables that override values in your application configuration files. This is a powerful pattern because it means you can deploy identical code to development, staging, and production environments, with only the settings differing. The application never needs to know which environment it's running in - the platform provides the appropriate configuration.

In .NET applications, the double underscore syntax in setting names represents nested configuration hierarchies. When you set a value like "Rng__FailAfter__CallCount", Azure maps this to the nested path Rng:FailAfter:CallCount in your application's configuration. This mirrors the JSON structure of appsettings.json but uses environment variable naming conventions. Other platforms have different conventions, but the principle remains the same - settings are injected at runtime without modifying code.

The configuration precedence is important for exam scenarios. App settings always override values from configuration files. This means your appsettings.json defines the defaults for local development, while Azure-hosted settings provide production values. If a setting exists in both places, the Azure setting wins. This precedence model is deterministic and predictable, which is essential for troubleshooting configuration issues.

Managing settings through the CLI follows a consistent pattern. The az webapp config appsettings set command takes key-value pairs and applies them to your web app. You can set multiple settings in a single command by separating them with spaces, which is efficient for scripting and automation. The output shows all current settings, not just the ones you changed, giving you visibility into the complete configuration state.

The exercises demonstrate this by configuring a failure threshold that doesn't exist in the default configuration. You're overriding application behavior purely through platform settings, demonstrating separation of code from configuration. This pattern appears frequently in exam scenarios about deploying applications across multiple environments.

## Health Checks and Monitoring

Health checks are a critical exam topic because they represent Azure's approach to automated application monitoring and high availability. Understanding how health checks work and when they trigger action is essential.

A health check is a lightweight HTTP endpoint in your application that returns success or failure status. By convention, these endpoints are often named /health, /healthz, or /health/ready. The endpoint should verify that the application is functioning correctly - checking database connections, validating configuration, ensuring critical dependencies are available. A simple 200 response means healthy, while a 500-series response indicates problems.

When you enable health checking in App Service, the platform begins polling your specified endpoint at regular intervals. The polling happens behind the scenes, separate from user traffic. If the endpoint returns failure status consistently, App Service marks the instance as unhealthy and takes action based on your configuration.

The load balancing threshold determines how many consecutive failures occur before an instance is removed from rotation. Setting this to two means that after two consecutive health check failures, the load balancer stops routing traffic to that instance. The instance continues running and health checks continue, but user requests go to healthy instances only. This protects users from failed instances while giving the application time to recover.

Metrics integration is powerful for production monitoring. Health check results appear in Azure Monitor as metrics, which means you can create dashboards showing health trends over time. You can configure alerts that notify operations teams when instances become unhealthy. You can query metrics through APIs for custom monitoring solutions. This integration makes health checks not just a runtime feature but part of your comprehensive monitoring strategy.

The single instance limitation is an important exam detail. When only one instance is running, App Service doesn't automatically replace it even when unhealthy, because replacement would cause downtime. The platform considers an unhealthy instance serving some traffic preferable to no instance at all. This behavior changes with multiple instances, where the platform can safely remove unhealthy instances because others remain available.

## Scaling Concepts and Implementation

Scaling appears throughout the AZ-204 exam because it's fundamental to cloud architecture. Understanding when and how to scale is as important as knowing the mechanics.

The distinction between scaling up and scaling out is critical. Scaling up means changing to a larger SKU with more CPU, memory, or features - this is vertical scaling. You might scale from B1 to B2 for more power, or from Basic to Standard for additional features. Scaling up affects all applications on the plan because the SKU applies to the entire plan. Scaling out means increasing the number of instances running your application - this is horizontal scaling. You keep the same SKU but run more copies in parallel. Scaling out directly improves throughput and availability.

Instance count determines how many copies of your application run simultaneously. With multiple instances, App Service load balances requests across all healthy instances using round-robin distribution. More instances mean more aggregate capacity - if one instance can handle 100 requests per second, three instances can handle roughly 300. More instances also improve availability because the failure of one instance only reduces capacity, it doesn't cause an outage.

SKU capabilities vary significantly across tiers. Free and Shared tiers don't support scaling out at all - you're limited to a single shared instance. Basic tier supports up to three instances but doesn't include autoscaling. Standard tier supports up to ten instances and unlocks autoscaling rules that can adjust instance count automatically based on metrics. Premium tiers support even higher instance counts and include additional features like deployment slots and enhanced security. The exam frequently tests your knowledge of these tier limitations.

The scaling command follows a simple pattern. For scaling out, you use az appservice plan update with the number-of-workers parameter. For scaling up, you use the same command with the sku parameter. You can combine both in a single command if needed. The operation applies to the entire App Service Plan, affecting all web apps hosted on that plan.

The exercises demonstrate scaling from one to two instances, which unlocks high availability features. With two instances, the platform can route traffic away from unhealthy instances while keeping the healthy one in service. This is the minimum configuration for true high availability in App Service. Exam scenarios involving high availability requirements almost always require multiple instances.

## Auto-Heal Capabilities

Auto-heal represents Azure's proactive approach to maintaining application availability. Understanding how to configure auto-heal rules is a key exam skill.

Auto-heal triggers are the conditions that detect problems. Request count triggers fire when an instance handles too many requests, which might indicate a memory leak or resource exhaustion. Slow request triggers detect performance degradation, firing when requests exceed a duration threshold. Status code triggers are most common, firing when the application returns specific HTTP codes like 500 errors. Memory threshold triggers detect excessive memory consumption that might lead to out-of-memory failures. Each trigger type addresses different failure patterns you encounter in production.

Time windows are crucial for preventing false positives. Rather than reacting to a single error, auto-heal requires the triggering condition to persist for a specified duration. A 30-second window means the condition must be true for 30 consecutive seconds before action is taken. This prevents unnecessary restarts from transient errors or momentary spikes. The window should be long enough to filter noise but short enough to respond to real problems.

Actions determine what happens when triggers fire. The recycle action restarts the worker process, which clears memory and reinitializes the application - this resolves most transient issues. The log event action records the trigger without taking corrective action, useful for observability. Custom actions can run executables or scripts, enabling sophisticated recovery workflows. Restart timing can be configured to prevent rapid restart loops that waste resources without fixing underlying problems.

Configuration in the portal happens through the Diagnose and solve problems blade or directly in the Configuration section. The interface guides you through creating rules with appropriate triggers and actions. You can configure multiple rules with different triggers and actions, creating a comprehensive auto-heal strategy. Each rule operates independently, so you might have one rule for 500 errors and another for slow requests.

The exercises challenge you to configure auto-heal for status code triggers. This is the most common production scenario - detecting failed instances through error responses and automatically restarting them. The 30-second window balances responsiveness with stability. Testing your configuration by triggering failures and observing automatic recovery demonstrates the complete workflow.

## High Availability Patterns

Combining these features creates resilient applications that maintain availability despite failures. This represents the exam's expectation that you understand not just individual features but how they work together.

Multiple instances provide the foundation for high availability. With at least two instances, the application can tolerate single instance failures without service disruption. Load balancing ensures traffic distributes evenly across instances during normal operation.

Health checks detect problems and trigger traffic routing changes. When an instance fails its health check, the load balancer immediately stops sending it requests. Traffic shifts to remaining healthy instances automatically, with no manual intervention required. Users experience no interruption because healthy instances continue serving requests.

Auto-heal completes the recovery cycle by restarting failed instances automatically. While health checks remove failed instances from rotation, auto-heal brings them back online. The instance restarts, becomes healthy again, passes health checks, and rejoins the load balancer pool. The entire recovery happens automatically without operator involvement.

The combination provides self-healing infrastructure. Applications can experience failures, have them detected automatically, be removed from service temporarily, recover through restart, and return to service - all without manual intervention. This is cloud-native application architecture at its core.

The exam tests this holistic understanding through scenario questions. You might see a requirement for an application that "maintains availability despite transient failures" or "automatically recovers from errors." Your answer needs to include multiple instances for availability, health checks for detection, and auto-heal for recovery. Understanding each feature in isolation isn't enough - you must know how they combine to meet business requirements.

## Production Considerations

Real-world applications require additional considerations beyond what the exercises demonstrate. The exam expects you to understand production requirements.

Deployment slots allow testing configuration changes in staging before applying them to production. You can configure different app settings per slot, enable features in staging first, and swap to production only after validation. This reduces risk when changing operational features like health checks or auto-heal rules.

Application Insights provides deep observability beyond basic metrics. You can track individual request traces, identify performance bottlenecks, correlate errors across distributed systems, and create custom metrics. For production applications, Application Insights integration is essential.

Connection strings and Key Vault integration secure sensitive configuration. While app settings work for most configuration, connection strings are specifically designed for database credentials and have additional security features. For secrets, Key Vault references replace literal values with references that resolve at runtime, ensuring secrets never appear in configuration at rest.

Autoscaling takes scaling beyond manual instance count changes. You define rules based on metrics - scale out when CPU exceeds 70%, scale in when it drops below 30%. The platform automatically adjusts instance count based on actual load, optimizing both performance and cost. This is a Standard tier feature that appears frequently in exam scenarios.

## AZ-204 Exam Study Points

Consolidating the key points for exam success: Application settings override configuration files using environment variable syntax, with double underscores representing nested paths in .NET. Health checks require an HTTP endpoint returning success or failure status, with the load balancing threshold determining how quickly failed instances are removed. Scaling up changes SKU for more resources, while scaling out increases instance count for more capacity. Multiple instances are required for automatic failover - single instance apps don't get replaced when unhealthy. Auto-heal automatically restarts instances based on configured triggers like status codes, request count, or slow requests. Basic tier supports up to three manual instances, Standard tier unlocks autoscaling up to ten instances, and Premium tier provides the highest capacity. The combination of multiple instances, health checks, and auto-heal creates self-healing applications that maintain availability through failures.

Understanding these concepts at a practical level is what separates passing from failing the exam. Microsoft tests application of knowledge, not memorization. Practice the labs, understand why each feature exists and when to use it, and you'll be well-prepared for App Service questions on the AZ-204 exam.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything - the App Service Plan, the Web Apps, and all configuration. This cleanup is important not just for cost management but also because the exam sometimes includes questions about proper resource lifecycle management and cost optimization. Understanding when and how to clean up resources demonstrates production operational knowledge.
