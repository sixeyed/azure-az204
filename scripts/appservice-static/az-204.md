# App Service for Static Web Apps - AZ-204 Exam Exercises

App Service deployment options appear prominently in the AZ-204 exam under the Azure Compute solutions domain, which typically accounts for twenty-five to thirty percent of your exam score. These exercises explore different approaches to hosting web content in Azure, from specialized Static Web Apps to traditional App Service deployments. The AZ-204 exam tests not just your ability to deploy applications, but your understanding of when to use each hosting option, how they differ in resource models and capabilities, and how to integrate authentication into web applications without code changes.

## Prerequisites

You should complete the basic App Service deployment labs before diving into these exercises. Understanding fundamental deployment concepts is essential. You'll also need a GitHub account for the Static Web Apps portions, as that service deploys exclusively from Git repositories. These exercises assume you're comfortable with Git operations and ready to explore different hosting patterns.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across several web hosting patterns in Azure. You'll need to understand when Static Web Apps is the appropriate choice versus traditional App Service. Creating and configuring Static Web Apps with GitHub integration is a specific exam skill. Deploying different content types to App Service, from pure static HTML to runtime-based applications like Node.js, appears frequently. Understanding App Service Plans and resource sharing across multiple applications is crucial. Authentication configuration through Easy Auth without application code changes is a key security skill. Finally, you must understand the tradeoffs between different hosting options in terms of features, complexity, and cost.

## Static Web Apps Overview

Static Web Apps is a relatively new service that addresses a specific and increasingly common pattern in modern web development. Understanding when this service is appropriate versus traditional App Service is crucial for the exam.

Static Web Apps targets scenarios where your application consists primarily of static assets - HTML, CSS, JavaScript, and images - with minimal or no backend processing. Single Page Applications built with React, Angular, or Vue are perfect candidates. Static marketing sites, documentation portals, and frontend-only applications all fit this pattern. The service assumes your content lives in a Git repository, typically GitHub or Azure Repos, and provides automatic deployment through GitHub Actions or Azure DevOps pipelines.

The resource model for Static Web Apps is simpler than traditional App Service. You create a single Static Web App resource without needing an App Service Plan. This simplification reduces management overhead and typically reduces costs as well. The free tier is generous, making Static Web Apps an excellent choice for personal projects, documentation sites, or low-traffic applications.

Deployment happens through Git integration. When you create a Static Web App, Azure automatically creates a workflow file in your repository. This workflow runs on every push to your designated branch, building and deploying your content automatically. The continuous deployment is built-in from the start, with no additional configuration required. This is fundamentally different from App Service where you choose deployment methods separately.

Static Web Apps includes automatic global distribution through content delivery networks, meaning your content is cached in multiple regions worldwide for fast access. SSL certificates are automatically provisioned and renewed, eliminating certificate management. Custom domain support is included. For applications needing backend APIs, Static Web Apps integrates with Azure Functions, allowing you to combine static frontend with serverless backend in a single resource.

The exam tests your ability to recognize scenarios where Static Web Apps is appropriate. Key indicators include pure static content or SPAs, requirement for Git-based deployment, need for staging environments from pull requests, and desire for simplified resource management. When an exam scenario describes these characteristics, Static Web Apps is likely the correct answer.

## Creating and Configuring Static Web Apps

The mechanics of creating Static Web Apps differ significantly from traditional App Service, and the exam expects you to understand this process including the GitHub integration aspects.

Creating a Static Web App requires specifying the source repository URL. This must be a Git repository that you have write access to, because Azure needs to create workflow files. You specify the branch to deploy from - typically main or master. You also specify the app location within the repository if your static content isn't at the root. Some repositories contain multiple applications, and the app location parameter tells Azure which directory contains your deployable content.

The login-with-github flag triggers interactive authentication, which is the simplest approach for learning and testing. Azure displays a device code, launches your browser, and you confirm the authorization. This grants Azure permission to access your repository and create workflow files. In production scenarios, you might use personal access tokens instead for automation, but the interactive approach demonstrates the integration clearly.

When creation completes, Azure has done several things behind the scenes. It created the Static Web App resource in Azure. It added a workflow YAML file to your repository under the .github/workflows directory. It configured that workflow to trigger on pushes to your specified branch. The workflow includes steps to check out your code, build if necessary, and deploy to your Static Web App. This automation happens during creation, giving you continuous deployment immediately.

The workflow file is important to understand because the exam might present questions about how deployment happens. The workflow uses a specialized Azure Static Web Apps action that handles uploading content, invalidating caches, and routing configuration. Each deployment gets a unique URL for the preview environment, which is useful for testing changes before they reach production. The workflow logs show detailed information about each deployment, useful for troubleshooting.

Subsequent deployments happen automatically when you push to the configured branch. You make changes locally, commit them, push to GitHub, and the workflow runs automatically. Within minutes, your changes are live. This Git-centric workflow is fundamentally different from App Service where you might deploy from local filesystems using ZIP deployment or the webapp up command.

## Traditional App Service for Static Content

While Static Web Apps is optimized for static content, you can also use traditional App Service for the same purpose. Understanding when and why you might choose this approach is important for the exam.

Traditional App Service requires an App Service Plan, even for static content. The plan defines the compute resources - the VM size and quantity. This adds complexity compared to Static Web Apps, but it also provides capabilities that Static Web Apps lacks. You get access to deployment slots for staging and testing. You can configure custom scaling rules. You can integrate with virtual networks for private connectivity. You have granular control over SSL certificates, custom domains, and authentication.

The deployment model for static content in App Service uses the webapp up command with the html flag. This flag tells Azure that you're deploying static content rather than an application requiring a runtime. The command creates the App Service Plan if needed, creates the Web App, packages your current directory into a ZIP file, and deploys it. The entire process happens from your local filesystem without requiring Git operations.

The runtime for static content defaults to Windows with IIS and ASP.NET. This might seem like overkill for simple HTML files, but it provides a robust web server with extensive configuration options. IIS handles caching, compression, rewrite rules, and other advanced features automatically. For Linux-based static hosting, you would use nginx instead, but the principle is the same - a full web server runtime even for static content.

Resource sharing is an important concept for the exam. Multiple App Service instances can share a single App Service Plan. This is cost-effective when you have multiple small applications that don't individually justify dedicated infrastructure. The exercises demonstrate this by deploying both static HTML and a Node.js application to the same plan. Both apps run on the same underlying compute resources but remain isolated from each other. Understanding this resource model helps you design cost-effective architectures.

The exam might present scenarios where traditional App Service is preferable despite the added complexity. Look for requirements like deployment slots for testing, custom scaling requirements, VNet integration for private connectivity, or need to share infrastructure across multiple applications. These scenarios favor traditional App Service over Static Web Apps.

## Mixed Static and Dynamic Content

Many applications don't fit neatly into pure static or pure dynamic categories. Understanding how to deploy and configure applications with both static assets and dynamic endpoints is a practical skill the exam tests.

The Node.js exercise demonstrates a common pattern - serving static HTML, CSS, and JavaScript from a public directory while providing dynamic API endpoints for backend logic. The Express framework makes this easy, serving static files from public folders while routing specific paths to dynamic handlers. This represents real-world applications where most content is static for performance, but certain functionality requires server processing.

Deploying Node.js applications to App Service requires specifying the runtime. The az webapp list-runtimes command shows available options, which differ between Windows and Linux. The runtime specification must match your code requirements - Node.js version, .NET version, Python version, etc. The runtime also must match your App Service Plan's operating system. A Windows plan requires Windows runtimes, a Linux plan requires Linux runtimes. Attempting to deploy a Linux runtime to a Windows plan fails, which is a common exam troubleshooting scenario.

The webapp up command for runtime-based applications differs from static HTML deployment. You specify the runtime explicitly rather than using the html flag. You must ensure the runtime matches the App Service Plan OS. If reusing an existing plan, you specify the plan name to avoid creating a new one. The deployment packages your application code and deploys it to the App Service where it runs continuously.

Application structure matters for runtime deployments. Node.js applications need a package.json defining dependencies and start scripts. App Service uses this information to install dependencies and launch your application. Python applications need requirements.txt files. .NET applications need project files. Understanding these runtime requirements is important for troubleshooting deployment failures in exam scenarios.

The exercises demonstrate multiple applications sharing an App Service Plan efficiently. One app serves static HTML using the default Windows runtime. Another runs Node.js on the same infrastructure. Both apps are isolated - they don't share memory or interfere with each other - but they do share the underlying compute resources. This resource sharing reduces costs while maintaining proper application boundaries.

## Authentication and Authorization

Easy Auth is one of App Service's most powerful features, and understanding it is crucial for the AZ-204 exam. The ability to add authentication to applications without code changes represents platform-as-a-service at its best.

Easy Auth works by intercepting requests at the platform level before they reach your application. When a request arrives, App Service checks if the user is authenticated. If not, it redirects to the configured identity provider for authentication. After successful authentication, App Service injects authentication details into the request headers before forwarding to your application. Your application code can simply read these headers to access user information. No authentication libraries, no OAuth flows, no token management in your code.

Configuring authentication happens entirely in the Azure Portal or through CLI commands. You navigate to the Authentication blade in your App Service and add an identity provider. Azure supports multiple providers - Azure Active Directory, Microsoft Account, Google, Facebook, Twitter, and others. For Azure AD, you can create a new application registration automatically or use an existing one. You configure whether to allow unauthenticated requests, what action to take for unauthenticated users, and which token store options to use.

The authentication flow is transparent to your application. An unauthenticated user requests a protected page. App Service redirects to the identity provider. The user authenticates with their credentials. The identity provider redirects back to App Service with authentication tokens. App Service validates these tokens, creates a session, and forwards the request to your application with authentication headers populated. Your application code simply reads headers like X-MS-CLIENT-PRINCIPAL-NAME for the username or X-MS-CLIENT-PRINCIPAL-ID for the user identifier.

The Node.js exercise demonstrates this perfectly. The application code accesses user information from the request object, expecting Azure AD authentication. Initially, these values are undefined because authentication isn't configured. After configuring an Azure AD identity provider in the portal, the same code suddenly works - it displays user names and email addresses without any code changes. The platform handled the entire authentication flow.

Configuration options provide flexibility for different scenarios. You can require authentication for all requests, useful for internal applications where all access should be authenticated. You can allow anonymous requests, leaving authentication enforcement to your application code, useful for public sites with some protected sections. You can configure token refresh behavior, session timeout, and allowed external redirect URLs. These options let you tailor authentication to your application's requirements.

The exam loves scenarios involving authentication requirements. When you see requirements like "integrate with Azure AD for authentication" or "require users to authenticate before accessing the application," Easy Auth is the answer. The exam might ask you to identify where authentication is configured, what the authentication flow looks like, or how the application accesses user information. Understanding that the platform handles authentication, and the application simply reads injected headers, is key.

## Decision Framework for Hosting Options

The exam frequently tests your ability to choose the appropriate hosting option based on scenario requirements. Understanding the decision criteria is as important as understanding the technical details.

Choose Static Web Apps when the application consists primarily of static files or is a Single Page Application. The Git-based deployment model of Static Web Apps provides continuous deployment automatically, perfect when you want deployments to happen on every push. The simplified resource model without App Service Plans reduces management overhead and typically costs less. Static Web Apps includes global distribution and automatic SSL, eliminating infrastructure concerns. The service integrates with Azure Functions for serverless APIs when needed.

Choose traditional App Service when you need deployment flexibility beyond Git-based workflows. App Service supports ZIP deployment, FTP, local Git, GitHub Actions, Azure DevOps, and other methods, giving you options for various CI/CD patterns. Choose App Service when you need deployment slots for staging and testing, a feature not available in Static Web Apps free tier. Advanced features like VNet integration, hybrid connections, custom scaling rules, and private endpoints require App Service. The ability to share App Service Plans across multiple applications can be cost-effective for multiple small apps.

For runtime-based applications with dynamic content, traditional App Service is typically the choice. While Static Web Apps can integrate with Functions for APIs, full server-side applications with established frameworks like Node.js, .NET, Python, or Java run on App Service. Applications requiring persistent server-side sessions, WebSocket connections, or other runtime features need App Service compute models.

Cost considerations matter in architectural decisions. Static Web Apps has a generous free tier suitable for many small applications. The free tier of App Service is more limited. However, App Service Plans can host multiple applications, potentially making them more cost-effective for multiple sites. Premium features in either service increase costs, so understanding the actual requirements helps optimize spending.

The exam presents scenarios and expects you to recommend appropriate solutions. Look for keywords and requirements. Static content plus Git deployment suggests Static Web Apps. Need for deployment slots or VNet integration suggests App Service. Multiple small applications suggest shared App Service Plans. Requirements for functions-based APIs with static frontend suggest Static Web Apps with Functions integration. Practice mapping requirements to service capabilities.

## CLI Command Patterns

The exam includes questions about CLI commands, so understanding the command patterns and parameters is important.

Creating Static Web Apps follows the pattern az staticwebapp create with resource group, name, source repository URL, branch, and app location parameters. The login-with-github flag enables interactive authentication. The command is relatively straightforward with fewer parameters than App Service creation because there's no plan or runtime to specify.

Creating traditional App Service for static content uses az webapp up with the html flag. You specify resource group, app name, SKU, and optionally an existing plan name. The command creates necessary resources automatically, packages the current directory, and deploys. The simplicity is deceptive - it does a lot behind the scenes.

Deploying runtime-based applications uses az webapp up without the html flag. Instead, you specify the runtime parameter with the appropriate runtime version. You must ensure the runtime matches the plan's operating system. You can list available runtimes with az webapp list-runtimes filtered by OS type. Specifying an existing plan with the plan parameter reuses infrastructure rather than creating new resources.

Configuring authentication through CLI involves multiple commands. You can list available identity providers with az webapp auth list. You can add Azure AD authentication with az webapp auth update. The Portal provides a simpler interface for authentication configuration, but understanding the CLI commands helps with automation and scripting scenarios.

The exam might present commands and ask you to identify errors or missing parameters. Common mistakes include mismatched runtimes and OS types, missing required parameters, incorrect resource names, or attempting operations that aren't supported for the SKU tier. Practice reading commands critically to spot these issues.

## Production Patterns and Best Practices

Real-world deployments involve considerations beyond basic setup, and the exam expects you to understand production-ready patterns.

For Static Web Apps, configure custom domains and SSL certificates for professional applications. The service handles certificate provisioning automatically, but you need to configure DNS records correctly. Configure preview environments to test changes before they reach production. The pull request workflow creates temporary environments automatically for testing. Monitor deployments through GitHub Actions logs to catch and resolve issues quickly.

For traditional App Service, use deployment slots for zero-downtime deployments. Deploy to a staging slot, test thoroughly, then swap to production. This pattern ensures production remains stable while testing changes. Configure slot-specific settings for environment-specific configuration, with production connection strings and keys staying in the production slot. Use auto-scaling rules to handle traffic variability automatically, scaling out during high load and scaling in during quiet periods to optimize costs.

Configure Application Insights for comprehensive monitoring regardless of hosting choice. Application Insights provides request tracking, performance metrics, error logging, and custom telemetry. Integration is straightforward for App Service and can be configured for Static Web Apps through Functions. Production applications need this observability.

Secure sensitive configuration with Key Vault integration. Rather than storing connection strings and secrets in app settings directly, use Key Vault references. App Service resolves these references at runtime, fetching secrets securely. This pattern keeps secrets out of configuration and source control, following security best practices.

Implement proper authentication and authorization patterns. Easy Auth handles authentication, but your application must handle authorization - deciding what authenticated users can do. Don't rely on client-side security alone. Validate permissions server-side for any sensitive operations. Use role-based access control to manage which users can administer your Azure resources.

## AZ-204 Exam Study Points

Consolidating the key points for exam success: Static Web Apps targets static content and SPAs with Git-based continuous deployment and simplified resource model without App Service Plans. Traditional App Service provides more deployment flexibility, supports deployment slots and advanced networking, and allows multiple applications to share one App Service Plan. The webapp up command with html flag deploys static content, while specifying runtime deploys applications requiring server-side processing. Runtime specifications must match the App Service Plan's operating system - Windows runtimes for Windows plans, Linux runtimes for Linux plans. Easy Auth adds authentication through platform configuration without application code changes, with the platform intercepting requests and injecting authentication details into headers. Static Web Apps is appropriate for static sites with Git deployment, App Service for applications needing deployment slots, advanced features, or runtime-based processing. Multiple apps can share an App Service Plan efficiently, reducing costs while maintaining isolation.

Understanding these concepts at a practical level prepares you for the hosting and deployment questions on the AZ-204 exam. Microsoft tests your ability to apply knowledge to scenarios, not just memorize commands. Practice the labs, understand the decision criteria for choosing hosting options, and you'll be well-prepared.

## Cleanup

When you're finished with these exercises, removing the resource group deletes everything - Static Web Apps, App Service Plans, and Web Apps. Remember to also clean up the GitHub workflow file from your fork if you want to prevent accidental deployments. This cleanup demonstrates understanding of resource lifecycle management and cost optimization, concepts that appear in exam questions about operational excellence.
