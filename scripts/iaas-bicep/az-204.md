# IaaS Bicep - AZ-204 Exam Exercises

This lab directly addresses the implement IaaS solutions domain of the AZ-204 exam, with a strong focus on infrastructure as code using Bicep. The exam tests your ability to deploy and manage infrastructure programmatically, and Bicep is Microsoft's recommended approach for this. Understanding how to automate complete application deployments including compute, networking, and configuration is essential for passing the exam.

## Prerequisites

You should complete both the basic IaaS apps lab and the ARM templates lab before these exercises. Understanding VM deployment fundamentals and the concepts behind infrastructure as code are essential building blocks. These exercises demonstrate advanced patterns like modular templates, automated application deployment, and deployment mode management.

## AZ-204 Exam Skills Covered

The exam expects you to demonstrate competency across infrastructure as code and IaaS automation. You'll need to understand how to provision VMs using Bicep and ARM templates, not just manually through the portal or CLI. Modular template design is crucial for managing complex deployments. Understanding deployment modes - incremental versus complete - is fundamental for safely managing infrastructure. VM extensions and custom script extensions enable automated application deployment. Finally, you must understand resource dependencies and how Bicep manages them implicitly versus explicit dependency declaration.

## ARM Templates and Bicep

The AZ-204 exam covers infrastructure as code concepts extensively, with Bicep being Microsoft's strategic direction for Azure deployments. Understanding the relationship between ARM JSON and Bicep is important for the exam.

ARM templates use JSON format which can be verbose and difficult to read, especially for complex deployments with many resources. The template structure includes parameters for input values, variables for computed values, resources for Azure services to deploy, and outputs for values to return after deployment. While comprehensive, JSON templates require careful attention to syntax with commas, brackets, and nesting.

Bicep is a domain-specific language that transpiles to ARM templates behind the scenes. The syntax is cleaner and more concise than JSON, reducing boilerplate significantly. Type safety and IntelliSense support in editors like VS Code catch errors before deployment. Resource references use simple symbolic names rather than complex resource ID functions. Bicep supports modules for organizing large deployments into manageable pieces. Most importantly for the exam, Bicep is functionally equivalent to ARM JSON - they compile to the same underlying template format.

The exam may present scenarios asking you to choose between deployment approaches. Know that Bicep is Microsoft's recommended approach for new projects because of its improved developer experience. ARM JSON is still fully supported and common in existing projects. Both use the same Azure Resource Manager deployment engine underneath, so capabilities are identical. You can decompile ARM JSON to Bicep and build ARM JSON from Bicep, enabling gradual migration.

## Modular Template Design

Understanding how to organize Bicep templates across multiple files is crucial for the exam because real-world deployments rarely fit in a single file. Breaking templates into modules improves maintainability and reusability.

The shared variables pattern uses a JSON file to define resource names used across multiple Bicep files. This centralization means name changes only require editing one file. The loadJsonContent function reads these variables into Bicep templates at compile time. This pattern appears frequently in exam scenarios involving multi-tier applications.

Referencing resources across files uses the existing keyword to declare resources defined in other templates. This tells Bicep that the resource already exists and should not be created, but can be referenced. The symbolic name you assign becomes available for building properties like resource IDs and names. Understanding when to use existing versus defining resources directly is an important exam topic.

Module parameters and outputs enable communication between templates. Parameters pass configuration values into modules, while outputs expose resource properties for use by other modules or the main template. Default parameter values reduce the configuration burden for common scenarios. Parameter decorators like @secure mark sensitive values that shouldn't be logged.

## Deployment Modes

Understanding deployment modes is critical for the AZ-204 exam because choosing the wrong mode can delete resources accidentally. The mode determines how ARM reconciles the template with existing resources.

Incremental mode is the default and the safest option for most scenarios. Resources defined in the template are created or updated to match the template specification. Resources in the resource group but not in the template are left unchanged. This allows you to deploy partial updates without affecting unrelated resources. Multiple templates can safely target the same resource group in incremental mode. The exam favors incremental mode for questions about safely updating existing deployments.

Complete mode treats the template as the complete desired state. Resources defined in the template are created or updated to match the specification. Resources in the resource group but not in the template are deleted to make the deployment match the template exactly. This mode is dangerous unless your template truly represents everything in the resource group. Complete mode is appropriate for ephemeral environments like testing where you want to ensure nothing extra exists.

The what-if operation previews deployment changes without executing them, working with both modes. It shows which resources would be created, modified, or deleted. The exam loves what-if questions because it demonstrates understanding of deployment impact. Always use what-if before complete mode deployments to verify you won't delete important resources accidentally.

## Custom Script Extensions

Custom Script Extensions are essential for the AZ-204 exam because they enable automated application deployment and configuration. Understanding how they work and when to use them distinguishes basic VM creation from production-ready deployment automation.

The extension resource type is Microsoft dot Compute slash virtualMachines slash extensions, attached to a VM resource. It downloads and executes scripts from Azure Storage or public URLs. Execution happens with system-level privileges, allowing full configuration access. The extension runs during VM creation or can be added to existing VMs later. Scripts can be PowerShell on Windows or bash on Linux, matching the VM operating system.

Script parameters can include sensitive values like passwords and connection strings using the @secure decorator in Bicep. The settings object contains public configuration like script URLs, while protected settings contains sensitive parameters. The extension outputs success or failure status, and detailed logs capture stdout and stderr from script execution.

Idempotency is crucial for custom script extensions. Your scripts should be written to run successfully multiple times without errors or duplicate actions. Check if software is already installed before attempting installation. Use conditional logic to skip completed configuration steps. The exam may present scenarios where an extension runs multiple times and ask what happens.

Common use cases for custom script extensions include installing application prerequisites like web servers or runtimes, deploying application code from repositories or storage accounts, configuring application settings and connection strings, starting services and verifying installation, and joining VMs to domains or configuration management systems. The exam frequently tests whether custom script extensions are the appropriate solution for deployment automation scenarios.

## Resource Dependencies

Understanding how Bicep manages resource dependencies is important for the exam because deployment order matters when resources depend on each other.

Implicit dependencies are automatically detected by Bicep when you reference one resource from another. If a network interface references a virtual network by name, Bicep knows the VNet must be created first. If a VM references a network interface, Bicep ensures the NIC exists before creating the VM. This automatic dependency management is a major advantage of Bicep over manual ARM JSON where you often need explicit dependsOn clauses.

Explicit dependencies use the dependsOn property when implicit references don't capture the relationship. This is rare in Bicep but appears when you need ordering without direct references. For example, a custom script extension might need a firewall rule configured even though it doesn't directly reference it. The exam might show you a Bicep template and ask whether dependencies are correctly specified.

Parent-child relationships use the parent property for nested resources like subnets within VNets or database tables within databases. This establishes both the hierarchical relationship and the deployment dependency. The child resource name can omit the parent name prefix when using the parent property, making templates cleaner.

Deployment failures due to dependency issues manifest as resources trying to use others that don't exist yet. Bicep minimizes these errors through implicit dependency detection. When troubleshooting failed deployments, check that all resource references are correct and complete. The exam may present a failed deployment scenario and ask you to identify the dependency problem.

## VM Provisioning with Bicep

The exam tests your knowledge of VM deployment patterns using Bicep, including all the associated resources VMs require.

Required resources for a VM include the VM resource itself specifying hardware and OS configuration. A network interface connects the VM to a subnet. A virtual network provides the network address space. A subnet partitions the virtual network. A public IP address enables internet connectivity if needed. Managed disks store the OS and data. Network security groups control inbound and outbound traffic.

Bicep simplifies resource references compared to ARM JSON. When you reference a NIC from the VM, you just use the NIC's symbolic name. When you reference a subnet from the NIC, you use the VNet and subnet symbolic names. Bicep generates the correct resource ID functions automatically during compilation. This reduction in complexity is why Microsoft recommends Bicep over JSON.

Common VM configuration includes specifying the VM size like Standard_D2s_v5 for general purpose workloads. Image reference uses publisher, offer, SKU, and version components. OS disk configuration defines size, storage type, and delete options. Administrator credentials use parameters with @secure decorator for passwords. Tags provide metadata for organization and cost tracking. Availability sets or zones enable high availability configurations.

## Common Exam Scenarios

The exam presents realistic scenarios where you must apply Bicep knowledge to solve problems. Automated application deployment scenarios require using custom script extensions to install and configure applications without manual intervention. Multi-tier application deployments need modular templates for web tier, application tier, and database tier that reference each other appropriately. Environment-specific deployments use parameters to customize dev, test, and production environments from the same templates. Troubleshooting deployment failures requires understanding dependency order, what-if analysis, and ARM error messages.

Security best practices appear frequently in exam questions. Store secrets in Key Vault and reference them in templates using KeyVault references. Use managed identities for VM authentication to other Azure services. Apply least-privilege permissions using RBAC roles assigned in templates. Tag resources for security auditing and compliance tracking. Enable diagnostic logging for VMs, NICs, and NSGs.

Template maintenance scenarios test your understanding of how to update existing deployments safely. Use incremental mode for updates to avoid deleting unrelated resources. Run what-if before every deployment to preview changes. Version control your Bicep files to track changes over time. Use modules to isolate changes to specific components. Test template changes in non-production environments first.

## Practice Recommendations

To prepare for Bicep-related exam questions, you should practice writing Bicep templates from scratch, not just modifying existing ones. Start with single-resource templates and gradually add complexity. Experiment with both incremental and complete deployment modes to understand their behavior. Create modular templates that reference resources across files. Practice using custom script extensions to automate application deployment. Work with parameters, variables, and outputs to make templates reusable. Use what-if extensively to understand how ARM interprets your templates.

Understanding these concepts at a practical level is what separates passing from failing the exam. Microsoft tests application of knowledge, not memorization. Practice the labs, understand why each feature exists and when to use it, and you'll be well-prepared for the Bicep sections of the AZ-204 exam.
