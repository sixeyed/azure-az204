We've covered automating IaaS deployments using Bicep Infrastructure as Code, combining full control with complete automation. Now let's implement a fully automated IaaS environment that deploys without any manual steps.

Working with core resources introduces you to modular Bicep structure split across multiple files where core.bicep handles VNet, subnet, and NSG, sql.bicep manages SQL Server and database, and vm.bicep creates the Windows VM. Each file focuses on one concern making the code more maintainable and reusable. The files use JSON variables with loadJsonContent to share configuration across modules, demonstrating how to avoid hardcoding values. You'll deploy the core networking resources first using incremental deployment mode, and practice using what-if validation to see what changes would happen before actually making them. Incremental mode which is the default adds or updates resources matching the template while leaving other resources untouched, but complete mode removes resources not in the template which can be dangerous if you forget to include existing infrastructure.

The SQL Server section has you deploying database resources with secure parameters using the @secure decorator for the admin password so it doesn't get logged or displayed. The Bicep file references the VNet and subnet created in the core deployment using the existing keyword which lets one module reference resources created by another module without trying to recreate them. You'll use what-if validation again to see exactly what SQL resources will be created before committing to the deployment, building confidence in your infrastructure changes.

Working with the Windows Application VM is the exciting part where you see custom script extensions in action. Instead of manually connecting via RDP and installing IIS like you did in the previous lab, the custom script extension automatically installs IIS, deploys your application by downloading and running the MSI installer, and configures the connection string, all without human intervention. You define the entire setup process in the Bicep template and it executes during VM provisioning. After deployment you'll use run-command to verify setup logs remotely by reading the log file that the custom script wrote, checking that everything executed successfully.

The lab challenge has you fixing issues with the VM Bicep file including addressing the warning about secure parameters and adding output values so you don't have to manually query to get the application URL. When you redeploy after fixing these issues, you'll discover whether the setup script runs again or if Bicep is smart enough to skip it since nothing changed in the custom script extension definition.

The key learning is that custom script extensions turn IaaS into true infrastructure as code. You get the same automation benefits as PaaS with consistent, repeatable deployments, but maintain full control over the OS configuration and application stack.

Let's automate IaaS deployments!
