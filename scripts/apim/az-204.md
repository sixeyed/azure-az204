# API Management - AZ-204 Exam Preparation Narration Script

## Introduction

Welcome to the AZ-204 exam preparation module for Azure API Management. This lab focuses specifically on the skills and scenarios you'll encounter in the AZ-204 certification exam. API Management is part of the "Connect to and Consume Azure Services" domain, which represents 20 to 25 percent of the exam.

Before we begin, make sure you've completed the basic API Management lab to understand the fundamentals. This session will build on that foundation with exam-specific scenarios and deeper technical content.

## AZ-204 Exam Skills Overview

Let's start by understanding what the exam expects you to know about API Management:

- Creating an Azure API Management instance and understanding the different tiers
- Creating and documenting APIs through various methods
- Configuring authentication and authorization for APIs
- Implementing policies for transformation, caching, and rate limiting
- Working with API versioning and revisions
- Configuring the Developer Portal

These are the core competencies you'll be tested on, so we'll work through exercises for each one.

## Exercise 1: Understanding APIM Service Tiers

First, let's talk about APIM service tiers. This is crucial exam knowledge because you need to know which tier to recommend for different scenarios.

The Consumption tier is serverless and pay-per-call. It auto-scales and has a 99.95% SLA. Use this for unpredictable or bursty workloads where you want to pay only for what you use.

The Developer tier has no SLA and is limited to a single scale unit. Never use this in production - it's strictly for development and testing. But it's perfect for labs because it's cheap.

The Basic tier is your entry-level production option with a 99.95% SLA. It supports up to two units for scaling.

The Standard tier adds support for multi-region caching and VNet integration. It can scale to four units.

The Premium tier is for enterprise scenarios. It offers 99.99% SLA, multi-region deployment, VNet integration, and can scale to many units. Use this when you need high availability, geographical distribution, or network isolation.

For the exam, remember: Developer for dev/test, Consumption for serverless scenarios, Basic/Standard for production, Premium for enterprise and multi-region deployments.

## Creating an APIM Instance

Let's create an APIM instance using the Azure CLI. We'll use the Consumption tier because it provisions much faster - usually within 5 minutes instead of 30-45 minutes:

```bash
az group create -n labs-apim-az204 --tags courselabs=azure -l eastus

az apim create \
  -g labs-apim-az204 \
  -n <your-apim-name> \
  --publisher-email admin@contoso.com \
  --publisher-name "Contoso" \
  --sku-name Consumption \
  -l eastus
```

Notice we must provide a publisher email and publisher name. These are required fields for all APIM instances.

To get the details of your APIM instance:

```bash
az apim show \
  -g labs-apim-az204 \
  -n <your-apim-name> \
  --query '{name:name, gatewayUrl:gatewayUrl, portalUrl:portalUrl}' \
  -o table
```

For the exam, know the four key components of APIM:
- The API Gateway accepts API calls, enforces policies, and routes to backends
- The Azure Portal is the admin interface for configuration
- The Developer Portal is the self-service portal for API consumers
- The Management API allows programmatic configuration

## Exercise 2: Import and Create APIs

The exam will test your knowledge of different ways to add APIs to APIM. There are two main approaches: importing from a specification, or manually creating the API.

### Importing from OpenAPI Specification

When you have an existing API with an OpenAPI spec, you can import it directly:

```bash
az apim api import \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --path weather \
  --api-id weather-api \
  --display-name "Weather API" \
  --specification-format OpenApiJson \
  --specification-url "https://example.com/swagger.json"
```

This automatically creates all the operations, parameters, and documentation based on the spec. It's the fastest way to onboard an existing API.

### Manually Defining an API

When you don't have a spec, or when you want full control, you can manually create the API:

```bash
az apim api create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api \
  --path orders \
  --display-name "Orders API" \
  --service-url "https://mybackend.azurewebsites.net" \
  --protocols https
```

Then add individual operations:

```bash
az apim api operation create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api \
  --url-template "/orders" \
  --method GET \
  --display-name "Get Orders" \
  --operation-id get-orders
```

For operations with parameters, like getting a specific order by ID:

```bash
az apim api operation create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api \
  --url-template "/orders/{id}" \
  --method GET \
  --display-name "Get Order by ID" \
  --operation-id get-order \
  --template-parameters name=id description="Order ID" type=string required=true
```

For the exam, understand both approaches and know when each is appropriate.

## Exercise 3: API Policies - Critical Exam Topic

Policies are one of the most important topics for the exam. You need to understand policy structure, execution order, and common policy types.

### Policy Structure and Execution Order

Every policy has four sections, and they execute in this specific order:

1. Inbound - executes before the request is forwarded to the backend
2. Backend - controls how the backend is invoked
3. Outbound - executes before the response is sent to the client
4. On-error - executes when an error occurs in any section

Here's the basic structure:

```xml
<policies>
    <inbound>
        <base />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
```

The `<base />` tag is crucial - it means "inherit policies from the parent scope." This brings us to policy scope hierarchy.

### Policy Scope Hierarchy

Policies can be applied at four levels, from most specific to least specific:

1. Operation level - applies to a single operation
2. API level - applies to all operations in an API
3. Product level - applies to all APIs in a product
4. Global level - applies to all APIs in the APIM instance

The most specific policy wins. The `<base />` tag lets you inherit from parent scopes, so you can combine policies at different levels.

For the exam, remember: Operation overrides API, API overrides Product, Product overrides Global.

### Rate Limiting Policy

Rate limiting restricts how many calls can be made in a time period:

```xml
<inbound>
    <rate-limit calls="5" renewal-period="60" />
    <base />
</inbound>
```

This allows 5 calls per 60 seconds. When exceeded, the client gets a 429 Too Many Requests response.

For the exam, know that renewal-period is in seconds, and the policy should be in the inbound section.

### IP Filtering Policy

IP filtering allows or denies requests based on IP address:

```xml
<inbound>
    <ip-filter action="allow">
        <address>13.66.201.169</address>
        <address-range from="13.66.140.128" to="13.66.140.143" />
    </ip-filter>
</inbound>
```

You can allow or deny, and you can specify individual addresses or ranges.

### Caching Policies

Caching improves performance and reduces backend load. You need both cache-lookup in inbound and cache-store in outbound:

```xml
<inbound>
    <cache-lookup vary-by-developer="false" vary-by-developer-groups="false">
        <vary-by-query-parameter>category</vary-by-query-parameter>
    </cache-lookup>
</inbound>
<outbound>
    <cache-store duration="3600" />
</outbound>
```

The duration is in seconds. The vary-by parameters control cache key generation - you can vary by query parameters, headers, developer, or developer groups.

For the exam, remember that caching requires TWO policies - lookup in inbound, store in outbound.

### Request and Response Transformation

Transformation policies modify requests and responses:

```xml
<inbound>
    <!-- Add header to request -->
    <set-header name="X-API-Version" exists-action="override">
        <value>v1</value>
    </set-header>

    <!-- Rewrite URL -->
    <rewrite-uri template="/api/v2{remainder}" />

    <!-- Change backend URL -->
    <set-backend-service base-url="https://newbackend.azurewebsites.net" />
</inbound>
<outbound>
    <!-- Remove header from response -->
    <set-header name="X-Powered-By" exists-action="delete" />

    <!-- Transform response content -->
    <find-and-replace from="Microsoft" to="Contoso" />
</outbound>
```

These are incredibly powerful for adapting legacy APIs or hiding backend details from consumers.

### CORS Policy

CORS enables cross-origin requests from web applications:

```xml
<inbound>
    <cors allow-credentials="true">
        <allowed-origins>
            <origin>https://www.contoso.com</origin>
            <origin>https://app.contoso.com</origin>
        </allowed-origins>
        <allowed-methods>
            <method>GET</method>
            <method>POST</method>
        </allowed-methods>
        <allowed-headers>
            <header>*</header>
        </allowed-headers>
    </cors>
</inbound>
```

For the exam, know that CORS is an inbound policy and you need to specify allowed origins, methods, and headers.

## Exercise 4: Authentication and Authorization

The exam tests your understanding of different authentication methods in APIM. Let's cover the main ones.

### Subscription Keys

Subscription keys are APIM's built-in authentication mechanism. They're automatically generated when a user subscribes to a product.

To create a subscription via CLI:

```bash
az apim subscription create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --subscription-id mobile-app \
  --display-name "Mobile App Subscription" \
  --scope "/apis/orders-api"
```

Clients can pass the subscription key in two ways:

As a header:
```bash
curl -H "Ocp-Apim-Subscription-Key: <subscription-key>" \
  https://<apim-name>.azure-api.net/orders
```

Or as a query parameter:
```bash
curl "https://<apim-name>.azure-api.net/orders?subscription-key=<subscription-key>"
```

For the exam, know both methods and know that the header name is "Ocp-Apim-Subscription-Key" with that exact casing.

### JWT Token Validation

For Azure AD or OAuth 2.0 authentication, use the validate-jwt policy:

```xml
<inbound>
    <validate-jwt header-name="Authorization" failed-validation-httpcode="401">
        <openid-config url="https://login.microsoftonline.com/{tenant-id}/v2.0/.well-known/openid-configuration" />
        <required-claims>
            <claim name="aud">
                <value>api://myapi</value>
            </claim>
        </required-claims>
    </validate-jwt>
</inbound>
```

This validates that the JWT token is properly signed, not expired, and contains required claims. The OpenID config URL tells APIM where to get the signing keys.

For the exam, understand that this policy goes in the inbound section and can validate audience, issuer, and custom claims.

### Client Certificate Authentication

For mutual TLS authentication:

```xml
<inbound>
    <choose>
        <when condition="@(context.Request.Certificate == null || !context.Request.Certificate.Verify() || context.Request.Certificate.Thumbprint != "DESIRED-THUMBPRINT")">
            <return-response>
                <set-status code="403" reason="Invalid client certificate" />
            </return-response>
        </when>
    </choose>
</inbound>
```

This checks that a certificate is present, valid, and matches an expected thumbprint.

## Exercise 5: API Versioning

Versioning is critical when you need to make breaking changes to an API. The exam will test your understanding of versioning schemes and how to implement them.

### Versioning Schemes

There are three common versioning schemes:

1. Path-based: `/v1/orders` vs `/v2/orders`
2. Query string-based: `/orders?api-version=1`
3. Header-based: `Api-Version: 1` header

Path-based is most common because it's explicit and easy to understand.

### Implementing Versioning

First, create a version set:

```bash
az apim api versionset create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --version-set-id orders-versions \
  --display-name "Orders API Versions" \
  --versioning-scheme Segment
```

The versioning scheme "Segment" means path-based versioning.

Then create your versioned APIs:

```bash
# Create v1
az apim api create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api-v1 \
  --path orders/v1 \
  --display-name "Orders API v1" \
  --service-url "https://backend-v1.azurewebsites.net" \
  --protocols https \
  --api-version v1 \
  --api-version-set-id orders-versions

# Create v2
az apim api create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api-v2 \
  --path orders/v2 \
  --display-name "Orders API v2" \
  --service-url "https://backend-v2.azurewebsites.net" \
  --protocols https \
  --api-version v2 \
  --api-version-set-id orders-versions
```

Now you have two versions of the same API, each pointing to a different backend. Consumers can choose which version to use based on the URL path.

## Versioning vs Revisions

This is important for the exam: understand the difference between versions and revisions.

Versions are for breaking changes. They create a new URL path and represent incompatible changes to the API contract. Use versions when you're changing the structure of requests or responses in a way that would break existing clients.

Revisions are for non-breaking changes. They let you safely test changes before making them current. Revisions don't change the URL (by default), and you can roll back if needed. Use revisions for bug fixes, performance improvements, or adding new optional features.

## Exercise 6: API Revisions

Revisions let you test changes safely before promoting them to production.

Create a new revision:

```bash
az apim api revision create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api \
  --api-revision 2 \
  --api-revision-description "Added filtering support"
```

The new revision is accessible at a special URL:

```
https://<apim-name>.azure-api.net/orders;rev=2
```

Notice the semicolon followed by the revision number. This lets you test the revision without affecting the current version.

When you're satisfied with the revision, make it current:

```bash
az apim api release create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --api-id orders-api \
  --api-revision 2 \
  --notes "Promoted revision 2 to current"
```

Now revision 2 becomes the default, and the main URL points to it.

## Exercise 7: Products

Products group APIs and apply common policies and access controls.

Create a product:

```bash
az apim product create \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --product-id premium \
  --product-name "Premium Plan" \
  --description "Full API access with higher rate limits" \
  --subscription-required true \
  --approval-required true \
  --state published
```

The subscription-required flag means users must subscribe to access this product. The approval-required flag means an admin must approve subscriptions.

Add an API to the product:

```bash
az apim product api add \
  -g labs-apim-az204 \
  --service-name <your-apim-name> \
  --product-id premium \
  --api-id orders-api
```

You can apply product-level policies that affect all APIs in the product:

```xml
<policies>
    <inbound>
        <rate-limit calls="1000" renewal-period="3600" />
        <quota calls="10000" renewal-period="86400" />
        <base />
    </inbound>
</policies>
```

This applies a rate limit of 1000 calls per hour and a quota of 10,000 calls per day to all APIs in the Premium product.

For the exam, understand that products are how you monetize and control access to your APIs.

## AZ-204 Exam Study Points

Let me summarize the key concepts you absolutely must master for the exam:

### APIM Components
- API Gateway handles requests, enforces policies, and routes to backends
- Management plane is for configuration via Portal or Management API
- Developer Portal provides self-service for API consumers
- Azure Portal is the admin interface

### Policy Execution Order
Remember: Inbound, Backend, Outbound, On-error. This exact order.

### Policy Scope Hierarchy
From most to least specific: Operation, API, Product, Global. Use `<base />` to inherit parent policies.

### Authentication Methods
- Subscription keys - built into APIM, passed via header or query string
- OAuth 2.0 / Azure AD - validate JWT tokens
- Client certificates - mutual TLS authentication
- JWT validation - check issuer, audience, and custom claims

### Versioning vs Revisions
- Versions for breaking changes, create new URL paths
- Revisions for non-breaking changes, test before promoting

### Common Policies
- `rate-limit` and `quota` for throttling
- `cache-lookup` and `cache-store` for caching (remember: TWO policies!)
- `validate-jwt` for authentication
- `set-header` and `rewrite-uri` for transformation
- `cors` for cross-origin support
- `ip-filter` for IP whitelisting or blacklisting

## Common Exam Scenarios

Let's work through some typical exam scenarios:

**Scenario 1:** Limit API calls to 100 per hour per user.

**Solution:** Use a rate-limit policy in the inbound section:
```xml
<rate-limit calls="100" renewal-period="3600" />
```

Remember renewal-period is in seconds, so 3600 seconds equals one hour.

**Scenario 2:** Cache GET requests for 1 hour.

**Solution:** Use cache-lookup in inbound and cache-store in outbound:
```xml
<inbound>
    <cache-lookup />
</inbound>
<outbound>
    <cache-store duration="3600" />
</outbound>
```

Duration is in seconds.

**Scenario 3:** Validate Azure AD JWT tokens.

**Solution:** Use validate-jwt policy with OpenID configuration:
```xml
<inbound>
    <validate-jwt header-name="Authorization" failed-validation-httpcode="401">
        <openid-config url="https://login.microsoftonline.com/{tenant-id}/v2.0/.well-known/openid-configuration" />
    </validate-jwt>
</inbound>
```

**Scenario 4:** Deploy breaking API changes without affecting existing clients.

**Solution:** Create a new version with a different path. Existing clients continue using v1, new clients use v2:
```bash
az apim api create --api-version v2 --path orders/v2 ...
```

**Scenario 5:** Test changes before making them live.

**Solution:** Create a new revision, test it, then promote:
```bash
az apim api revision create --api-revision 2 ...
# Test using ;rev=2 URL
az apim api release create --api-revision 2 ...
```

## Best Practices for the Exam

Here are the best practices you should know:

1. Use products to group APIs and apply common policies - this reduces duplication and makes management easier

2. Enable caching for read-heavy APIs - this improves performance and reduces backend load

3. Implement rate limiting to protect backend services from overload - every production API should have rate limits

4. Use revisions for safe testing before deployment - never push untested changes directly to production

5. Version APIs for breaking changes - maintain backward compatibility for existing clients

6. Validate JWT tokens for secure APIs - subscription keys alone aren't sufficient for high-security scenarios

7. Monitor usage through Application Insights - this gives you visibility into API performance and usage patterns

8. Document APIs in the Developer Portal - good documentation reduces support burden and improves API adoption

## Cleanup

When you're done with the lab:

```bash
az group delete -y -n labs-apim-az204 --no-wait
```

The no-wait flag means it will delete in the background without blocking your terminal.

## Conclusion

You've now covered all the key APIM topics for the AZ-204 exam. You understand:

- The different service tiers and when to use each
- How to create and import APIs
- The policy system including structure, execution order, and scope
- Common policies for caching, rate limiting, transformation, and authentication
- The difference between versioning and revisions
- How products control API access

Make sure you practice these concepts hands-on. The exam will include scenario-based questions where you need to choose the right approach or identify correct policy syntax.

Review the common exam scenarios we covered, practice writing policies, and make sure you understand the execution order and scope hierarchy.

Good luck with your AZ-204 certification!
