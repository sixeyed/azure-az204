We've covered Azure SignalR Service as a managed solution for real-time, two-way communication between web applications and clients, solving the scaling challenges of self-hosted SignalR. Now let's implement real-time broadcasting across multiple server instances.

We'll start by running a local SignalR website which is a basic chat application that uses SignalR to broadcast messages to connected clients. You'll run it locally and open two browser windows to the same site. When you exchange messages, you'll see both browsers update without any client-side refreshing. When a new message gets posted, the server broadcasts it using SignalR, which is Microsoft's customization of WebSockets for .NET. If you stop the server app, you'll see what happens on the browser, and when you restart it the previous messages are lost because the app doesn't have a persistence layer and SignalR doesn't provide that either.

The interesting part comes when you run at scale. You'll run another copy of the website using a different port, but it's a completely separate instance with its own list of connected clients. When you open one browser page to each site and try sending messages, they aren't shared between the two servers. Users see a different set of messages depending on which server they're connected to. This is exactly the problem that makes it hard to scale self-hosted SignalR, and it's the use-case for Azure SignalR Service where you can run as many web hosts as your application needs without having to manage client connections.

Next you'll create SignalR Service in the portal where you'll explore the options including the DNS name, region, and pricing tiers. There's Free tier for dev and test, Standard and Premium with different levels of scale and reliability. SignalR runs on a shared platform like App Services, so there's no VNet integration. You'll create an instance with the CLI using the Free tier, and SignalR Service might need to be registered in your subscription since it's one of the less common services. Once it's created, you'll see in the portal that under Keys you have the connection string to use with an access key, and in Connection strings there's a different format to use with Managed Identities.

You'll run your local app again with two instances, but this time you'll pass in configuration settings that enable SignalR Service and provide the connection string. Now when you open one browser to each server, you can exchange messages because they're both using the same Azure SignalR Service as the central hub. If you stop one server and restart, the messages still aren't preserved because SignalR is for real-time broadcasting, not state management.

Finally you'll deploy SignalR website to Azure using the webapp up command to create an App Service and deploy the application. You'll set the SignalR connection string as an app setting, but this time using a Managed Identity format that just needs the SignalR domain name and not the key. When you browse to the app it won't work initially, and checking the log stream will show that the Managed Identity credential is unavailable because App Service apps are not created with a Managed Identity by default. You'll configure the web app to use a system-generated Managed Identity, but it still won't work because the web app can authenticate to SignalR with the Managed Identity, but the identity isn't authorized to use the service yet. You'll create a role assignment giving the App Service's principal ID the SignalR App Server role with the service scope. The role assignment can take a few minutes to propagate, but then the app will start working.

For the lab challenge, you'll explore the trace tool in SignalR Service to see message flow and understand how the service works under the hood. When you're done, you'll clean up by deleting the resource group.
