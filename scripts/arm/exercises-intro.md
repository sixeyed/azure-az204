We've covered the declarative approach to infrastructure deployment as an alternative to imperative Azure CLI commands. Now let's deploy infrastructure using ARM templates and see how they work in practice.

You'll start by looking at the reference documentation and understanding ARM template JSON structure. The templates use a specific format with parameters for customization, variables for computed values, and resources that define what to create. Once you understand the structure, you'll move into desired-state deployment where you actually deploy a storage account using an ARM template via the Azure CLI. This demonstrates the declarative approach where you describe what you want, like a storage account with specific properties, and Azure figures out how to create it.

The what-if feature becomes really important here because you can preview changes before deployment, seeing exactly what Azure will create, modify, or delete. This is super useful when you're working with production environments. Then comes a key learning moment about configuration drift detection. You'll manually change a deployed resource through the Portal, simulating when someone makes ad-hoc changes outside your infrastructure code. Then you'll run what-if again to see how ARM templates identify the discrepancy between your template's desired state and the actual deployed state. This shows how templates help maintain infrastructure consistency over time.

Next, you'll explore dynamic values in ARM templates by deploying a complex Linux VM template with multiple associated resources including a virtual network, storage account, public IP, network interface, and the VM itself. This demonstrates how ARM templates handle resource dependencies automatically, with all related resources defined in one file and deployed together. You'll encounter an interesting issue with dynamic IP allocation where the template isn't truly repeatable because dynamic means the IP address can change with each deployment.

The lab exercise asks you to solve this idempotency problem by using static IP addresses in your template. This teaches you about making templates truly idempotent, where running them multiple times produces the same result without creating new resources or making unnecessary changes. Finally, you'll look at cleanup procedures to understand how ARM deployment deletion works and how to properly remove resources when you're done. Let's deploy infrastructure as code with ARM templates!
