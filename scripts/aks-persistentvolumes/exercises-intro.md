We've covered Kubernetes storage abstractions for managing persistent data in containerized applications. Now let's see these concepts in action and understand how data survives or doesn't survive container and pod lifecycle events.

We'll start by creating an AKS cluster with the no-wait flag, which means the command returns immediately and the cluster gets created in the background. While that's happening, you'll work with your local Docker Desktop cluster to understand the storage concepts before applying them to AKS.

The first exercises explore volumes and volume mounts using a simple queue worker application that reads config files and writes to files in various locations. You'll deploy a version that mounts a ConfigMap to load application settings. The ConfigMap stores a JSON file, the Pod loads the ConfigMap as a volume, and the container mounts that volume into its filesystem at the app directory. After the app is running, you can execute commands inside the container to see the files it's writing. The app writes a line to cache and database files every 20 seconds, with each line including the Pod name as the hostname.

Next comes an important lesson about container writable storage and its ephemeral nature. When you write data in containers, that storage has the same lifecycle as the container itself. When your Pod gets replaced, you get a new container with a new filesystem, and any data written by the previous container is lost. You'll see this in action by deleting your Pod and letting the Deployment create a replacement. When the new Pod is running and you check the database file, you'll see it only contains writes from the new Pod. The data from the previous Pod was inside the container's filesystem, and that container has been deleted and replaced.

To solve this problem, we'll explore EmptyDirs and PersistentVolumeClaims using a new version of the application. This version mounts the cache directory to an EmptyDir volume and the database directory to a PersistentVolumeClaim volume. EmptyDir is storage with the lifecycle of the Pod, so if the Pod needs to restart the container, the data survives. PersistentVolumeClaim is a request for the cluster to provide storage the Pod can attach to, and you don't specify any particular type of storage, just the amount you need. When you deploy this version and let it run, then delete the Pod and check the files in the replacement, you'll discover that the cache file is new because the EmptyDir volume in the new Pod replaces the old one. But the database file is retained with entries from both the old and new Pods, because it's stored in a PersistentVolume that has a separate lifecycle from any Pods.

The same application model works in AKS without any changes, demonstrating Kubernetes portability. When you connect to your AKS cluster and deploy the same specs, you'll see the same behavior with data persisting between Pod replacements. But where is the data actually stored? That's determined by PVCs and Storage Classes in AKS. Storage Classes are platform-specific: AKS offers Azure storage services while Docker Desktop just uses disk on your machine. But they both have a default Storage Class for PVCs, which is why you can use the exact same application model on both platforms.

The lab exercise explores the difference between storage class options in AKS. The default Storage Class uses Azure Managed Disks, which have good I/O performance but can only be attached to one node at a time. For shared storage scenarios, you can use the azurefile Storage Class, which uses Azure File Share service and can be accessed by many Pods on many nodes. Your challenge is to write a new PVC that specifies the Azure Files Storage Class, amend the Deployment spec to use it, and scale up to three replicas. All the replicas will write to the same shared database file, and you should be able to access that file through the Azure Portal as well.

Finally, the cleanup section shows you how to delete the resource group and change your Kubernetes context back to Docker Desktop. Let's master persistent storage in Kubernetes!
