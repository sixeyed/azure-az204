# Microsoft Graph - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Implement Azure Security (15-20%)

This lab extends the basic Microsoft Graph exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Microsoft Graph lab](README.md) first to understand fundamental Graph API concepts.

## AZ-204 Exam Skills Covered

- Implement authentication with Microsoft Identity platform
- Use Microsoft Authentication Library (MSAL) in .NET and Python
- Acquire and refresh tokens
- Implement delegated and application permissions
- Work with Microsoft Graph SDK
- Handle consent and permissions
- Implement Graph API best practices

## Exercise 1: MSAL Authentication in .NET

**AZ-204 Critical Topic:** Microsoft Authentication Library (MSAL) is the recommended way to acquire tokens for Microsoft Identity platform.

### Setup .NET Project

```bash
# Create console application
dotnet new console -n GraphMsalApp
cd GraphMsalApp

# Add MSAL and Graph SDK packages
dotnet add package Microsoft.Identity.Client
dotnet add package Microsoft.Graph
dotnet add package Azure.Identity
```

### Interactive Authentication (Delegated Permissions)

Create a .NET application that authenticates users interactively:

```csharp
using Microsoft.Identity.Client;
using Microsoft.Graph;
using Azure.Identity;

// Configuration
string clientId = "<your-client-id>";
string tenantId = "<your-tenant-id>";
string[] scopes = new[] { "User.Read", "Mail.Read" };

// Build PublicClientApplication for interactive auth
var app = PublicClientApplicationBuilder
    .Create(clientId)
    .WithTenantId(tenantId)
    .WithRedirectUri("http://localhost")
    .Build();

// Acquire token interactively
AuthenticationResult result = await app
    .AcquireTokenInteractive(scopes)
    .WithPrompt(Prompt.SelectAccount)
    .ExecuteAsync();

Console.WriteLine($"Token acquired: {result.AccessToken.Substring(0, 20)}...");
Console.WriteLine($"Expires on: {result.ExpiresOn}");
Console.WriteLine($"User: {result.Account.Username}");

// Use token with Graph SDK
var graphClient = new GraphServiceClient(
    new DelegateAuthenticationProvider(async (request) =>
    {
        request.Headers.Authorization =
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", result.AccessToken);
    }));

// Get user profile
var user = await graphClient.Me.Request().GetAsync();
Console.WriteLine($"Display Name: {user.DisplayName}");
Console.WriteLine($"Email: {user.Mail}");
```

> **AZ-204 Exam Tip:** `PublicClientApplication` is used for desktop, mobile, and CLI applications where the client cannot securely store secrets. For web apps and services, use `ConfidentialClientApplication`.

### Token Caching

MSAL automatically caches tokens to improve performance:

```csharp
// Enable token cache serialization (for desktop apps)
var app = PublicClientApplicationBuilder
    .Create(clientId)
    .WithTenantId(tenantId)
    .WithRedirectUri("http://localhost")
    .Build();

// Configure token cache
TokenCacheHelper.EnableSerialization(app.UserTokenCache);

// Try to acquire token silently (from cache)
var accounts = await app.GetAccountsAsync();
AuthenticationResult result;

try
{
    result = await app
        .AcquireTokenSilent(scopes, accounts.FirstOrDefault())
        .ExecuteAsync();

    Console.WriteLine("Token acquired from cache");
}
catch (MsalUiRequiredException)
{
    // Token not in cache or expired, need interactive auth
    result = await app
        .AcquireTokenInteractive(scopes)
        .ExecuteAsync();

    Console.WriteLine("Token acquired interactively");
}
```

### Token Cache Helper

```csharp
using System.IO;
using System.Security.Cryptography;
using Microsoft.Identity.Client;

public static class TokenCacheHelper
{
    private static readonly string CacheFilePath =
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        "msalcache.bin");

    public static void EnableSerialization(ITokenCache tokenCache)
    {
        tokenCache.SetBeforeAccess(BeforeAccessNotification);
        tokenCache.SetAfterAccess(AfterAccessNotification);
    }

    private static void BeforeAccessNotification(TokenCacheNotificationArgs args)
    {
        if (File.Exists(CacheFilePath))
        {
            byte[] data = File.ReadAllBytes(CacheFilePath);
            // Decrypt data in production
            args.TokenCache.DeserializeMsalV3(data);
        }
    }

    private static void AfterAccessNotification(TokenCacheNotificationArgs args)
    {
        if (args.HasStateChanged)
        {
            byte[] data = args.TokenCache.SerializeMsalV3();
            // Encrypt data in production
            File.WriteAllBytes(CacheFilePath, data);
        }
    }
}
```

> **AZ-204 Exam Tip:** Token caching is critical for performance. MSAL manages cache automatically but you must implement serialization for desktop apps. Web apps use in-memory cache by default.

## Exercise 2: Client Credentials Flow (Application Permissions)

**AZ-204 Critical Topic:** Client credentials flow is used for daemon/service applications that run without user interaction.

### Configure Application Permissions

1. In Azure Portal, go to your app registration
2. Click **API permissions** > **Add a permission**
3. Select **Microsoft Graph** > **Application permissions**
4. Add permissions: `User.Read.All`, `Mail.Read`
5. Click **Grant admin consent**

### Create Client Secret

```bash
# Create client secret
CLIENT_SECRET=$(az ad app credential reset \
  --id $APP_ID \
  --append \
  --query password -o tsv)

echo "Client Secret: $CLIENT_SECRET"
```

### Client Credentials Authentication

```csharp
using Microsoft.Identity.Client;
using Microsoft.Graph;

string clientId = "<your-client-id>";
string clientSecret = "<your-client-secret>";
string tenantId = "<your-tenant-id>";

// Build ConfidentialClientApplication
var app = ConfidentialClientApplicationBuilder
    .Create(clientId)
    .WithClientSecret(clientSecret)
    .WithTenantId(tenantId)
    .Build();

// Acquire token with client credentials
string[] scopes = new[] { "https://graph.microsoft.com/.default" };
AuthenticationResult result = await app
    .AcquireTokenForClient(scopes)
    .ExecuteAsync();

Console.WriteLine($"Token acquired for app: {result.AccessToken.Substring(0, 20)}...");

// Create Graph client with app token
var graphClient = new GraphServiceClient(
    new DelegateAuthenticationProvider(async (request) =>
    {
        request.Headers.Authorization =
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", result.AccessToken);
    }));

// Access data as application (not on behalf of user)
var users = await graphClient.Users
    .Request()
    .Top(10)
    .GetAsync();

foreach (var user in users)
{
    Console.WriteLine($"{user.DisplayName} ({user.Mail})");
}
```

> **AZ-204 Exam Tip:** When using `.default` scope with client credentials, the token includes all application permissions granted to the app. You cannot request specific scopes in client credentials flow.

### Certificate-Based Authentication

More secure alternative to client secret:

```csharp
using System.Security.Cryptography.X509Certificates;

string clientId = "<your-client-id>";
string tenantId = "<your-tenant-id>";
string certThumbprint = "<certificate-thumbprint>";

// Load certificate from store
X509Certificate2 certificate = GetCertificateFromStore(certThumbprint);

var app = ConfidentialClientApplicationBuilder
    .Create(clientId)
    .WithCertificate(certificate)
    .WithTenantId(tenantId)
    .Build();

AuthenticationResult result = await app
    .AcquireTokenForClient(new[] { "https://graph.microsoft.com/.default" })
    .ExecuteAsync();

// Helper method
private static X509Certificate2 GetCertificateFromStore(string thumbprint)
{
    using var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    store.Open(OpenFlags.ReadOnly);
    var certs = store.Certificates.Find(
        X509FindType.FindByThumbprint,
        thumbprint,
        validOnly: false);

    if (certs.Count == 0)
        throw new Exception("Certificate not found");

    return certs[0];
}
```

> **AZ-204 Exam Tip:** Certificate-based authentication is more secure than client secrets because:
> - Certificates can't be accidentally logged or exposed in code
> - Certificate rotation is easier
> - Azure Key Vault can securely store certificates

## Exercise 3: Using Microsoft Graph SDK

**AZ-204 Topic:** Graph SDK simplifies API calls with strongly-typed objects.

### Initialize Graph Client with DefaultAzureCredential

```csharp
using Azure.Identity;
using Microsoft.Graph;

// DefaultAzureCredential tries multiple authentication methods
var credential = new DefaultAzureCredential();

var graphClient = new GraphServiceClient(credential);

// Get current user
var me = await graphClient.Me.Request().GetAsync();
Console.WriteLine($"Signed in as: {me.DisplayName}");
```

### User Operations

```csharp
// Get specific user
var user = await graphClient.Users["user@contoso.com"]
    .Request()
    .GetAsync();

// Get all users with filtering
var users = await graphClient.Users
    .Request()
    .Filter("startsWith(displayName,'J')")
    .Select("id,displayName,mail")
    .Top(10)
    .GetAsync();

foreach (var u in users)
{
    Console.WriteLine($"{u.DisplayName} - {u.Mail}");
}

// Get user's manager
var manager = await graphClient.Users["user@contoso.com"]
    .Manager
    .Request()
    .GetAsync();

// Get user's direct reports
var reports = await graphClient.Users["user@contoso.com"]
    .DirectReports
    .Request()
    .GetAsync();

// Create new user (requires User.ReadWrite.All)
var newUser = new User
{
    AccountEnabled = true,
    DisplayName = "John Doe",
    MailNickname = "johnd",
    UserPrincipalName = "johnd@contoso.com",
    PasswordProfile = new PasswordProfile
    {
        ForceChangePasswordNextSignIn = true,
        Password = "TempPassword123!"
    }
};

var createdUser = await graphClient.Users
    .Request()
    .AddAsync(newUser);

// Update user
await graphClient.Users[createdUser.Id]
    .Request()
    .UpdateAsync(new User
    {
        JobTitle = "Software Engineer"
    });

// Delete user
await graphClient.Users[createdUser.Id]
    .Request()
    .DeleteAsync();
```

> **AZ-204 Exam Tip:** Graph SDK automatically handles:
> - Pagination (use `GetNextPageRequestAsync()`)
> - Retry logic (with exponential backoff)
> - Request throttling
> - JSON serialization/deserialization

### Group Operations

```csharp
// Get all groups
var groups = await graphClient.Groups
    .Request()
    .GetAsync();

// Get specific group
var group = await graphClient.Groups["group-id"]
    .Request()
    .GetAsync();

// Get group members
var members = await graphClient.Groups["group-id"]
    .Members
    .Request()
    .GetAsync();

// Add user to group
await graphClient.Groups["group-id"]
    .Members
    .References
    .Request()
    .AddAsync(new DirectoryObject
    {
        Id = "user-id"
    });

// Create group (requires Group.ReadWrite.All)
var newGroup = new Group
{
    DisplayName = "Marketing Team",
    MailNickname = "marketing",
    MailEnabled = false,
    SecurityEnabled = true,
    GroupTypes = new List<string>()
};

var createdGroup = await graphClient.Groups
    .Request()
    .AddAsync(newGroup);
```

### Mail Operations

```csharp
// Get messages
var messages = await graphClient.Me
    .Messages
    .Request()
    .Filter("isRead eq false")
    .OrderBy("receivedDateTime DESC")
    .Top(10)
    .GetAsync();

foreach (var message in messages)
{
    Console.WriteLine($"From: {message.From.EmailAddress.Address}");
    Console.WriteLine($"Subject: {message.Subject}");
    Console.WriteLine($"Received: {message.ReceivedDateTime}");
    Console.WriteLine();
}

// Send email
var message = new Message
{
    Subject = "Project Update",
    Body = new ItemBody
    {
        ContentType = BodyType.Html,
        Content = "<h1>Project Status</h1><p>All tasks completed!</p>"
    },
    ToRecipients = new List<Recipient>
    {
        new Recipient
        {
            EmailAddress = new EmailAddress
            {
                Address = "user@contoso.com"
            }
        }
    },
    CcRecipients = new List<Recipient>
    {
        new Recipient
        {
            EmailAddress = new EmailAddress
            {
                Address = "manager@contoso.com"
            }
        }
    }
};

// Send immediately
await graphClient.Me
    .SendMail(message, saveToSentItems: true)
    .Request()
    .PostAsync();

// Or save to drafts
await graphClient.Me
    .Messages
    .Request()
    .AddAsync(message);

// Mark message as read
await graphClient.Me
    .Messages[message.Id]
    .Request()
    .UpdateAsync(new Message
    {
        IsRead = true
    });
```

### Calendar Operations

```csharp
// Get calendar events
var events = await graphClient.Me
    .Events
    .Request()
    .Filter("start/dateTime ge '2025-01-01'")
    .OrderBy("start/dateTime")
    .Top(10)
    .GetAsync();

// Create calendar event
var newEvent = new Event
{
    Subject = "Team Meeting",
    Body = new ItemBody
    {
        ContentType = BodyType.Html,
        Content = "Discuss Q1 goals"
    },
    Start = new DateTimeTimeZone
    {
        DateTime = "2025-11-10T14:00:00",
        TimeZone = "Pacific Standard Time"
    },
    End = new DateTimeTimeZone
    {
        DateTime = "2025-11-10T15:00:00",
        TimeZone = "Pacific Standard Time"
    },
    Location = new Location
    {
        DisplayName = "Conference Room A"
    },
    Attendees = new List<Attendee>
    {
        new Attendee
        {
            EmailAddress = new EmailAddress
            {
                Address = "user@contoso.com",
                Name = "John Doe"
            },
            Type = AttendeeType.Required
        }
    },
    IsOnlineMeeting = true,
    OnlineMeetingProvider = OnlineMeetingProviderType.TeamsForBusiness
};

var createdEvent = await graphClient.Me
    .Events
    .Request()
    .AddAsync(newEvent);

// Get availability
var startTime = new DateTimeTimeZone
{
    DateTime = "2025-11-10T09:00:00",
    TimeZone = "Pacific Standard Time"
};

var endTime = new DateTimeTimeZone
{
    DateTime = "2025-11-10T17:00:00",
    TimeZone = "Pacific Standard Time"
};

var schedules = new List<string> { "user1@contoso.com", "user2@contoso.com" };

// Note: Calendar availability requires special endpoint
```

### File Operations (OneDrive)

```csharp
// Get files in root
var items = await graphClient.Me
    .Drive
    .Root
    .Children
    .Request()
    .GetAsync();

// Upload small file (< 4MB)
using var fileStream = System.IO.File.OpenRead("document.pdf");
var uploadedFile = await graphClient.Me
    .Drive
    .Root
    .ItemWithPath("document.pdf")
    .Content
    .Request()
    .PutAsync<DriveItem>(fileStream);

// Download file
var downloadStream = await graphClient.Me
    .Drive
    .Items[uploadedFile.Id]
    .Content
    .Request()
    .GetAsync();

using var fileStream2 = System.IO.File.Create("downloaded.pdf");
await downloadStream.CopyToAsync(fileStream2);

// Upload large file (> 4MB) - use upload session
var uploadSession = await graphClient.Me
    .Drive
    .Root
    .ItemWithPath("largefile.zip")
    .CreateUploadSession()
    .Request()
    .PostAsync();

// Upload in chunks (see Graph SDK documentation for chunk upload)
```

## Exercise 4: MSAL in Python

**AZ-204 Topic:** Python applications can also use MSAL for authentication.

### Setup Python Project

```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate    # Windows

# Install packages
pip install msal requests
```

### Interactive Authentication (Delegated)

```python
import msal
import requests

# Configuration
client_id = "<your-client-id>"
tenant_id = "<your-tenant-id>"
authority = f"https://login.microsoftonline.com/{tenant_id}"
scopes = ["User.Read", "Mail.Read"]

# Create PublicClientApplication
app = msal.PublicClientApplication(
    client_id,
    authority=authority
)

# Try to get token from cache
accounts = app.get_accounts()
result = None

if accounts:
    # Try silent authentication
    result = app.acquire_token_silent(scopes, account=accounts[0])

if not result:
    # Interactive authentication required
    result = app.acquire_token_interactive(scopes)

if "access_token" in result:
    print(f"Token acquired: {result['access_token'][:20]}...")

    # Call Graph API
    headers = {'Authorization': f"Bearer {result['access_token']}"}
    response = requests.get(
        "https://graph.microsoft.com/v1.0/me",
        headers=headers
    )

    user = response.json()
    print(f"Display Name: {user['displayName']}")
    print(f"Email: {user['mail']}")
else:
    print(f"Error: {result.get('error')}")
    print(f"Description: {result.get('error_description')}")
```

### Device Code Flow (Python)

Perfect for CLI applications and devices without a browser:

```python
import msal
import requests

client_id = "<your-client-id>"
tenant_id = "<your-tenant-id>"
authority = f"https://login.microsoftonline.com/{tenant_id}"
scopes = ["User.Read", "Mail.Read"]

app = msal.PublicClientApplication(client_id, authority=authority)

# Initiate device code flow
flow = app.initiate_device_flow(scopes=scopes)

if "user_code" not in flow:
    raise ValueError(f"Failed to create device flow: {flow.get('error_description')}")

print(flow["message"])
# Output: "To sign in, use a web browser to open the page https://microsoft.com/devicelogin
#          and enter the code ABC123XYZ to authenticate."

# Wait for user to authenticate
result = app.acquire_token_by_device_flow(flow)

if "access_token" in result:
    print("Authentication successful!")

    headers = {'Authorization': f"Bearer {result['access_token']}"}
    response = requests.get(
        "https://graph.microsoft.com/v1.0/me",
        headers=headers
    )
    print(response.json())
else:
    print(f"Error: {result.get('error_description')}")
```

> **AZ-204 Exam Tip:** Device code flow is ideal for:
> - CLI applications
> - SSH sessions
> - IoT devices
> - Environments without a web browser

### Client Credentials Flow (Python)

```python
import msal
import requests

client_id = "<your-client-id>"
client_secret = "<your-client-secret>"
tenant_id = "<your-tenant-id>"
authority = f"https://login.microsoftonline.com/{tenant_id}"
scopes = ["https://graph.microsoft.com/.default"]

# Create ConfidentialClientApplication
app = msal.ConfidentialClientApplication(
    client_id,
    authority=authority,
    client_credential=client_secret
)

# Acquire token for client
result = app.acquire_token_for_client(scopes=scopes)

if "access_token" in result:
    headers = {'Authorization': f"Bearer {result['access_token']}"}

    # Get all users (requires User.Read.All app permission)
    response = requests.get(
        "https://graph.microsoft.com/v1.0/users",
        headers=headers
    )

    users = response.json()
    for user in users['value']:
        print(f"{user['displayName']} - {user['mail']}")
else:
    print(f"Error: {result.get('error_description')}")
```

### Token Caching in Python

```python
import msal
import os

token_cache_file = "token_cache.bin"

# Load cache from file
cache = msal.SerializableTokenCache()
if os.path.exists(token_cache_file):
    with open(token_cache_file, "r") as f:
        cache.deserialize(f.read())

# Create app with cache
app = msal.PublicClientApplication(
    client_id,
    authority=authority,
    token_cache=cache
)

# Try to get cached token
accounts = app.get_accounts()
if accounts:
    result = app.acquire_token_silent(scopes, account=accounts[0])
else:
    result = app.acquire_token_interactive(scopes)

# Save cache if changed
if cache.has_state_changed:
    with open(token_cache_file, "w") as f:
        f.write(cache.serialize())
```

## Exercise 5: Consent Framework

**AZ-204 Critical Topic:** Understanding user and admin consent is essential.

### Consent Types

**User Consent:**
- User grants permissions on their own behalf
- Works for delegated permissions only
- User sees consent prompt on first sign-in
- Applies to low-risk permissions (User.Read, Mail.Read)

**Admin Consent:**
- Admin grants permissions for entire organization
- Required for high-risk delegated permissions
- Required for all application permissions
- Users won't see consent prompts after admin consent

### Request Admin Consent

**Via Portal:**
1. Azure Portal > App registrations > Your app
2. API permissions
3. Click "Grant admin consent for [Organization]"

**Via URL:**
```
https://login.microsoftonline.com/{tenant}/v2.0/adminconsent
  ?client_id={client-id}
  &redirect_uri={redirect-uri}
  &state={state}
```

**Via Azure CLI:**
```bash
# Grant admin consent for specific permission
az ad app permission admin-consent \
  --id $APP_ID
```

### Dynamic Consent in Code

Request additional permissions at runtime:

```csharp
// Initial scopes
string[] initialScopes = new[] { "User.Read" };

var result = await app
    .AcquireTokenInteractive(initialScopes)
    .ExecuteAsync();

// Later, request additional scope
string[] additionalScopes = new[] { "Mail.Read", "Calendars.Read" };

try
{
    result = await app
        .AcquireTokenSilent(additionalScopes, result.Account)
        .ExecuteAsync();
}
catch (MsalUiRequiredException)
{
    // Need user consent for new scopes
    result = await app
        .AcquireTokenInteractive(additionalScopes)
        .WithAccount(result.Account)
        .WithPrompt(Prompt.Consent)  // Force consent prompt
        .ExecuteAsync();
}
```

> **AZ-204 Exam Tip:** Incremental consent allows apps to request permissions only when needed, providing better user experience. However, this doesn't work for application permissions which always require admin consent.

### Consent Scopes in Authorization Request

When building authorization URL manually:

```
https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize
  ?client_id={client-id}
  &response_type=code
  &redirect_uri={redirect-uri}
  &scope=https://graph.microsoft.com/User.Read https://graph.microsoft.com/Mail.Read
  &state={state}
```

## Exercise 6: Batch Requests

**AZ-204 Topic:** Batch multiple Graph requests into a single HTTP call.

### Batch Request Example

```csharp
using Microsoft.Graph;

var batchRequestContent = new BatchRequestContent();

// Add multiple requests to batch
var userRequest = graphClient.Me.Request();
var messagesRequest = graphClient.Me.Messages.Request().Top(5);
var eventsRequest = graphClient.Me.Events.Request().Top(5);

var userRequestId = batchRequestContent.AddBatchRequestStep(userRequest);
var messagesRequestId = batchRequestContent.AddBatchRequestStep(messagesRequest);
var eventsRequestId = batchRequestContent.AddBatchRequestStep(eventsRequest);

// Send batch request
var returnedResponse = await graphClient.Batch.Request().PostAsync(batchRequestContent);

// Get individual responses
var userResponse = await returnedResponse
    .GetResponseByIdAsync<User>(userRequestId);
Console.WriteLine($"User: {userResponse.DisplayName}");

var messagesResponse = await returnedResponse
    .GetResponseByIdAsync<UserMessagesCollectionResponse>(messagesRequestId);
Console.WriteLine($"Messages count: {messagesResponse.Value.Count}");

var eventsResponse = await returnedResponse
    .GetResponseByIdAsync<UserEventsCollectionResponse>(eventsRequestId);
Console.WriteLine($"Events count: {eventsResponse.Value.Count}");
```

### Batch Request with Dependencies

```csharp
// Create batch with dependencies
var batchRequestContent = new BatchRequestContent();

// Step 1: Get user
var userRequest = graphClient.Users["user@contoso.com"].Request();
var userStepId = batchRequestContent.AddBatchRequestStep(userRequest);

// Step 2: Get user's manager (depends on step 1)
var managerRequest = graphClient.Users["user@contoso.com"].Manager.Request();
var managerStepId = batchRequestContent.AddBatchRequestStep(managerRequest);
batchRequestContent.AddBatchRequestStepDependency(managerStepId, userStepId);

var returnedResponse = await graphClient.Batch.Request().PostAsync(batchRequestContent);
```

> **AZ-204 Exam Tip:** Batch requests can include up to 20 individual requests and significantly improve performance by reducing round trips. However, all requests must be GET operations or you must use JSON batching format.

## Exercise 7: Change Notifications (Webhooks)

**AZ-204 Advanced Topic:** Subscribe to changes in Graph resources.

### Create Subscription

```csharp
var subscription = new Subscription
{
    ChangeType = "created,updated",
    NotificationUrl = "https://yourdomain.com/api/notifications",
    Resource = "me/messages",
    ExpirationDateTime = DateTimeOffset.UtcNow.AddHours(1),
    ClientState = "SecretClientState"
};

var createdSubscription = await graphClient.Subscriptions
    .Request()
    .AddAsync(subscription);

Console.WriteLine($"Subscription ID: {createdSubscription.Id}");
Console.WriteLine($"Expires: {createdSubscription.ExpirationDateTime}");
```

### Webhook Endpoint Requirements

Your notification endpoint must:
1. Return 200 OK within 3 seconds
2. Validate the subscription (respond to validation token)
3. Process notifications asynchronously

```csharp
[HttpPost]
public async Task<IActionResult> HandleNotification()
{
    // Handle validation request
    if (Request.Query.ContainsKey("validationToken"))
    {
        var token = Request.Query["validationToken"];
        return Content(token, "text/plain");
    }

    // Read notification
    using var reader = new StreamReader(Request.Body);
    var content = await reader.ReadToEndAsync();
    var notifications = JsonSerializer.Deserialize<ChangeNotificationCollection>(content);

    // Validate client state
    foreach (var notification in notifications.Value)
    {
        if (notification.ClientState != "SecretClientState")
            return Unauthorized();

        // Process notification asynchronously
        _ = ProcessNotificationAsync(notification);
    }

    return Ok();
}
```

> **AZ-204 Exam Tip:** Webhooks require:
> - Publicly accessible HTTPS endpoint
> - Quick response time (< 3 seconds)
> - Validation token handling
> - Subscription renewal before expiration

## Exercise 8: Error Handling and Retry Logic

**AZ-204 Best Practice:** Implement proper error handling for production applications.

### Handle Graph API Errors

```csharp
using Microsoft.Graph;

try
{
    var user = await graphClient.Users["nonexistent@contoso.com"]
        .Request()
        .GetAsync();
}
catch (ServiceException ex)
{
    Console.WriteLine($"Error Code: {ex.Error.Code}");
    Console.WriteLine($"Message: {ex.Error.Message}");
    Console.WriteLine($"Status Code: {ex.StatusCode}");

    switch (ex.Error.Code)
    {
        case "Request_ResourceNotFound":
            Console.WriteLine("User not found");
            break;
        case "InvalidAuthenticationToken":
            Console.WriteLine("Token expired or invalid");
            // Re-acquire token
            break;
        case "Authorization_RequestDenied":
            Console.WriteLine("Insufficient permissions");
            break;
        case "TooManyRequests":
            Console.WriteLine("Rate limit exceeded");
            // Implement retry with backoff
            var retryAfter = ex.ResponseHeaders.RetryAfter;
            break;
        default:
            Console.WriteLine("Unknown error");
            break;
    }
}
```

### Implement Retry Logic with Polly

```bash
dotnet add package Polly
```

```csharp
using Polly;
using Polly.Retry;

// Define retry policy
var retryPolicy = Policy
    .Handle<ServiceException>(ex =>
        ex.StatusCode == System.Net.HttpStatusCode.TooManyRequests ||
        ex.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable)
    .WaitAndRetryAsync(
        retryCount: 3,
        sleepDurationProvider: (retryAttempt, ex, context) =>
        {
            // Use Retry-After header if available
            if (ex is ServiceException serviceEx &&
                serviceEx.ResponseHeaders?.RetryAfter != null)
            {
                return serviceEx.ResponseHeaders.RetryAfter.Delta ??
                       TimeSpan.FromSeconds(Math.Pow(2, retryAttempt));
            }

            // Otherwise use exponential backoff
            return TimeSpan.FromSeconds(Math.Pow(2, retryAttempt));
        },
        onRetryAsync: (ex, timespan, retryCount, context) =>
        {
            Console.WriteLine($"Retry {retryCount} after {timespan.TotalSeconds}s");
            return Task.CompletedTask;
        });

// Use retry policy
var users = await retryPolicy.ExecuteAsync(async () =>
    await graphClient.Users.Request().GetAsync());
```

> **AZ-204 Exam Tip:** Always implement retry logic for transient errors (429, 503, 504). Respect the Retry-After header to avoid further throttling.

## Exercise 9: Pagination

**AZ-204 Topic:** Handle large result sets with pagination.

### Automatic Pagination

```csharp
var messages = await graphClient.Me
    .Messages
    .Request()
    .Top(10)
    .GetAsync();

// Process first page
foreach (var message in messages)
{
    Console.WriteLine(message.Subject);
}

// Get additional pages
while (messages.NextPageRequest != null)
{
    messages = await messages.NextPageRequest.GetAsync();

    foreach (var message in messages)
    {
        Console.WriteLine(message.Subject);
    }
}
```

### Manual Pagination

```csharp
var request = graphClient.Users
    .Request()
    .Top(50);

do
{
    var users = await request.GetAsync();

    foreach (var user in users)
    {
        Console.WriteLine(user.DisplayName);
    }

    request = users.NextPageRequest;
} while (request != null);
```

### Page Iterator (Simplified)

```csharp
var messages = await graphClient.Me.Messages
    .Request()
    .GetAsync();

var pageIterator = PageIterator<Message>
    .CreatePageIterator(
        graphClient,
        messages,
        (message) =>
        {
            Console.WriteLine(message.Subject);
            return true; // Continue iteration
        });

await pageIterator.IterateAsync();
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **MSAL Components:**
   - **PublicClientApplication**: Desktop, mobile, CLI apps (no secret)
   - **ConfidentialClientApplication**: Web apps, services (with secret/cert)
   - **Token Cache**: Automatic caching, manual serialization for desktop apps
   - **DefaultAzureCredential**: Tries multiple auth methods automatically

2. **Authentication Flows:**
   | Flow | Use Case | User Interaction | Permission Type |
   |------|----------|------------------|-----------------|
   | Authorization Code | Web apps | Yes | Delegated |
   | Client Credentials | Daemon/service | No | Application |
   | Device Code | CLI/IoT | Yes (on another device) | Delegated |
   | Interactive | Desktop/mobile | Yes | Delegated |

3. **Permission Types:**
   - **Delegated**: App acts on behalf of signed-in user
     - User must have the permission
     - Scopes: `User.Read`, `Mail.Read`, etc.
   - **Application**: App acts as itself (no user)
     - Requires admin consent
     - Scope: `.default` (includes all granted permissions)

4. **Token Lifecycle:**
   - Access tokens expire (typically 1 hour)
   - Refresh tokens extend authentication
   - MSAL automatically refreshes tokens
   - Use `AcquireTokenSilent` for cached/refreshed tokens

5. **Consent Types:**
   - **User consent**: User grants for themselves
   - **Admin consent**: Admin grants for organization
   - **Static consent**: All permissions requested upfront
   - **Dynamic consent**: Request permissions when needed

### Common Exam Scenarios

1. **Scenario:** Desktop app needs to access user's email
   - **Solution:** Use `PublicClientApplication` with interactive flow, request `Mail.Read` delegated permission

2. **Scenario:** Background service reads all users' profiles nightly
   - **Solution:** Use `ConfidentialClientApplication` with client credentials flow, request `User.Read.All` application permission, grant admin consent

3. **Scenario:** Web app needs to access user's OneDrive
   - **Solution:** Use authorization code flow with PKCE, request `Files.Read` delegated permission

4. **Scenario:** CLI tool needs to authenticate user
   - **Solution:** Use device code flow with `PublicClientApplication`

5. **Scenario:** Minimize token acquisition requests
   - **Solution:** Implement token caching, use `AcquireTokenSilent` first, fall back to interactive

6. **Scenario:** App needs additional permissions after initial sign-in
   - **Solution:** Use dynamic consent by requesting additional scopes with `AcquireTokenInteractive` and `WithPrompt(Prompt.Consent)`

### Permission Comparison Table

| Permission | Delegated | Application | Admin Consent Required |
|------------|-----------|-------------|----------------------|
| User.Read | User's profile | N/A | No |
| User.ReadBasic.All | All users' basic profiles | All users' basic profiles | Delegated: No, App: Yes |
| User.Read.All | All users' full profiles | All users' full profiles | Yes |
| Mail.Read | User's mail | All mailboxes | App: Yes |
| Mail.ReadWrite | User's mail | All mailboxes | App: Yes |
| Files.Read | User's files | All files | App: Yes |
| Calendars.Read | User's calendar | All calendars | App: Yes |
| Group.Read.All | All groups | All groups | Yes |

### Graph SDK vs REST API

| Aspect | Graph SDK | REST API |
|--------|-----------|----------|
| Type safety | Strongly-typed objects | JSON strings |
| Serialization | Automatic | Manual |
| Pagination | Built-in helpers | Manual implementation |
| Retry logic | Built-in | Manual implementation |
| Learning curve | Moderate | Lower |
| Flexibility | Limited to SDK version | Full API access |
| Best for | Production apps | Quick prototypes |

### DefaultAzureCredential Order

`DefaultAzureCredential` tries authentication in this order:

1. **EnvironmentCredential**: Environment variables
   - `AZURE_TENANT_ID`
   - `AZURE_CLIENT_ID`
   - `AZURE_CLIENT_SECRET`

2. **ManagedIdentityCredential**: Azure managed identity
   - System-assigned or user-assigned

3. **VisualStudioCredential**: Visual Studio authentication
   - Uses VS signed-in account

4. **AzureCliCredential**: Azure CLI authentication
   - Uses `az login` credentials

5. **AzurePowerShellCredential**: Azure PowerShell
   - Uses `Connect-AzAccount` credentials

6. **InteractiveBrowserCredential**: Browser login
   - Opens browser for sign-in

> **AZ-204 Exam Tip:** `DefaultAzureCredential` is recommended for production because it works across different environments (local dev, Azure services) without code changes.

## Best Practices

1. **Authentication:**
   - Use `DefaultAzureCredential` for flexible authentication
   - Implement token caching for performance
   - Use certificate-based auth over client secrets in production
   - Never hardcode credentials in source code

2. **Permissions:**
   - Request minimum required permissions (least privilege)
   - Use delegated permissions when user context is needed
   - Use application permissions for background services only
   - Implement proper admin consent workflow

3. **API Calls:**
   - Use batch requests to combine multiple operations
   - Implement pagination for large result sets
   - Use `$select` to request only needed properties
   - Cache frequently accessed data

4. **Error Handling:**
   - Implement retry logic with exponential backoff
   - Respect `Retry-After` headers
   - Handle token expiration gracefully
   - Log errors with correlation IDs

5. **Performance:**
   - Cache tokens (don't request for every API call)
   - Use batch requests when possible
   - Implement delta queries for change tracking
   - Use webhooks instead of polling

6. **Security:**
   - Validate webhook notifications
   - Use HTTPS for all communications
   - Store secrets in Azure Key Vault
   - Rotate client secrets regularly
   - Enable certificate-based authentication

## Cleanup

```bash
# Delete app registration
az ad app delete --id $APP_ID

# Delete resource group
az group delete -y -n labs-graph --no-wait
```

## Additional Resources

- [Microsoft Graph documentation](https://docs.microsoft.com/en-us/graph/)
- [MSAL for .NET](https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview)
- [MSAL for Python](https://github.com/AzureAD/microsoft-authentication-library-for-python)
- [Graph SDK for .NET](https://docs.microsoft.com/en-us/graph/sdks/sdks-overview)
- [Microsoft Identity platform](https://docs.microsoft.com/en-us/azure/active-directory/develop/)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
- [Graph permissions reference](https://docs.microsoft.com/en-us/graph/permissions-reference)
- [Best practices for Microsoft Graph](https://docs.microsoft.com/en-us/graph/best-practices-concept)
