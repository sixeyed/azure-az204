# Azure App Service Configuration - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Implement Azure App Service Web Apps (15-20%)

This lab focuses on advanced App Service configuration topics essential for the AZ-204 exam, including health checks, auto-heal, VNet integration, and managed identities.

## Prerequisites

Complete the [basic App Service lab](../appservice/README.md) and [App Service AZ-204 exercises](../appservice/AZ-204.md) first.

## AZ-204 Exam Skills Covered

- Configure health checks and auto-heal rules
- Implement VNet integration for secure connectivity
- Configure managed identities for Azure resource access
- Use Kudu console for advanced diagnostics
- Understand Always On vs idle timeout
- Differentiate application settings and slot settings
- Configure path mappings and handlers

## Exercise 1: Health Checks

**AZ-204 Critical Topic:** Health checks ensure your application is running properly and remove unhealthy instances from load balancing.

### Configure Health Check

```bash
az group create -n labs-appservice-config-az204 --tags courselabs=azure -l eastus

# Create App Service Plan (Standard tier minimum)
az appservice plan create \
  -g labs-appservice-config-az204 \
  -n config-plan \
  --sku S1 \
  --location eastus

# Create web app
az webapp create \
  -g labs-appservice-config-az204 \
  -p config-plan \
  -n <webapp-name> \
  --runtime "DOTNET:8.0"

# Configure health check
az webapp config set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --health-check-path "/health"
```

### Implement Health Check Endpoint

**.NET Example:**

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Health check endpoint
app.MapGet("/health", async (HttpContext context) =>
{
    // Check database connectivity
    var dbHealthy = await CheckDatabaseAsync();

    // Check external dependencies
    var apiHealthy = await CheckExternalApiAsync();

    if (dbHealthy && apiHealthy)
    {
        context.Response.StatusCode = 200;
        return Results.Ok(new { status = "healthy", timestamp = DateTime.UtcNow });
    }

    context.Response.StatusCode = 503;
    return Results.Json(new { status = "unhealthy", timestamp = DateTime.UtcNow }, statusCode: 503);
});

app.Run();

async Task<bool> CheckDatabaseAsync()
{
    try
    {
        // Test database connection
        // return await dbContext.Database.CanConnectAsync();
        return true;
    }
    catch
    {
        return false;
    }
}

async Task<bool> CheckExternalApiAsync()
{
    try
    {
        // Test external API
        // var response = await httpClient.GetAsync("https://api.example.com/health");
        // return response.IsSuccessStatusCode;
        return true;
    }
    catch
    {
        return false;
    }
}
```

**Node.js Example:**

```javascript
const express = require('express');
const app = express();

app.get('/health', async (req, res) => {
    try {
        // Check database
        const dbHealthy = await checkDatabase();

        // Check other dependencies
        const cacheHealthy = await checkCache();

        if (dbHealthy && cacheHealthy) {
            res.status(200).json({ status: 'healthy', timestamp: new Date() });
        } else {
            res.status(503).json({ status: 'unhealthy', timestamp: new Date() });
        }
    } catch (error) {
        res.status(503).json({ status: 'unhealthy', error: error.message });
    }
});

async function checkDatabase() {
    // Test database connection
    return true;
}

async function checkCache() {
    // Test cache connection
    return true;
}

app.listen(process.env.PORT || 3000);
```

> **AZ-204 Exam Tip:** Health check behavior:
> - Pings health check path every 60 seconds
> - Instance marked unhealthy after 10 failed checks (10 minutes)
> - Unhealthy instances removed from load balancer
> - If all instances unhealthy, most recently deployed instance receives traffic
> - Requires Standard tier or higher
> - Health check path should return 200-299 status for healthy

### Advanced Health Check Configuration

```bash
# Configure with advanced settings (via ARM template or Portal)
# - Health check path: /health
# - Health check interval: 60 seconds (default)
# - Unhealthy threshold: 10 consecutive failures (default)
# - Timeout: 30 seconds

# View health check configuration
az webapp config show \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --query "healthCheckPath"
```

## Exercise 2: Auto-Heal Rules

**AZ-204 Critical Topic:** Automatically recover from application errors and performance issues.

### Configure Auto-Heal

Auto-heal can take action based on:
- Request count
- Slow requests
- Memory limit
- Status codes
- Custom rules

```bash
# Enable auto-heal (requires restart)
az webapp config set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --auto-heal-enabled true
```

### Auto-Heal Configuration (via Portal or ARM Template)

**Example Auto-Heal Rules JSON:**

```json
{
  "autoHealEnabled": true,
  "autoHealRules": {
    "triggers": {
      "requests": {
        "count": 100,
        "timeInterval": "00:01:00"
      },
      "privateBytesInKB": 1048576,
      "statusCodes": [
        {
          "status": 500,
          "subStatus": 0,
          "win32Status": 0,
          "count": 5,
          "timeInterval": "00:01:00"
        }
      ],
      "slowRequests": {
        "timeTaken": "00:00:30",
        "count": 5,
        "timeInterval": "00:01:00"
      }
    },
    "actions": {
      "actionType": "Recycle",
      "minProcessExecutionTime": "00:01:00"
    }
  }
}
```

**Trigger Types:**

1. **Request Count**: Recycle if request volume exceeds threshold
2. **Slow Requests**: Recycle if requests take too long
3. **Memory Limit**: Recycle if private memory exceeds limit
4. **Status Codes**: Recycle on specific HTTP status codes
5. **Custom Rules**: Based on custom performance counters

**Action Types:**

1. **Recycle**: Restart the worker process
2. **LogEvent**: Log event without taking action
3. **CustomAction**: Execute custom executable

### Auto-Heal Best Practices

```bash
# View current configuration
az webapp config show \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --query "{autoHeal:autoHealEnabled, alwaysOn:alwaysOn}"
```

> **AZ-204 Exam Tip:** Auto-heal considerations:
> - Automatically recycles app when conditions are met
> - Helps recover from transient issues (memory leaks, hung threads)
> - Set `minProcessExecutionTime` to avoid immediate recycle on startup
> - Use with caution - doesn't fix underlying issues
> - Monitor with Application Insights to identify root causes
> - Available in Basic tier and higher

## Exercise 3: Always On vs Idle Timeout

**AZ-204 Critical Topic:** Control application availability and resource usage.

### Always On Setting

```bash
# Enable Always On (keeps app loaded, prevents idle timeout)
az webapp config set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --always-on true

# Disable Always On (allow idle timeout after 20 minutes)
az webapp config set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --always-on false
```

**Always On Behavior:**

**Enabled (true):**
- App always loaded and ready
- No cold start delays
- Continuous WebJobs run properly
- Consumes resources even when idle
- Required for continuous WebJobs

**Disabled (false):**
- App unloaded after 20 minutes of inactivity
- First request after idle has cold start delay
- Saves resources when traffic is low
- Triggered WebJobs not affected

> **AZ-204 Exam Tip:** Always On:
> - Available in Basic tier and higher (not Free/Shared)
> - Required for continuous WebJobs
> - Recommended for production apps with consistent traffic
> - Disable for dev/test environments to save costs
> - Each slot can have different Always On setting

### Application Initialization

```xml
<!-- web.config for IIS-based apps -->
<system.webServer>
  <applicationInitialization
    doAppInitAfterRestart="true"
    skipManagedModules="false">
    <add initializationPage="/api/warmup" />
    <add initializationPage="/api/cache/load" />
  </applicationInitialization>
</system.webServer>
```

## Exercise 4: Application Settings vs Slot Settings

**AZ-204 Critical Topic:** Understanding setting behavior during slot swaps.

### Application Settings

```bash
# Set application settings (swap with slot)
az webapp config appsettings set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --settings \
    AppVersion="1.2.3" \
    FeatureFlags__EnableNewUI="true" \
    LogLevel="Information"

# Set slot-specific settings (don't swap)
az webapp config appsettings set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging \
  --settings \
    Environment="Staging" \
    DatabaseName="staging-db" \
  --slot-settings Environment DatabaseName
```

### Connection Strings

```bash
# Production connection string (slot-specific)
az webapp config connection-string set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --connection-string-type SQLAzure \
  --settings \
    DefaultConnection="Server=prod-server.database.windows.net;Database=proddb;User ID=produser;" \
  --slot-settings DefaultConnection

# Staging connection string (slot-specific)
az webapp config connection-string set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging \
  --connection-string-type SQLAzure \
  --settings \
    DefaultConnection="Server=staging-server.database.windows.net;Database=stagingdb;User ID=staginguser;" \
  --slot-settings DefaultConnection
```

### Setting Behavior During Swap

**Non-Slot Settings (default):**
- Swap with the application
- Example: Feature flags, app version, UI settings

**Slot Settings:**
- Stay with the slot
- Example: Database connections, API endpoints, environment names

```bash
# List all settings and their slot configuration
az webapp config appsettings list \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --query "[].{Name:name, Value:value, SlotSetting:slotSetting}" \
  -o table

# Create staging slot with unique settings
az webapp deployment slot create \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging

# Configure staging-specific settings
az webapp config appsettings set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging \
  --settings \
    Environment="Staging" \
    ApiEndpoint="https://staging-api.contoso.com" \
    EnableDebugMode="true" \
  --slot-settings Environment ApiEndpoint
```

> **AZ-204 Exam Tip:** Common slot settings:
> - **Database connections**: Different per environment
> - **Storage account connections**: Separate staging storage
> - **API endpoints**: Point to staging/production APIs
> - **Application Insights keys**: Separate telemetry per slot
> - **Feature flags**: Test features in staging first
> - **Authentication settings**: Different OAuth credentials

ðŸ“‹ Configure an app with slot-specific Redis cache connection for staging and production.

<details>
  <summary>Not sure how?</summary>

```bash
# Create staging slot
az webapp deployment slot create \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging

# Production cache connection (slot-specific)
az webapp config appsettings set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --settings \
    RedisConnection="prod-cache.redis.cache.windows.net:6380,password=prodkey,ssl=True" \
  --slot-settings RedisConnection

# Staging cache connection (slot-specific)
az webapp config appsettings set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --slot staging \
  --settings \
    RedisConnection="staging-cache.redis.cache.windows.net:6380,password=stagingkey,ssl=True" \
  --slot-settings RedisConnection
```

</details><br/>

## Exercise 5: VNet Integration

**AZ-204 Critical Topic:** Connect App Service to virtual networks for secure access to private resources.

### Regional VNet Integration

```bash
# Create virtual network
az network vnet create \
  -g labs-appservice-config-az204 \
  -n app-vnet \
  --address-prefix 10.0.0.0/16 \
  --subnet-name app-subnet \
  --subnet-prefix 10.0.1.0/24

# Create integration subnet (required for regional VNet integration)
az network vnet subnet create \
  -g labs-appservice-config-az204 \
  --vnet-name app-vnet \
  -n integration-subnet \
  --address-prefix 10.0.2.0/24 \
  --delegations Microsoft.Web/serverFarms

# Enable VNet integration
az webapp vnet-integration add \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --vnet app-vnet \
  --subnet integration-subnet

# Verify VNet integration
az webapp vnet-integration list \
  -g labs-appservice-config-az204 \
  -n <webapp-name>
```

### Access Private Resources

Once integrated, your app can access:
- Azure SQL Database with private endpoint
- Azure Storage with service endpoint
- Virtual Machines in the VNet
- On-premises resources via VPN/ExpressRoute

```bash
# Configure route all traffic through VNet
az webapp config set \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --vnet-route-all-enabled true
```

### Private Endpoints (Inbound Connectivity)

```bash
# Create private endpoint for inbound access
az network private-endpoint create \
  -g labs-appservice-config-az204 \
  -n app-private-endpoint \
  --vnet-name app-vnet \
  --subnet app-subnet \
  --private-connection-resource-id $(az webapp show -g labs-appservice-config-az204 -n <webapp-name> --query id -o tsv) \
  --group-id sites \
  --connection-name app-connection

# Configure DNS for private endpoint
az network private-dns zone create \
  -g labs-appservice-config-az204 \
  -n privatelink.azurewebsites.net

az network private-dns link vnet create \
  -g labs-appservice-config-az204 \
  --zone-name privatelink.azurewebsites.net \
  --name app-dns-link \
  --virtual-network app-vnet \
  --registration-enabled false
```

> **AZ-204 Exam Tip:** VNet Integration types:
> - **Regional VNet Integration**: Connect to VNet in same region (Standard, Premium, Isolated tiers)
> - **Gateway-required VNet Integration**: Connect via VPN Gateway (any tier, deprecated)
> - **Private Endpoint**: Inbound private connectivity (Premium v2, v3, Isolated)
> - **Service Endpoints**: Outbound to Azure services (configured on subnet)
> - **VNet route all**: Route all outbound traffic through VNet

## Exercise 6: Managed Identities with App Service

**AZ-204 Critical Topic:** Securely access Azure resources without storing credentials.

### System-Assigned Managed Identity

```bash
# Enable system-assigned managed identity
az webapp identity assign \
  -g labs-appservice-config-az204 \
  -n <webapp-name>

# Get the managed identity principal ID
PRINCIPAL_ID=$(az webapp identity show \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --query principalId -o tsv)

echo "Managed Identity Principal ID: $PRINCIPAL_ID"
```

### Grant Access to Azure Resources

```bash
# Create Key Vault
az keyvault create \
  -g labs-appservice-config-az204 \
  -n <keyvault-name> \
  -l eastus

# Grant Key Vault access to managed identity
az keyvault set-policy \
  --name <keyvault-name> \
  --object-id $PRINCIPAL_ID \
  --secret-permissions get list

# Create Storage Account
az storage account create \
  -g labs-appservice-config-az204 \
  -n <storage-account-name> \
  --sku Standard_LRS

# Grant Storage Blob Data Contributor role
az role assignment create \
  --assignee $PRINCIPAL_ID \
  --role "Storage Blob Data Contributor" \
  --scope $(az storage account show -g labs-appservice-config-az204 -n <storage-account-name> --query id -o tsv)

# Grant SQL Database access
# In SQL Database, run: CREATE USER [<webapp-name>] FROM EXTERNAL PROVIDER;
# GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.TableName TO [<webapp-name>];
```

### Use Managed Identity in Application Code

**.NET Example:**

```csharp
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;
using Azure.Storage.Blobs;
using Microsoft.Data.SqlClient;

// Access Key Vault
var secretClient = new SecretClient(
    new Uri("https://<keyvault-name>.vault.azure.net/"),
    new DefaultAzureCredential());

KeyVaultSecret secret = await secretClient.GetSecretAsync("DatabasePassword");

// Access Blob Storage
var blobServiceClient = new BlobServiceClient(
    new Uri("https://<storage-account-name>.blob.core.windows.net/"),
    new DefaultAzureCredential());

var containerClient = blobServiceClient.GetBlobContainerClient("mycontainer");

// Access SQL Database with managed identity
var connectionString = "Server=tcp:myserver.database.windows.net;Database=mydb;";
using var connection = new SqlConnection(connectionString);
connection.AccessToken = await GetAzureSqlAccessTokenAsync();
await connection.OpenAsync();

async Task<string> GetAzureSqlAccessTokenAsync()
{
    var credential = new DefaultAzureCredential();
    var token = await credential.GetTokenAsync(
        new Azure.Core.TokenRequestContext(
            new[] { "https://database.windows.net/.default" }));
    return token.Token;
}
```

**Node.js Example:**

```javascript
const { DefaultAzureCredential } = require('@azure/identity');
const { SecretClient } = require('@azure/keyvault-secrets');
const { BlobServiceClient } = require('@azure/storage-blob');

// Access Key Vault
const credential = new DefaultAzureCredential();
const keyVaultUrl = 'https://<keyvault-name>.vault.azure.net/';
const secretClient = new SecretClient(keyVaultUrl, credential);

const secret = await secretClient.getSecret('DatabasePassword');
console.log(`Secret value: ${secret.value}`);

// Access Blob Storage
const blobServiceClient = new BlobServiceClient(
    'https://<storage-account-name>.blob.core.windows.net/',
    credential
);

const containerClient = blobServiceClient.getContainerClient('mycontainer');
```

### User-Assigned Managed Identity

```bash
# Create user-assigned managed identity
az identity create \
  -g labs-appservice-config-az204 \
  -n app-user-identity

# Get identity details
USER_IDENTITY_ID=$(az identity show \
  -g labs-appservice-config-az204 \
  -n app-user-identity \
  --query id -o tsv)

USER_PRINCIPAL_ID=$(az identity show \
  -g labs-appservice-config-az204 \
  -n app-user-identity \
  --query principalId -o tsv)

# Assign to web app
az webapp identity assign \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --identities $USER_IDENTITY_ID

# Grant permissions to user-assigned identity
az keyvault set-policy \
  --name <keyvault-name> \
  --object-id $USER_PRINCIPAL_ID \
  --secret-permissions get list
```

> **AZ-204 Exam Tip:** Managed Identity best practices:
> - **System-assigned**: Lifecycle tied to app, automatic cleanup
> - **User-assigned**: Shared across resources, independent lifecycle
> - **DefaultAzureCredential**: Works for both local dev and Azure deployment
> - **No credentials in code**: Most secure authentication method
> - **RBAC roles**: Use specific roles (e.g., Storage Blob Data Reader) not broad roles
> - **Key Vault references**: Use `@Microsoft.KeyVault(...)` syntax in app settings

## Exercise 7: Kudu Console

**AZ-204 Topic:** Advanced diagnostics and troubleshooting with Kudu.

### Access Kudu Console

```bash
# Get Kudu URL
echo "https://<webapp-name>.scm.azurewebsites.net"

# Open in browser (requires authentication)
az webapp browse \
  -g labs-appservice-config-az204 \
  -n <webapp-name> \
  --scm
```

### Kudu Features

**1. Debug Console (CMD/PowerShell):**
- Navigate file system
- View environment variables
- Run commands directly

**2. Environment:**
- View all environment variables
- System information
- App settings and connection strings

**3. Process Explorer:**
- View running processes
- Memory and CPU usage
- Thread count
- Create memory dumps

**4. Site Extensions:**
- Install additional tools
- Azure Application Insights Profiler
- PHP Manager

### Kudu REST API

```bash
# Get app settings via Kudu API
curl -u '$<webapp-name>:<publish-password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/settings

# Get environment variables
curl -u '$<webapp-name>:<publish-password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/environment

# List files
curl -u '$<webapp-name>:<publish-password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/vfs/site/wwwroot/

# Download file
curl -u '$<webapp-name>:<publish-password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/vfs/site/wwwroot/web.config \
  -o web.config

# Upload file
curl -u '$<webapp-name>:<publish-password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/vfs/site/wwwroot/newfile.txt \
  -X PUT \
  --data-binary @localfile.txt
```

### Kudu Command Line

```bash
# Via debug console or API
curl -u '$<webapp-name>:<publish-password>' \
  -X POST \
  https://<webapp-name>.scm.azurewebsites.net/api/command \
  -H "Content-Type: application/json" \
  -d '{"command":"dir","dir":"site\\wwwroot"}'
```

> **AZ-204 Exam Tip:** Kudu capabilities:
> - **Always accessible**: Even when app is down
> - **File system access**: Browse and modify files
> - **Process management**: View and create dumps
> - **Deployment tools**: Manual deployment operations
> - **REST API**: Automate operations
> - **Environment inspection**: View all variables and settings
> - **Requires deployment credentials**: Username/password or publish profile

### Common Kudu Diagnostic Tasks

```bash
# View running processes
# Navigate to: Process Explorer in Kudu portal

# Check environment variables
# Navigate to: Environment in Kudu portal

# View app settings (in Kudu CMD console)
echo %WEBSITE_SITE_NAME%
echo %WEBSITE_INSTANCE_ID%
echo %APPSETTING_MyCustomSetting%

# Check deployed files
cd D:\home\site\wwwroot
dir

# View logs
cd D:\home\LogFiles
dir /s

# Test connectivity
curl https://api.example.com/health
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Health Checks:**
   - Path returns 200-299 for healthy
   - Checked every 60 seconds
   - 10 failures = unhealthy
   - Requires Standard+ tier

2. **Auto-Heal:**
   - Triggers: Requests, slow requests, memory, status codes
   - Actions: Recycle, log, custom action
   - Set minimum process execution time
   - Available in Basic+ tier

3. **Always On:**
   - Keeps app loaded (no idle timeout)
   - Required for continuous WebJobs
   - Available in Basic+ tier
   - Per-slot setting

4. **Slot Settings:**
   - Stay with slot during swap
   - Used for environment-specific config
   - Database connections, API endpoints
   - Both app settings and connection strings

5. **VNet Integration:**
   - Regional: Outbound to VNet resources
   - Private Endpoint: Inbound private access
   - Route all: All traffic through VNet
   - Requires Standard+ tier

6. **Managed Identities:**
   - System-assigned: Tied to app lifecycle
   - User-assigned: Shared, independent
   - No credentials in code
   - Works with Key Vault, Storage, SQL, etc.

7. **Kudu:**
   - Advanced SCM site
   - File system access
   - Process explorer
   - REST API
   - Always accessible

### Common Exam Scenarios

1. **Scenario:** App needs to access Key Vault secrets securely
   - **Solution:** Enable managed identity, grant Key Vault access, use DefaultAzureCredential

2. **Scenario:** Database connection different for staging and production
   - **Solution:** Configure slot-specific connection strings

3. **Scenario:** Instances becoming unhealthy under load
   - **Solution:** Configure health check endpoint, implement proper health checks

4. **Scenario:** App experiencing memory leaks
   - **Solution:** Configure auto-heal with memory limit trigger

5. **Scenario:** Need to access Azure SQL Database privately
   - **Solution:** Enable VNet integration, configure SQL private endpoint

6. **Scenario:** App unloading after inactivity causing slow first request
   - **Solution:** Enable Always On setting

7. **Scenario:** Need to troubleshoot file system issues
   - **Solution:** Use Kudu console to browse files and check permissions

## Best Practices

1. **Always implement health check endpoints** for production apps
2. **Use managed identities** instead of connection strings with credentials
3. **Configure slot-specific settings** for environment-specific configuration
4. **Enable VNet integration** when accessing private Azure resources
5. **Use Always On** for production apps with consistent traffic
6. **Configure auto-heal** as safety net, but fix root causes
7. **Test slot settings** before swapping to production
8. **Use Kudu** for advanced troubleshooting
9. **Monitor health check failures** with Application Insights
10. **Document slot settings** for team awareness

## Cleanup

```bash
az group delete -y -n labs-appservice-config-az204 --no-wait
```

## Additional Resources

- [App Service health checks](https://docs.microsoft.com/en-us/azure/app-service/monitor-instances-health-check)
- [Auto-heal rules](https://azure.github.io/AppService/2018/09/10/Announcing-the-New-Auto-Healing-Experience-in-App-Service-Diagnostics.html)
- [VNet integration](https://docs.microsoft.com/en-us/azure/app-service/web-sites-integrate-with-vnet)
- [Managed identities with App Service](https://docs.microsoft.com/en-us/azure/app-service/overview-managed-identity)
- [Kudu service](https://github.com/projectkudu/kudu/wiki)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
