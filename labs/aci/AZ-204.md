# Azure Container Instances - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Implement containerized solutions (10-15%)

This lab extends the basic Azure Container Instances exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [ACI lab](README.md) first to understand fundamental container deployment operations.

## AZ-204 Exam Skills Covered

- Deploy container instances with environment variables and secrets
- Configure container groups and multi-container deployments
- Mount Azure Files volumes to containers
- Set resource limits (CPU, memory)
- Configure restart policies
- Access container logs and execute commands
- Pull images from private registries
- Understand when to use ACI vs Container Apps vs AKS

## Exercise 1: Container Groups and Multi-Container Deployments

**AZ-204 Critical Topic:** Container groups allow multiple containers to share resources and network.

### Understanding Container Groups

A container group is a collection of containers that:
- Get scheduled on the same host machine
- Share a lifecycle, resources, local network, and storage volumes
- Similar to a pod in Kubernetes

### Deploy a Multi-Container Group

Create a YAML file for a multi-container deployment with a web app and a sidecar:

```bash
cat > multi-container.yaml << 'EOF'
apiVersion: 2019-12-01
location: eastus
name: app-with-sidecar
properties:
  containers:
  - name: web-app
    properties:
      image: mcr.microsoft.com/azuredocs/aci-helloworld
      resources:
        requests:
          cpu: 1
          memoryInGb: 1.5
      ports:
      - port: 80
        protocol: TCP
      environmentVariables:
      - name: APP_ENV
        value: production
  - name: log-collector
    properties:
      image: mcr.microsoft.com/azure-cli
      command:
      - "/bin/sh"
      - "-c"
      - "while true; do echo 'Collecting logs...'; sleep 30; done"
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
  ipAddress:
    type: Public
    ports:
    - protocol: TCP
      port: 80
  osType: Linux
  restartPolicy: Always
tags:
  environment: production
  project: az204
type: Microsoft.ContainerInstance/containerGroups
EOF
```

Deploy the container group:

```bash
az group create -n labs-aci-az204 --tags courselabs=azure -l eastus

az container create \
  -g labs-aci-az204 \
  --file multi-container.yaml
```

Verify both containers are running:

```bash
az container show \
  -g labs-aci-az204 \
  -n app-with-sidecar \
  --query 'containers[].{name:name, state:instanceView.currentState.state}' \
  -o table
```

üìã Create a multi-container group with an Nginx container and a Redis container that share the same network.

<details>
  <summary>Not sure how?</summary>

```bash
cat > nginx-redis.yaml << 'EOF'
apiVersion: 2019-12-01
location: eastus
name: nginx-redis-group
properties:
  containers:
  - name: nginx
    properties:
      image: nginx:latest
      resources:
        requests:
          cpu: 1
          memoryInGb: 1
      ports:
      - port: 80
  - name: redis
    properties:
      image: redis:alpine
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
      ports:
      - port: 6379
  ipAddress:
    type: Public
    ports:
    - protocol: TCP
      port: 80
  osType: Linux
  restartPolicy: Always
type: Microsoft.ContainerInstance/containerGroups
EOF

az container create -g labs-aci-az204 --file nginx-redis.yaml
```

Containers in the same group can communicate via localhost.

</details><br/>

> **AZ-204 Exam Tip:** Container groups are ideal for sidecar patterns (logging, monitoring), ambassador patterns (proxy), and adapter patterns (data transformation). All containers share the same public IP and port namespace.

## Exercise 2: Environment Variables and Secrets

**AZ-204 Critical:** Properly manage configuration and sensitive data in containers.

### Using Environment Variables

Deploy a container with regular environment variables:

```bash
az container create \
  -g labs-aci-az204 \
  -n webapp-with-env \
  --image mcr.microsoft.com/azuredocs/aci-helloworld \
  --environment-variables \
    'APP_ENV=production' \
    'LOG_LEVEL=info' \
    'MAX_CONNECTIONS=100' \
  --dns-name-label webapp-env-$RANDOM \
  --ports 80
```

### Using Secure Environment Variables

For sensitive data (passwords, API keys, connection strings), use secure environment variables:

```bash
az container create \
  -g labs-aci-az204 \
  -n webapp-with-secrets \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo API_KEY=$API_KEY && sleep 3600'" \
  --secure-environment-variables API_KEY=super-secret-key-12345 \
  --restart-policy Never
```

Check that secure variables are hidden:

```bash
az container show \
  -g labs-aci-az204 \
  -n webapp-with-secrets \
  --query 'containers[0].environmentVariables'
```

üìã Deploy a container with both regular and secure environment variables for a database connection.

<details>
  <summary>Not sure how?</summary>

```bash
az container create \
  -g labs-aci-az204 \
  -n db-app \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo Connecting to $DB_HOST with user $DB_USER && sleep 3600'" \
  --environment-variables \
    'DB_HOST=myserver.database.windows.net' \
    'DB_NAME=ProductsDB' \
    'DB_USER=dbadmin' \
  --secure-environment-variables \
    'DB_PASSWORD=MySecureP@ssw0rd!' \
    'CONNECTION_STRING=Server=tcp:myserver.database.windows.net;Database=ProductsDB' \
  --restart-policy Never
```

Regular variables are visible, but secure variables are masked in queries.

</details><br/>

> **AZ-204 Exam Tip:** Secure environment variables are encrypted and not visible in container properties or logs. Always use secure environment variables for passwords, keys, and connection strings. For better security, use Azure Key Vault integration.

## Exercise 3: Mounting Azure Files Volumes

**AZ-204 Topic:** Persist data and share files across container restarts.

### Create Azure Files Share

```bash
# Create storage account
STORAGE_ACCOUNT_NAME=acifiles$RANDOM
az storage account create \
  -g labs-aci-az204 \
  -n $STORAGE_ACCOUNT_NAME \
  --sku Standard_LRS

# Get storage key
STORAGE_KEY=$(az storage account keys list \
  -g labs-aci-az204 \
  -n $STORAGE_ACCOUNT_NAME \
  --query '[0].value' -o tsv)

# Create file share
az storage share create \
  --account-name $STORAGE_ACCOUNT_NAME \
  --account-key $STORAGE_KEY \
  --name container-data
```

### Mount Volume in Container

```bash
az container create \
  -g labs-aci-az204 \
  -n webapp-with-volume \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo Hello from container > /mnt/data/hello.txt && cat /mnt/data/hello.txt && sleep 3600'" \
  --azure-file-volume-account-name $STORAGE_ACCOUNT_NAME \
  --azure-file-volume-account-key $STORAGE_KEY \
  --azure-file-volume-share-name container-data \
  --azure-file-volume-mount-path /mnt/data \
  --restart-policy Never
```

Verify the file was created:

```bash
az storage file list \
  --account-name $STORAGE_ACCOUNT_NAME \
  --account-key $STORAGE_KEY \
  --share-name container-data \
  -o table

az storage file download \
  --account-name $STORAGE_ACCOUNT_NAME \
  --account-key $STORAGE_KEY \
  --share-name container-data \
  --path hello.txt \
  --dest ./hello-downloaded.txt

cat hello-downloaded.txt
```

üìã Deploy a container that writes logs to an Azure Files share at /var/log/app.

<details>
  <summary>Not sure how?</summary>

```bash
az container create \
  -g labs-aci-az204 \
  -n log-writer \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'for i in {1..100}; do echo \"Log entry \$i at \$(date)\" >> /var/log/app/application.log; sleep 5; done'" \
  --azure-file-volume-account-name $STORAGE_ACCOUNT_NAME \
  --azure-file-volume-account-key $STORAGE_KEY \
  --azure-file-volume-share-name container-data \
  --azure-file-volume-mount-path /var/log/app \
  --restart-policy Never
```

Check logs in storage:

```bash
az storage file list \
  --account-name $STORAGE_ACCOUNT_NAME \
  --account-key $STORAGE_KEY \
  --share-name container-data \
  -o table
```

</details><br/>

> **AZ-204 Exam Tip:** Azure Files is the primary persistent storage option for ACI. Volumes survive container restarts and can be shared across multiple containers. Other volume types include empty directory (emptyDir) for temporary storage and secret volumes.

## Exercise 4: Resource Limits (CPU and Memory)

**AZ-204 Critical:** Control resource allocation and costs.

### Understanding Resource Requests

ACI bills based on CPU cores and memory GB per second. You can specify:
- **Requests**: Minimum resources guaranteed
- **Limits**: Maximum resources allowed (not directly supported in ACI, uses requests as both)

### Deploy with Specific Resource Limits

```bash
# Small container (minimal resources)
az container create \
  -g labs-aci-az204 \
  -n small-container \
  --image nginx:alpine \
  --cpu 0.5 \
  --memory 0.5 \
  --ports 80

# Large container (more resources)
az container create \
  -g labs-aci-az204 \
  -n large-container \
  --image nginx:alpine \
  --cpu 2 \
  --memory 4 \
  --ports 80
```

View resource allocation:

```bash
az container show \
  -g labs-aci-az204 \
  -n large-container \
  --query 'containers[0].resources.requests' \
  -o table
```

üìã Deploy a container group with different resource allocations for each container.

<details>
  <summary>Not sure how?</summary>

```bash
cat > resource-limits.yaml << 'EOF'
apiVersion: 2019-12-01
location: eastus
name: multi-resource-app
properties:
  containers:
  - name: frontend
    properties:
      image: nginx:alpine
      resources:
        requests:
          cpu: 1
          memoryInGb: 1
      ports:
      - port: 80
  - name: worker
    properties:
      image: mcr.microsoft.com/azure-cli
      command:
      - "/bin/sh"
      - "-c"
      - "while true; do echo 'Processing...'; sleep 10; done"
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
  - name: cache
    properties:
      image: redis:alpine
      resources:
        requests:
          cpu: 0.25
          memoryInGb: 0.25
      ports:
      - port: 6379
  ipAddress:
    type: Public
    ports:
    - port: 80
  osType: Linux
  restartPolicy: Always
type: Microsoft.ContainerInstance/containerGroups
EOF

az container create -g labs-aci-az204 --file resource-limits.yaml
```

</details><br/>

> **AZ-204 Exam Tip:** ACI supports:
> - CPU: 0.1 to 4 cores (in 0.1 increments)
> - Memory: 0.1 GB to 16 GB
> - Billing is per second based on allocated resources
> - Right-size containers to optimize costs

## Exercise 5: Restart Policies

**AZ-204 Topic:** Control container restart behavior for different workload types.

### Restart Policy Options

- **Always** (default): Container always restarts on exit
- **OnFailure**: Container restarts only on failure (non-zero exit code)
- **Never**: Container never restarts

### Long-Running Service (Always)

```bash
az container create \
  -g labs-aci-az204 \
  -n web-service \
  --image nginx:alpine \
  --restart-policy Always \
  --ports 80
```

### Batch Job (OnFailure)

```bash
az container create \
  -g labs-aci-az204 \
  -n data-processor \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo Processing data...; sleep 10; exit 0'" \
  --restart-policy OnFailure
```

### One-Time Task (Never)

```bash
az container create \
  -g labs-aci-az204 \
  -n backup-task \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo Running backup...; sleep 5; echo Complete'" \
  --restart-policy Never
```

Watch the one-time task complete:

```bash
az container show \
  -g labs-aci-az204 \
  -n backup-task \
  --query 'instanceView.state' \
  -o tsv
```

üìã Create a container that simulates a failing job and observe restart behavior with OnFailure policy.

<details>
  <summary>Not sure how?</summary>

```bash
az container create \
  -g labs-aci-az204 \
  -n failing-job \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'echo Attempt \$RANDOM; exit 1'" \
  --restart-policy OnFailure

# Check container events
az container show \
  -g labs-aci-az204 \
  -n failing-job \
  --query 'instanceView.events' \
  -o table
```

The container will keep restarting due to the non-zero exit code.

</details><br/>

> **AZ-204 Exam Tip:** Choose restart policy based on workload:
> - **Always**: Web servers, APIs, long-running services
> - **OnFailure**: Batch jobs, data processing tasks
> - **Never**: One-time initialization tasks, database migrations

## Exercise 6: Container Logs and Exec

**AZ-204 Critical:** Debug and troubleshoot running containers.

### View Container Logs

```bash
# Deploy a container that generates logs
az container create \
  -g labs-aci-az204 \
  -n log-generator \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'for i in {1..100}; do echo \"Log entry \$i at \$(date)\"; sleep 2; done'" \
  --restart-policy Never

# View logs
az container logs \
  -g labs-aci-az204 \
  -n log-generator

# Follow logs (stream)
az container logs \
  -g labs-aci-az204 \
  -n log-generator \
  --follow
```

### View Logs from Specific Container in Group

```bash
# For multi-container groups, specify container name
az container logs \
  -g labs-aci-az204 \
  -n app-with-sidecar \
  --container-name log-collector
```

### Execute Commands in Running Container

```bash
# Deploy a long-running container
az container create \
  -g labs-aci-az204 \
  -n debug-container \
  --image mcr.microsoft.com/azure-cli \
  --command-line "/bin/bash -c 'sleep 3600'" \
  --restart-policy Never

# Execute commands
az container exec \
  -g labs-aci-az204 \
  -n debug-container \
  --exec-command "ls -la /"

az container exec \
  -g labs-aci-az204 \
  -n debug-container \
  --exec-command "df -h"

az container exec \
  -g labs-aci-az204 \
  -n debug-container \
  --exec-command "ps aux"
```

### Interactive Shell Session

```bash
az container exec \
  -g labs-aci-az204 \
  -n debug-container \
  --exec-command "/bin/bash"
```

üìã Troubleshoot a failing container by viewing its logs and executing diagnostic commands.

<details>
  <summary>Not sure how?</summary>

```bash
# Deploy container that will fail
az container create \
  -g labs-aci-az204 \
  -n troubleshoot-me \
  --image nginx:alpine \
  --command-line "/bin/sh -c 'echo Starting app...; sleep 5; echo ERROR: Configuration missing; exit 1'" \
  --restart-policy Never

# Wait a moment, then check logs
az container logs -g labs-aci-az204 -n troubleshoot-me

# Check instance view
az container show \
  -g labs-aci-az204 \
  -n troubleshoot-me \
  --query 'instanceView' \
  -o json
```

</details><br/>

> **AZ-204 Exam Tip:**
> - `az container logs` retrieves stdout/stderr output
> - `az container exec` runs commands in running containers
> - Logs are retained for a limited time after container termination
> - Use Application Insights or Log Analytics for long-term log retention

## Exercise 7: Private Container Registries

**AZ-204 Topic:** Pull images from Azure Container Registry and other private registries.

### Create Azure Container Registry

```bash
ACR_NAME=acr$RANDOM

az acr create \
  -g labs-aci-az204 \
  -n $ACR_NAME \
  --sku Basic \
  --admin-enabled true
```

### Build and Push Image to ACR

```bash
# Create a simple Dockerfile
mkdir app
cat > app/Dockerfile << 'EOF'
FROM nginx:alpine
RUN echo '<h1>AZ-204 Private Registry Demo</h1>' > /usr/share/nginx/html/index.html
EOF

# Build and push
az acr build \
  -t sample-app:v1 \
  -r $ACR_NAME \
  ./app
```

### Deploy Container from ACR

```bash
# Get ACR credentials
ACR_USERNAME=$(az acr credential show -n $ACR_NAME --query username -o tsv)
ACR_PASSWORD=$(az acr credential show -n $ACR_NAME --query 'passwords[0].value' -o tsv)
ACR_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)

# Deploy from private registry
az container create \
  -g labs-aci-az204 \
  -n app-from-acr \
  --image ${ACR_SERVER}/sample-app:v1 \
  --registry-login-server $ACR_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label acr-app-$RANDOM \
  --ports 80

# Get URL
az container show \
  -g labs-aci-az204 \
  -n app-from-acr \
  --query 'ipAddress.fqdn' \
  -o tsv
```

### Using Managed Identity (Recommended)

```bash
# Enable managed identity on ACI
az container create \
  -g labs-aci-az204 \
  -n app-from-acr-mi \
  --image ${ACR_SERVER}/sample-app:v1 \
  --assign-identity \
  --acr-identity [system] \
  --ports 80

# Grant AcrPull permission (if needed)
IDENTITY=$(az container show -g labs-aci-az204 -n app-from-acr-mi --query identity.principalId -o tsv)
ACR_ID=$(az acr show -n $ACR_NAME --query id -o tsv)

az role assignment create \
  --assignee $IDENTITY \
  --role AcrPull \
  --scope $ACR_ID
```

üìã Deploy a container from Docker Hub private registry using credentials.

<details>
  <summary>Not sure how?</summary>

```bash
# For Docker Hub or other registries
az container create \
  -g labs-aci-az204 \
  -n app-from-dockerhub \
  --image username/private-image:tag \
  --registry-login-server docker.io \
  --registry-username <dockerhub-username> \
  --registry-password <dockerhub-password> \
  --ports 80
```

For production, use managed identity with ACR instead of passwords.

</details><br/>

> **AZ-204 Exam Tip:** Authentication options for private registries:
> - **Username/Password**: Basic authentication (admin account)
> - **Service Principal**: For automation and CI/CD
> - **Managed Identity**: Most secure, no credentials in deployment (RECOMMENDED)
> - ACR supports Azure AD authentication for fine-grained access control

## Exercise 8: When to Use ACI vs Container Apps vs AKS

**AZ-204 Critical:** Understand which Azure container service to use.

### Decision Matrix

#### Azure Container Instances (ACI)

**Use When:**
- Simple container deployments
- Batch jobs and task automation
- Build agents and CI/CD
- Development/testing environments
- Burst capacity for AKS

**Characteristics:**
- ‚úÖ Fast startup (seconds)
- ‚úÖ Per-second billing
- ‚úÖ No infrastructure management
- ‚úÖ Simple deployment model
- ‚ùå No built-in load balancing
- ‚ùå No auto-scaling
- ‚ùå Limited networking features
- ‚ùå No built-in service discovery

**Best For:**
```bash
# One-time jobs
az container create -n job --image worker:latest --restart-policy Never

# Simple web apps
az container create -n webapp --image app:latest --ports 80

# Sidecar patterns
# (Multi-container groups for logging, monitoring)
```

#### Azure Container Apps

**Use When:**
- Microservices applications
- Event-driven applications
- HTTP-based APIs and web apps
- Background processing with queues
- Modern cloud-native apps

**Characteristics:**
- ‚úÖ Built-in autoscaling (KEDA)
- ‚úÖ Ingress and traffic splitting
- ‚úÖ Dapr integration
- ‚úÖ Managed load balancing
- ‚úÖ Blue-green deployments
- ‚úÖ Scale to zero
- ‚ùå Less control than AKS
- ‚ùå Limited customization

**Best For:**
```bash
# Microservices with autoscaling
az containerapp create -n api --image api:latest --min-replicas 0 --max-replicas 10

# Event-driven apps
az containerapp create -n processor --image processor:latest \
  --scale-rule-name queue-rule --scale-rule-type azure-queue

# HTTP APIs with traffic splitting
az containerapp ingress traffic set -n api --revision-weight latest=80 previous=20
```

#### Azure Kubernetes Service (AKS)

**Use When:**
- Complex microservices architectures
- Need full Kubernetes control
- Advanced networking requirements
- Stateful applications
- Multi-region deployments
- CI/CD orchestration

**Characteristics:**
- ‚úÖ Full Kubernetes features
- ‚úÖ Complete control and customization
- ‚úÖ Advanced networking (CNI, policies)
- ‚úÖ Helm charts and operators
- ‚úÖ StatefulSets, DaemonSets
- ‚ùå Higher complexity
- ‚ùå Requires Kubernetes expertise
- ‚ùå More management overhead

**Best For:**
```bash
# Complex microservices
kubectl apply -f complex-app/

# Stateful applications
kubectl apply -f statefulset.yaml

# Advanced networking
kubectl apply -f networkpolicy.yaml

# Custom operators and CRDs
kubectl apply -f custom-operator.yaml
```

### Comparison Table

| Feature | ACI | Container Apps | AKS |
|---------|-----|----------------|-----|
| **Startup Time** | Seconds | Seconds | Minutes |
| **Complexity** | Low | Medium | High |
| **Cost Model** | Per second | Per app | Per node |
| **Auto-scaling** | No | Yes (KEDA) | Yes (HPA, KEDA) |
| **Load Balancing** | Manual | Built-in | Ingress controllers |
| **Service Mesh** | No | Built-in (Dapr) | Optional (Istio) |
| **Networking** | Basic | Managed | Advanced |
| **State** | Stateless | Stateless | Stateful |
| **Management** | None | Low | Medium |
| **Kubernetes** | No | Abstracted | Full |

### Migration Path

```
Simple App ‚Üí ACI ‚Üí Container Apps ‚Üí AKS
           (Start)   (Growing)      (Enterprise)
```

üìã Decide which service to use for the following scenarios:

<details>
  <summary>See Scenarios and Solutions</summary>

**Scenario 1:** Run a nightly database backup job
- **Answer:** ACI with restart policy Never
- **Reason:** One-time task, simple, cost-effective

**Scenario 2:** Deploy a REST API that needs to scale based on HTTP requests
- **Answer:** Container Apps
- **Reason:** Built-in autoscaling, ingress, HTTP triggers

**Scenario 3:** Deploy a complex e-commerce platform with 50+ microservices
- **Answer:** AKS
- **Reason:** Complexity requires full Kubernetes features, service mesh, advanced networking

**Scenario 4:** Run a containerized test suite in CI/CD pipeline
- **Answer:** ACI
- **Reason:** Fast startup, simple, per-second billing, no infrastructure

**Scenario 5:** Event-driven image processing triggered by blob storage
- **Answer:** Container Apps
- **Reason:** Event-driven scaling, KEDA integration, scale to zero

**Scenario 6:** Deploy a stateful database cluster with persistent storage
- **Answer:** AKS
- **Reason:** StatefulSets, persistent volumes, advanced storage options

</details><br/>

> **AZ-204 Exam Tip:** For the exam:
> - **ACI**: Simple, fast, batch jobs, sidecars
> - **Container Apps**: Modern apps, autoscaling, events, HTTP APIs
> - **AKS**: Complex apps, full control, Kubernetes expertise required
> - Remember: Start simple (ACI), grow to Container Apps, scale to AKS when needed

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Container Groups:**
   - Multiple containers sharing IP, storage, lifecycle
   - Similar to Kubernetes pods
   - Sidecar, ambassador, adapter patterns
   - Share network namespace (communicate via localhost)

2. **Environment Variables:**
   - Regular: Visible in properties and logs
   - Secure: Encrypted, hidden from queries
   - Use secure variables for secrets
   - Better: Use Key Vault for sensitive data

3. **Volumes:**
   - Azure Files: Persistent, shared storage (SMB)
   - Empty directory: Temporary, container-local
   - Secret: Mount secrets as files
   - GitRepo: Clone repository (deprecated, use init containers)

4. **Resource Management:**
   - CPU: 0.1-4 cores (fractional supported)
   - Memory: 0.1-16 GB
   - Billing: Per second, based on allocation
   - Specify both requests (guaranteed) and limits

5. **Restart Policies:**
   - Always: Long-running services (default)
   - OnFailure: Retry failed jobs
   - Never: One-time tasks, migrations

6. **Monitoring and Diagnostics:**
   - Container logs: stdout/stderr
   - Exec: Run commands in container
   - Events: Lifecycle events
   - Integrate with Log Analytics for retention

7. **Private Registries:**
   - ACR: Azure Container Registry
   - Authentication: Username/password, SP, managed identity
   - Best practice: Use managed identity
   - Pull permissions: AcrPull role

### Common Exam Scenarios

1. **Scenario:** Deploy a web app with a logging sidecar
   - **Solution:** Multi-container group with shared volume

2. **Scenario:** Run a batch job that processes files and exits
   - **Solution:** ACI with restart policy Never, mount Azure Files

3. **Scenario:** Store database password securely in container
   - **Solution:** Use secure environment variables or Key Vault

4. **Scenario:** Access application logs after container stops
   - **Solution:** Use `az container logs` or integrate Log Analytics

5. **Scenario:** Pull image from private ACR without storing credentials
   - **Solution:** Use managed identity with AcrPull role

6. **Scenario:** Choose between ACI and Container Apps for API
   - **Solution:** ACI for simple/dev, Container Apps for production with autoscaling

### Best Practices

1. **Security:**
   - Use secure environment variables for secrets
   - Prefer managed identity over passwords
   - Use private registries (ACR)
   - Enable diagnostic logging

2. **Resource Management:**
   - Right-size CPU and memory
   - Use appropriate restart policies
   - Monitor resource utilization
   - Consider per-second billing costs

3. **Storage:**
   - Use Azure Files for persistent data
   - Mount logs volume for troubleshooting
   - Don't store sensitive data in logs

4. **Networking:**
   - Use private endpoints for secure access
   - Configure DNS labels for friendly URLs
   - Use VNet integration for private networking

5. **Operations:**
   - Use YAML for complex deployments
   - Tag resources for organization
   - Integrate with Azure Monitor
   - Use managed identity for Azure services

## Cleanup

```bash
az group delete -y -n labs-aci-az204 --no-wait
```

## Additional Resources

- [Azure Container Instances documentation](https://docs.microsoft.com/en-us/azure/container-instances/)
- [Container Groups in ACI](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-container-groups)
- [Mount Azure Files volume in ACI](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-volume-azure-files)
- [Container Instances vs Container Apps vs AKS](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-container-groups)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
