# Application Insights - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Monitor, Troubleshoot, and Optimize Azure Solutions (5-10%)

This lab extends the basic Application Insights exercises with specific scenarios and skills required for the AZ-204 exam, focusing on comprehensive monitoring, troubleshooting, and optimization of Azure applications.

## Prerequisites

Complete the basic [Application Insights lab](README.md) first to understand fundamental monitoring operations.

Additional requirements:
- Azure CLI installed and configured
- .NET 6.0 or later SDK installed
- Basic understanding of Azure Web Apps and Azure Functions
- Familiarity with Kusto Query Language (KQL) basics

## AZ-204 Exam Skills Covered

- Configure Application Insights for web applications and Azure Functions
- Implement custom telemetry using the Application Insights SDK
- Use Application Map to visualize dependencies
- Configure and analyze availability tests
- Monitor applications with Live Metrics Stream
- Create and configure alerts and action groups
- Implement telemetry sampling and filtering
- Query Application Insights data using Kusto Query Language (KQL)
- Integrate Application Insights SDK with .NET applications
- Analyze application performance and troubleshoot issues

## Exercise 1: Configure Application Insights for Web Apps and Functions

Application Insights provides comprehensive monitoring for Azure applications with automatic instrumentation.

### Create Application Insights Instance

```bash
az group create -n labs-appinsights-az204 --tags courselabs=azure -l eastus

# Create Application Insights instance
az monitor app-insights component create \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  -l eastus \
  --application-type web

# Get the Instrumentation Key
INSTRUMENTATION_KEY=$(az monitor app-insights component show \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --query instrumentationKey -o tsv)

echo "Instrumentation Key: $INSTRUMENTATION_KEY"

# Get the Connection String (preferred over instrumentation key)
CONNECTION_STRING=$(az monitor app-insights component show \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --query connectionString -o tsv)

echo "Connection String: $CONNECTION_STRING"
```

> **AZ-204 Exam Tip:** Connection strings are the recommended way to configure Application Insights. They provide more flexibility than instrumentation keys and include endpoint information.

### Enable Application Insights for an Existing Web App

```bash
# Create a web app
az appservice plan create \
  -n asp-appinsights-demo \
  -g labs-appinsights-az204 \
  --sku B1 \
  -l eastus

az webapp create \
  -n webapp-appinsights-demo-$RANDOM \
  -g labs-appinsights-az204 \
  --plan asp-appinsights-demo \
  --runtime "DOTNET|6.0"

# Enable Application Insights on the web app
az webapp config appsettings set \
  -n webapp-appinsights-demo-$RANDOM \
  -g labs-appinsights-az204 \
  --settings APPLICATIONINSIGHTS_CONNECTION_STRING="$CONNECTION_STRING"

# For enhanced monitoring, enable auto-instrumentation
az monitor app-insights component connect-webapp \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --web-app webapp-appinsights-demo-$RANDOM \
  --enable-debugger false \
  --enable-profiler false
```

### Enable Application Insights for Azure Functions

```bash
# Create storage account for functions
az storage account create \
  -n safuncai$RANDOM \
  -g labs-appinsights-az204 \
  --sku Standard_LRS

# Create Function App with Application Insights
az functionapp create \
  -n func-appinsights-demo-$RANDOM \
  -g labs-appinsights-az204 \
  --consumption-plan-location eastus \
  --runtime dotnet \
  --functions-version 4 \
  --storage-account safuncai$RANDOM \
  --app-insights appinsights-az204-demo \
  --app-insights-key $INSTRUMENTATION_KEY
```

ðŸ“‹ Verify that Application Insights is properly configured by checking the app settings of your Function App.

<details>
  <summary>Not sure how?</summary>

```bash
az functionapp config appsettings list \
  -n func-appinsights-demo-$RANDOM \
  -g labs-appinsights-az204 \
  --query "[?name=='APPLICATIONINSIGHTS_CONNECTION_STRING' || name=='APPINSIGHTS_INSTRUMENTATIONKEY'].{Name:name, Value:value}" \
  -o table
```

</details><br/>

> **AZ-204 Exam Tip:** Azure Functions automatically integrate with Application Insights when created through the portal or CLI. The `APPLICATIONINSIGHTS_CONNECTION_STRING` setting is automatically added to function app settings.

## Exercise 2: Implement Custom Telemetry with the .NET SDK

**AZ-204 Critical Topic:** Custom telemetry allows you to track application-specific events, metrics, and traces.

### Install Application Insights SDK

Create a new .NET console application or web app:

```bash
mkdir ~/appinsights-custom-telemetry
cd ~/appinsights-custom-telemetry

dotnet new console
dotnet add package Microsoft.ApplicationInsights
dotnet add package Microsoft.ApplicationInsights.WorkerService
```

### Implement TelemetryClient for Custom Events

Create or update `Program.cs`:

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;
using Microsoft.ApplicationInsights.Extensibility;

// Initialize TelemetryClient
var config = TelemetryConfiguration.CreateDefault();
config.ConnectionString = "YOUR_CONNECTION_STRING_HERE";
var telemetryClient = new TelemetryClient(config);

// Track custom event
telemetryClient.TrackEvent("UserLoggedIn",
    new Dictionary<string, string>
    {
        { "UserId", "user123" },
        { "LoginMethod", "OAuth" },
        { "Location", "US-East" }
    },
    new Dictionary<string, double>
    {
        { "LoginDuration", 1.2 }
    });

// Track custom metric
telemetryClient.TrackMetric("OrderValue", 149.99,
    new Dictionary<string, string>
    {
        { "Currency", "USD" },
        { "Category", "Electronics" }
    });

// Track dependency (external call)
var startTime = DateTime.UtcNow;
var timer = System.Diagnostics.Stopwatch.StartNew();

// Simulate external call
await Task.Delay(100);

telemetryClient.TrackDependency("HTTP", "api.example.com", "GET /orders", startTime, timer.Elapsed, true);

// Track exception
try
{
    throw new InvalidOperationException("Demo exception");
}
catch (Exception ex)
{
    telemetryClient.TrackException(ex,
        new Dictionary<string, string>
        {
            { "ErrorCode", "E001" },
            { "Component", "OrderProcessor" }
        });
}

// Track trace (logging)
telemetryClient.TrackTrace("Processing order 12345",
    SeverityLevel.Information,
    new Dictionary<string, string>
    {
        { "OrderId", "12345" },
        { "Status", "Processing" }
    });

// Track page view (for web apps)
telemetryClient.TrackPageView("ProductDetails",
    new Dictionary<string, string>
    {
        { "ProductId", "PROD123" },
        { "Category", "Electronics" }
    },
    new Dictionary<string, double>
    {
        { "LoadTime", 0.8 }
    });

// Track request (custom request tracking)
var requestTelemetry = new RequestTelemetry
{
    Name = "POST /api/orders",
    Timestamp = DateTime.UtcNow,
    Duration = TimeSpan.FromMilliseconds(250),
    ResponseCode = "200",
    Success = true
};
requestTelemetry.Properties.Add("ApiVersion", "v2");
telemetryClient.TrackRequest(requestTelemetry);

// Flush telemetry before app exits
telemetryClient.Flush();
await Task.Delay(5000); // Allow time for telemetry to be sent
```

### Implement Custom Telemetry in ASP.NET Core

For ASP.NET Core applications, configure Application Insights in `Program.cs`:

```csharp
using Microsoft.ApplicationInsights.Extensibility;

var builder = WebApplication.CreateBuilder(args);

// Add Application Insights
builder.Services.AddApplicationInsightsTelemetry(options =>
{
    options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];
});

// Add custom telemetry initializer
builder.Services.AddSingleton<ITelemetryInitializer, CustomTelemetryInitializer>();

var app = builder.Build();

app.MapGet("/api/order/{id}", async (int id, TelemetryClient telemetry) =>
{
    // Automatic request tracking is enabled
    // Add custom event
    telemetry.TrackEvent("OrderRetrieved", new Dictionary<string, string>
    {
        { "OrderId", id.ToString() }
    });

    return Results.Ok(new { OrderId = id, Status = "Shipped" });
});

app.Run();
```

Create a custom telemetry initializer:

```csharp
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;

public class CustomTelemetryInitializer : ITelemetryInitializer
{
    public void Initialize(ITelemetry telemetry)
    {
        // Add custom properties to all telemetry
        telemetry.Context.GlobalProperties["Environment"] = "Production";
        telemetry.Context.GlobalProperties["ApplicationVersion"] = "2.1.0";
        telemetry.Context.Cloud.RoleName = "OrderService";
    }
}
```

ðŸ“‹ Implement a custom metric that tracks the number of items in a shopping cart and include the user's country as a property.

<details>
  <summary>Not sure how?</summary>

```csharp
telemetryClient.TrackMetric("ShoppingCartItems", 5,
    new Dictionary<string, string>
    {
        { "UserId", "user456" },
        { "Country", "USA" },
        { "SessionId", "session789" }
    });
```

To track this metric over time:

```csharp
var metric = telemetryClient.GetMetric("ShoppingCartItems", "Country");
metric.TrackValue(5, "USA");
```

</details><br/>

> **AZ-204 Exam Tip:** Key telemetry types to know:
> - **TrackEvent**: User actions or business events
> - **TrackMetric**: Numeric measurements (CPU, memory, custom business metrics)
> - **TrackException**: Exceptions and errors
> - **TrackTrace**: Diagnostic logging
> - **TrackDependency**: Calls to external services (databases, APIs, storage)
> - **TrackRequest**: Incoming requests (auto-tracked in web apps)
> - **TrackPageView**: Page views (for JavaScript/web clients)

## Exercise 3: Application Map and Dependency Tracking

**AZ-204 Exam Topic:** Application Map visualizes your application's architecture and dependencies automatically.

### Configure Dependency Tracking

Dependency tracking is automatic for most .NET applications, but you can customize it:

```csharp
using Microsoft.ApplicationInsights.DependencyCollector;

// In Program.cs or Startup.cs
builder.Services.ConfigureTelemetryModule<DependencyTrackingTelemetryModule>((module, o) =>
{
    module.EnableSqlCommandTextInstrumentation = true;
    module.EnableLegacyCorrelationHeadersInjection = true;
});
```

### Track Custom Dependencies

For custom dependencies not automatically tracked:

```csharp
public async Task<string> CallExternalApiAsync(string endpoint)
{
    var startTime = DateTime.UtcNow;
    var timer = System.Diagnostics.Stopwatch.StartNew();
    bool success = false;
    string resultCode = string.Empty;

    try
    {
        using var httpClient = new HttpClient();
        var response = await httpClient.GetAsync(endpoint);
        resultCode = ((int)response.StatusCode).ToString();
        success = response.IsSuccessStatusCode;
        return await response.Content.ReadAsStringAsync();
    }
    finally
    {
        // Track the dependency
        _telemetryClient.TrackDependency(
            dependencyTypeName: "HTTP",
            target: new Uri(endpoint).Host,
            dependencyName: endpoint,
            data: endpoint,
            startTime: startTime,
            duration: timer.Elapsed,
            resultCode: resultCode,
            success: success);
    }
}
```

### Understanding Distributed Tracing

Application Insights uses correlation IDs to track requests across services:

```csharp
// Parent service - Operation ID is automatically propagated
public async Task<IActionResult> ProcessOrder(int orderId)
{
    // This operation gets a unique operation ID
    var operation = _telemetryClient.StartOperation<RequestTelemetry>("ProcessOrder");

    try
    {
        // Call to another service - correlation headers are automatically added
        await _httpClient.GetAsync("https://inventory-service/api/check");

        // Both operations will share the same operation ID
        _telemetryClient.TrackEvent("OrderProcessed", new Dictionary<string, string>
        {
            { "OrderId", orderId.ToString() }
        });

        return Ok();
    }
    finally
    {
        _telemetryClient.StopOperation(operation);
    }
}
```

### View Application Map

Access the Application Map through Azure Portal or via API:

```bash
# Application Map data can be queried from Application Insights
az monitor app-insights query \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --analytics-query "
    requests
    | where timestamp > ago(1h)
    | summarize count() by operation_Name, cloud_RoleName
    | order by count_ desc
  "
```

> **AZ-204 Exam Tip:** Application Map shows:
> - **Components**: Your application and its dependencies
> - **Dependencies**: External services (databases, APIs, storage)
> - **Performance**: Average response times and failure rates
> - **Alerts**: Health indicators for each component
>
> Dependency tracking requires proper correlation headers (Request-Id, traceparent) to be propagated between services.

## Exercise 4: Availability Tests (Web Tests)

**AZ-204 Exam Topic:** Monitor application availability and responsiveness from multiple global locations.

### Create a URL Ping Test (Standard Availability Test)

```bash
# Create availability test using Azure CLI
az rest --method PUT \
  --uri "https://management.azure.com/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/webtests/webtest-homepage?api-version=2022-06-15" \
  --body '{
    "location": "eastus",
    "tags": {
      "hidden-link:/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo": "Resource"
    },
    "kind": "standard",
    "properties": {
      "syntheticMonitorId": "webtest-homepage",
      "name": "Homepage Availability Test",
      "enabled": true,
      "frequency": 300,
      "timeout": 30,
      "kind": "standard",
      "retryEnabled": true,
      "locations": [
        {"Id": "us-va-ash-azr"},
        {"Id": "us-ca-sjc-azr"},
        {"Id": "emea-nl-ams-azr"},
        {"Id": "apac-sg-sin-azr"},
        {"Id": "emea-gb-db3-azr"}
      ],
      "request": {
        "httpVerb": "GET",
        "requestUrl": "https://your-app-url.azurewebsites.net",
        "parseDependentRequests": false
      },
      "validationRules": {
        "expectedHttpStatusCode": 200,
        "contentValidation": {
          "contentMatch": "Welcome",
          "ignoreCase": true,
          "passIfTextFound": true
        }
      }
    }
  }'
```

### Create Multi-Step Web Test

For complex scenarios, create a multi-step test using Azure Portal or ARM template:

```xml
<!-- webtest.xml - Multi-step web test definition -->
<?xml version="1.0" encoding="utf-8"?>
<WebTest Name="LoginTest" Id="12345678-1234-1234-1234-123456789012"
         Owner="" Priority="0" Enabled="True" CssProjectStructure=""
         CssIteration="" Timeout="120" WorkItemIds=""
         xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2010">
  <Items>
    <Request Method="GET" Guid="a1234567-89ab-cdef-0123-456789abcdef"
             Version="1.1" Url="https://your-app.com/login"
             ThinkTime="0" Timeout="120" ParseDependentRequests="True">
      <ValidationRules>
        <ValidationRule Classname="Microsoft.VisualStudio.TestTools.WebTesting.Rules.ValidationRuleFindText"
                        DisplayName="Find Text"
                        Level="High"
                        ExectuionOrder="BeforeDependents">
          <RuleParameters>
            <RuleParameter Name="FindText" Value="Login" />
            <RuleParameter Name="IgnoreCase" Value="True" />
            <RuleParameter Name="UseRegularExpression" Value="False" />
            <RuleParameter Name="PassIfTextFound" Value="True" />
          </RuleParameters>
        </ValidationRule>
      </ValidationRules>
    </Request>
    <Request Method="POST" Guid="b2345678-90ab-cdef-0123-456789abcdef"
             Version="1.1" Url="https://your-app.com/api/login"
             ThinkTime="2" Timeout="120" ParseDependentRequests="False">
      <Headers>
        <Header Name="Content-Type" Value="application/json" />
      </Headers>
      <StringHttpBody ContentType="application/json" InsertByteOrderMark="False">
        {"username": "testuser", "password": "testpass"}
      </StringHttpBody>
      <ValidationRules>
        <ValidationRule Classname="Microsoft.VisualStudio.TestTools.WebTesting.Rules.ValidationRuleResponseCode"
                        DisplayName="Response Code"
                        Level="High"
                        ExectuionOrder="BeforeDependents">
          <RuleParameters>
            <RuleParameter Name="ExpectedResponseCode" Value="200" />
          </RuleParameters>
        </ValidationRule>
      </ValidationRules>
    </Request>
  </Items>
</WebTest>
```

### Configure Availability Alert

```bash
# Create action group for alerts
az monitor action-group create \
  -n ag-availability-alerts \
  -g labs-appinsights-az204 \
  --short-name AvailAlert \
  --action email admin admin@example.com

# Create availability alert rule
az monitor metrics alert create \
  -n alert-homepage-availability \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/webtests/webtest-homepage" \
  --condition "avg availabilityResults/availabilityPercentage < 99" \
  --window-size 5m \
  --evaluation-frequency 1m \
  --action ag-availability-alerts \
  --description "Alert when homepage availability drops below 99%"
```

ðŸ“‹ Create an availability test that checks if your application returns a 200 status code and the response contains the text "API v2.0".

<details>
  <summary>Not sure how?</summary>

```bash
az rest --method PUT \
  --uri "https://management.azure.com/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/webtests/webtest-api-health?api-version=2022-06-15" \
  --body '{
    "location": "eastus",
    "tags": {
      "hidden-link:/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo": "Resource"
    },
    "kind": "standard",
    "properties": {
      "syntheticMonitorId": "webtest-api-health",
      "name": "API Health Check",
      "enabled": true,
      "frequency": 300,
      "timeout": 30,
      "kind": "standard",
      "retryEnabled": true,
      "locations": [
        {"Id": "us-va-ash-azr"},
        {"Id": "emea-nl-ams-azr"}
      ],
      "request": {
        "httpVerb": "GET",
        "requestUrl": "https://your-api.azurewebsites.net/api/health"
      },
      "validationRules": {
        "expectedHttpStatusCode": 200,
        "contentValidation": {
          "contentMatch": "API v2.0",
          "ignoreCase": false,
          "passIfTextFound": true
        }
      }
    }
  }'
```

</details><br/>

> **AZ-204 Exam Tip:** Availability tests are executed from Microsoft-managed global locations:
> - **Standard tests**: Simple URL pings with optional content validation
> - **Multi-step tests**: Complex scenarios with multiple requests (requires upload of .webtest file)
> - **TrackAvailability()**: Custom availability tests from your code
> - Tests run every 5 or 15 minutes from multiple locations
> - Failed tests trigger alerts and are visible in Application Map

## Exercise 5: Live Metrics Stream

**AZ-204 Exam Topic:** Real-time monitoring for immediate diagnostics and troubleshooting.

### Enable Live Metrics

Live Metrics is automatically enabled with Application Insights SDK. Access it through Azure Portal.

### Configure Live Metrics Authentication

For production environments, secure Live Metrics with API key authentication:

```csharp
// In Program.cs or Startup.cs
builder.Services.ConfigureTelemetryModule<QuickPulseTelemetryModule>((module, options) =>
{
    module.AuthenticationApiKey = "YOUR-API-KEY";
});
```

### Custom Live Metrics

Add custom metrics to Live Metrics Stream:

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.ApplicationInsights.Extensibility.PerfCounterCollector.QuickPulse;

public class CustomLiveMetrics
{
    private readonly TelemetryClient _telemetryClient;

    public CustomLiveMetrics(TelemetryClient telemetryClient)
    {
        _telemetryClient = telemetryClient;
    }

    public void TrackBusinessMetric(string metricName, double value)
    {
        // This will appear in Live Metrics
        var metric = _telemetryClient.GetMetric(metricName);
        metric.TrackValue(value);
    }

    public void ProcessOrder(Order order)
    {
        // Track custom metric in Live Metrics
        TrackBusinessMetric("ActiveOrders", 1);
        TrackBusinessMetric("OrderValue", order.TotalAmount);

        // Process order...
    }
}
```

### Filter Live Metrics

Configure filters to focus on specific telemetry in Live Metrics:

```csharp
// Configure filters in Live Metrics
builder.Services.ConfigureTelemetryModule<QuickPulseTelemetryModule>((module, options) =>
{
    // Only show failed requests in Live Metrics
    module.RegisterTelemetryProcessor((next) =>
    {
        return new QuickPulseTelemetryProcessor(next)
        {
            // Custom filtering logic
        };
    });
});
```

> **AZ-204 Exam Tip:** Live Metrics Stream provides:
> - **Real-time telemetry**: < 1 second latency
> - **Server metrics**: Requests/sec, failures, dependencies
> - **Performance counters**: CPU, memory, process metrics
> - **Custom metrics**: Your application-specific metrics
> - **Live failures**: Exceptions and failed dependencies in real-time
> - **Sample telemetry**: Recent requests, dependencies, and exceptions
>
> Use Live Metrics for immediate diagnostics during deployments or incidents.

## Exercise 6: Alerts and Action Groups

**AZ-204 Exam Topic:** Configure proactive monitoring with alerts and automated responses.

### Create Action Groups

Action groups define what happens when an alert fires:

```bash
# Email action group
az monitor action-group create \
  -n ag-email-team \
  -g labs-appinsights-az204 \
  --short-name EmailTeam \
  --action email ops-team ops-team@example.com \
  --action email dev-team dev-team@example.com

# SMS action group
az monitor action-group create \
  -n ag-sms-oncall \
  -g labs-appinsights-az204 \
  --short-name SMSOnCall \
  --action sms oncall 1 5555551234

# Webhook action group (for integration with other systems)
az monitor action-group create \
  -n ag-webhook-slack \
  -g labs-appinsights-az204 \
  --short-name SlackHook \
  --action webhook slack-hook https://hooks.slack.com/services/YOUR/WEBHOOK/URL

# Azure Function action group
az monitor action-group create \
  -n ag-function-autofix \
  -g labs-appinsights-az204 \
  --short-name AutoFix \
  --action azurefunction autofix /subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Web/sites/{func-app}/functions/{function-name}

# Logic App action group
az monitor action-group create \
  -n ag-logicapp-ticket \
  -g labs-appinsights-az204 \
  --short-name Ticket \
  --action logicapp create-ticket /subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Logic/workflows/{logic-app}
```

### Create Metric Alerts

Alert on Application Insights metrics:

```bash
# Alert on high response time
az monitor metrics alert create \
  -n alert-high-response-time \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "avg requests/duration > 2000" \
  --window-size 5m \
  --evaluation-frequency 1m \
  --action ag-email-team \
  --description "Alert when average response time exceeds 2 seconds"

# Alert on high failure rate
az monitor metrics alert create \
  -n alert-high-failure-rate \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "avg requests/failed > 5" \
  --window-size 5m \
  --evaluation-frequency 1m \
  --action ag-email-team ag-sms-oncall \
  --description "Alert when failed requests exceed 5 per minute"

# Alert on high exception rate
az monitor metrics alert create \
  -n alert-high-exceptions \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "avg exceptions/count > 10" \
  --window-size 5m \
  --evaluation-frequency 1m \
  --action ag-email-team \
  --description "Alert when exceptions exceed 10 per minute"
```

### Create Log Query Alerts

Alert based on custom KQL queries:

```bash
# Create scheduled query rule
az monitor scheduled-query create \
  -n alert-suspicious-activity \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "count > 100" \
  --condition-query "
    requests
    | where timestamp > ago(5m)
    | where resultCode == '401'
    | summarize count() by bin(timestamp, 1m)
  " \
  --description "Alert on suspicious authentication failures" \
  --evaluation-frequency 5m \
  --window-size 5m \
  --action ag-email-team \
  --severity 2
```

### Dynamic Threshold Alerts

Create alerts with machine learning-based dynamic thresholds:

```bash
az monitor metrics alert create \
  -n alert-dynamic-response-time \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "avg requests/duration > dynamic medium 2 of 4" \
  --window-size 5m \
  --evaluation-frequency 1m \
  --action ag-email-team \
  --description "Dynamic threshold alert for response time anomalies"
```

ðŸ“‹ Create an alert that fires when the dependency failure rate exceeds 10% over a 10-minute window, and sends notifications to both email and SMS action groups.

<details>
  <summary>Not sure how?</summary>

```bash
# First, create a scheduled query for dependency failure rate
az monitor scheduled-query create \
  -n alert-dependency-failures \
  -g labs-appinsights-az204 \
  --scopes "/subscriptions/{subscription-id}/resourceGroups/labs-appinsights-az204/providers/Microsoft.Insights/components/appinsights-az204-demo" \
  --condition "avg failureRate > 10" \
  --condition-query "
    dependencies
    | where timestamp > ago(10m)
    | summarize
        total = count(),
        failures = countif(success == false),
        failureRate = 100.0 * countif(success == false) / count()
    | where failureRate > 10
  " \
  --description "Alert when dependency failure rate exceeds 10%" \
  --evaluation-frequency 5m \
  --window-size 10m \
  --action ag-email-team ag-sms-oncall \
  --severity 1
```

</details><br/>

> **AZ-204 Exam Tip:** Alert types in Azure Monitor:
> - **Metric alerts**: Based on near real-time metric values
> - **Log query alerts**: Based on KQL queries against log data
> - **Activity log alerts**: Based on events in Azure Activity Log
> - **Smart detection alerts**: Automatic anomaly detection by AI
>
> Alert severity levels: 0 (Critical), 1 (Error), 2 (Warning), 3 (Informational), 4 (Verbose)
>
> Action group types: Email, SMS, Voice, Push, Webhook, Azure Function, Logic App, Automation Runbook, ITSM, Secure Webhook

## Exercise 7: Sampling and Filtering

**AZ-204 Exam Topic:** Control telemetry volume and costs with sampling and filtering.

### Configure Adaptive Sampling

Adaptive sampling is enabled by default in ASP.NET Core:

```csharp
// Program.cs
builder.Services.AddApplicationInsightsTelemetry(options =>
{
    options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];

    // Configure adaptive sampling
    options.EnableAdaptiveSampling = true;
});

// Configure sampling settings
builder.Services.Configure<SamplingPercentageEstimatorSettings>(options =>
{
    options.MaxTelemetryItemsPerSecond = 5; // Limit to 5 items per second
    options.EvaluationInterval = TimeSpan.FromSeconds(15);
    options.SamplingPercentageDecreaseTimeout = TimeSpan.FromMinutes(2);
    options.SamplingPercentageIncreaseTimeout = TimeSpan.FromMinutes(15);
    options.InitialSamplingPercentage = 100; // Start with 100% sampling
});
```

### Configure Fixed-Rate Sampling

For predictable sampling:

```csharp
builder.Services.AddApplicationInsightsTelemetry(options =>
{
    options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];
    options.EnableAdaptiveSampling = false; // Disable adaptive sampling
});

// Add fixed-rate sampling processor
builder.Services.AddApplicationInsightsTelemetryProcessor<AdaptiveSamplingTelemetryProcessor>(
    (options) =>
    {
        options.MaxTelemetryItemsPerSecond = 5;
        options.InitialSamplingPercentage = 25; // Sample 25% of telemetry
    });
```

### Exclude Certain Telemetry from Sampling

Always include specific telemetry types:

```csharp
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.ApplicationInsights.DataContracts;

public class ExcludeImportantTelemetryProcessor : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }

    public ExcludeImportantTelemetryProcessor(ITelemetryProcessor next)
    {
        Next = next;
    }

    public void Process(ITelemetry item)
    {
        // Never sample exceptions
        if (item is ExceptionTelemetry)
        {
            ((ISupportSampling)item).SamplingPercentage = 100;
        }

        // Never sample high-priority custom events
        if (item is EventTelemetry eventTelemetry &&
            eventTelemetry.Properties.ContainsKey("Priority") &&
            eventTelemetry.Properties["Priority"] == "High")
        {
            ((ISupportSampling)item).SamplingPercentage = 100;
        }

        Next.Process(item);
    }
}

// Register in Program.cs
builder.Services.AddApplicationInsightsTelemetryProcessor<ExcludeImportantTelemetryProcessor>();
```

### Implement Telemetry Filtering

Filter out unwanted telemetry:

```csharp
public class FilterHealthCheckTelemetryProcessor : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }

    public FilterHealthCheckTelemetryProcessor(ITelemetryProcessor next)
    {
        Next = next;
    }

    public void Process(ITelemetry item)
    {
        // Filter out health check requests
        if (item is RequestTelemetry request &&
            request.Url.AbsolutePath.Contains("/health"))
        {
            return; // Don't send to Application Insights
        }

        // Filter out successful dependency calls to storage accounts (too noisy)
        if (item is DependencyTelemetry dependency &&
            dependency.Type == "Azure blob" &&
            dependency.Success == true)
        {
            return; // Don't send to Application Insights
        }

        Next.Process(item);
    }
}

// Register the processor
builder.Services.AddApplicationInsightsTelemetryProcessor<FilterHealthCheckTelemetryProcessor>();
```

### Configure Ingestion Sampling (Server-Side)

Ingestion sampling happens at the Application Insights endpoint:

```bash
# Configure ingestion sampling percentage via Azure Portal or API
# This is set in the Azure Portal under Application Insights > Usage and estimated costs > Data Sampling
```

ðŸ“‹ Implement a telemetry processor that filters out all successful requests to static files (CSS, JS, images) but keeps all failed requests and all POST requests.

<details>
  <summary>Not sure how?</summary>

```csharp
public class FilterStaticFilesTelemetryProcessor : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }
    private readonly string[] staticFileExtensions = { ".css", ".js", ".jpg", ".png", ".gif", ".ico", ".svg", ".woff", ".woff2" };

    public FilterStaticFilesTelemetryProcessor(ITelemetryProcessor next)
    {
        Next = next;
    }

    public void Process(ITelemetry item)
    {
        if (item is RequestTelemetry request)
        {
            // Keep all failed requests
            if (!request.Success)
            {
                Next.Process(item);
                return;
            }

            // Keep all POST requests
            if (request.Properties.ContainsKey("HttpMethod") &&
                request.Properties["HttpMethod"] == "POST")
            {
                Next.Process(item);
                return;
            }

            // Filter out successful requests to static files
            var path = request.Url.AbsolutePath.ToLower();
            if (staticFileExtensions.Any(ext => path.EndsWith(ext)))
            {
                return; // Don't send to Application Insights
            }
        }

        Next.Process(item);
    }
}

// Register in Program.cs
builder.Services.AddApplicationInsightsTelemetryProcessor<FilterStaticFilesTelemetryProcessor>();
```

</details><br/>

> **AZ-204 Exam Tip:** Sampling types:
> - **Adaptive sampling**: Automatically adjusts sampling rate based on telemetry volume (default in SDK)
> - **Fixed-rate sampling**: Fixed percentage set in code
> - **Ingestion sampling**: Applied at Application Insights service (affects billing)
>
> Sampling considerations:
> - Preserves correlation between related telemetry items
> - Metrics are automatically adjusted for sampling
> - Lower sampling = lower cost but less granular data
> - Always sample exceptions and critical business events at 100%

## Exercise 8: Query Application Insights Data with Kusto (KQL)

**AZ-204 Critical Topic:** Kusto Query Language (KQL) is essential for analyzing Application Insights data.

### Basic KQL Queries

Query Application Insights using Azure CLI:

```bash
# Recent requests
az monitor app-insights query \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --analytics-query "
    requests
    | where timestamp > ago(1h)
    | project timestamp, name, resultCode, duration, operation_Id
    | order by timestamp desc
    | take 20
  "

# Failed requests with details
az monitor app-insights query \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --analytics-query "
    requests
    | where timestamp > ago(24h) and success == false
    | summarize count() by resultCode, name
    | order by count_ desc
  "

# Request duration percentiles
az monitor app-insights query \
  --app appinsights-az204-demo \
  -g labs-appinsights-az204 \
  --analytics-query "
    requests
    | where timestamp > ago(1h)
    | summarize
        p50=percentile(duration, 50),
        p95=percentile(duration, 95),
        p99=percentile(duration, 99),
        avg=avg(duration)
    by name
    | order by p95 desc
  "
```

### Advanced KQL Queries for Performance Analysis

```kql
// Request timeline with aggregation
requests
| where timestamp > ago(1d)
| summarize
    count(),
    avg(duration),
    percentiles(duration, 50, 95, 99)
    by bin(timestamp, 1h), name
| render timechart

// Slowest requests
requests
| where timestamp > ago(1h)
| top 10 by duration desc
| project timestamp, name, url, duration, resultCode, operation_Id

// Requests by status code
requests
| where timestamp > ago(1d)
| summarize count() by resultCode, bin(timestamp, 1h)
| render columnchart

// Top dependencies by duration
dependencies
| where timestamp > ago(1h)
| summarize
    count(),
    avg(duration),
    max(duration)
    by target, name, type
| order by avg_duration desc
| take 20

// Failed dependencies
dependencies
| where timestamp > ago(1d) and success == false
| summarize count() by target, name, resultCode
| order by count_ desc
```

### Exception Analysis Queries

```kql
// Exception trends
exceptions
| where timestamp > ago(7d)
| summarize count() by bin(timestamp, 1h), type
| render timechart

// Top exceptions with details
exceptions
| where timestamp > ago(24h)
| summarize
    count(),
    sample_message = any(outerMessage)
    by type, method, assembly
| order by count_ desc

// Exceptions with related requests
exceptions
| where timestamp > ago(1h)
| join kind=inner (
    requests
    | where timestamp > ago(1h)
) on operation_Id
| project
    timestamp,
    exception_type = type,
    exception_message = outerMessage,
    request_name = name,
    request_url = url,
    request_resultCode = resultCode
| order by timestamp desc
```

### Custom Event and Metric Queries

```kql
// Custom events over time
customEvents
| where timestamp > ago(7d)
| where name == "UserLoggedIn"
| summarize count() by bin(timestamp, 1h), tostring(customDimensions.LoginMethod)
| render timechart

// Custom metrics analysis
customMetrics
| where timestamp > ago(1d)
| where name == "OrderValue"
| summarize
    total_orders = count(),
    total_value = sum(value),
    avg_order_value = avg(value),
    max_order_value = max(value)
    by tostring(customDimensions.Category)
| order by total_value desc

// Funnel analysis
customEvents
| where timestamp > ago(1d)
| where name in ("ProductViewed", "AddedToCart", "CheckoutStarted", "OrderCompleted")
| summarize users = dcount(user_Id) by name
| order by users desc
```

### Performance and Availability Queries

```kql
// Availability test results
availabilityResults
| where timestamp > ago(7d)
| summarize
    total_tests = count(),
    failed_tests = countif(success == false),
    availability_pct = 100.0 * countif(success == true) / count()
    by name, location
| order by availability_pct asc

// Page view performance
pageViews
| where timestamp > ago(1d)
| summarize
    count(),
    avg(duration),
    percentile(duration, 95)
    by name
| order by avg_duration desc

// End-to-end transaction tracing
requests
| where timestamp > ago(1h) and name == "POST /api/order"
| join kind=inner (
    dependencies
    | where timestamp > ago(1h)
) on operation_Id
| project
    request_timestamp = timestamp,
    request_name = name,
    request_duration = duration,
    dependency_name = name1,
    dependency_type = type,
    dependency_target = target,
    dependency_duration = duration1,
    operation_Id
| order by request_timestamp desc
```

### User and Session Analytics

```kql
// Active users by day
customEvents
| union pageViews, requests
| where timestamp > ago(30d)
| summarize users = dcount(user_Id) by bin(timestamp, 1d)
| render timechart

// Session duration analysis
pageViews
| where timestamp > ago(7d)
| summarize
    session_duration = max(timestamp) - min(timestamp),
    page_count = count()
    by session_Id
| summarize
    avg_duration = avg(session_duration),
    avg_pages = avg(page_count),
    total_sessions = count()

// User journey analysis
pageViews
| where timestamp > ago(1d)
| where session_Id != ""
| order by session_Id, timestamp asc
| summarize pages = make_list(name) by session_Id
| take 100
```

ðŸ“‹ Write a KQL query that finds all requests that took longer than 2 seconds and had at least one failed dependency call, showing the request details and the failed dependency.

<details>
  <summary>Not sure how?</summary>

```kql
let slowRequests = requests
    | where timestamp > ago(1h)
    | where duration > 2000
    | project operation_Id, request_timestamp=timestamp, request_name=name, request_url=url, request_duration=duration;
let failedDeps = dependencies
    | where timestamp > ago(1h)
    | where success == false
    | project operation_Id, dep_name=name, dep_target=target, dep_type=type, dep_resultCode=resultCode;
slowRequests
| join kind=inner (failedDeps) on operation_Id
| project
    request_timestamp,
    request_name,
    request_url,
    request_duration,
    dep_name,
    dep_target,
    dep_type,
    dep_resultCode,
    operation_Id
| order by request_timestamp desc
```

</details><br/>

> **AZ-204 Exam Tip:** Essential KQL operators:
> - **where**: Filter rows
> - **project**: Select columns
> - **extend**: Add computed columns
> - **summarize**: Aggregate data
> - **join**: Combine tables
> - **union**: Combine multiple tables
> - **render**: Visualize results (timechart, columnchart, piechart)
> - **bin()**: Round timestamps for time-series aggregation
> - **ago()**: Relative time (ago(1h), ago(7d))
> - **percentile()**: Calculate percentiles
> - **dcount()**: Count distinct values

## Exercise 9: Integration with .NET SDK (TelemetryClient)

**AZ-204 Exam Topic:** Comprehensive .NET SDK integration patterns.

### Configure Application Insights in ASP.NET Core

Complete configuration example:

```csharp
// Program.cs
using Microsoft.ApplicationInsights.AspNetCore.Extensions;
using Microsoft.ApplicationInsights.Extensibility;

var builder = WebApplication.CreateBuilder(args);

// Configure Application Insights
builder.Services.AddApplicationInsightsTelemetry(options =>
{
    options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];
    options.EnableAdaptiveSampling = true;
    options.EnableQuickPulseMetricStream = true;
    options.EnableAuthenticationTrackingJavaScript = false;
    options.EnableHeartbeat = true;
    options.AddAutoCollectedMetricExtractor = true;
    options.RequestCollectionOptions.InjectResponseHeaders = true;
    options.RequestCollectionOptions.TrackExceptions = true;
    options.EnableDependencyTrackingTelemetryModule = true;
});

// Add telemetry initializers
builder.Services.AddSingleton<ITelemetryInitializer, CloudRoleNameInitializer>();
builder.Services.AddSingleton<ITelemetryInitializer, UserContextInitializer>();

// Add telemetry processors
builder.Services.AddApplicationInsightsTelemetryProcessor<FilterHealthCheckProcessor>();
builder.Services.AddApplicationInsightsTelemetryProcessor<EnrichTelemetryProcessor>();

// Configure logging with Application Insights
builder.Logging.AddApplicationInsights();

var app = builder.Build();

app.MapGet("/", () => "Hello from Application Insights demo!");

app.Run();

// Custom Telemetry Initializer
public class CloudRoleNameInitializer : ITelemetryInitializer
{
    public void Initialize(ITelemetry telemetry)
    {
        telemetry.Context.Cloud.RoleName = "OrderService";
        telemetry.Context.Cloud.RoleInstance = Environment.MachineName;
        telemetry.Context.Component.Version = "2.1.0";
    }
}

public class UserContextInitializer : ITelemetryInitializer
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public UserContextInitializer(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public void Initialize(ITelemetry telemetry)
    {
        var httpContext = _httpContextAccessor.HttpContext;
        if (httpContext != null)
        {
            telemetry.Context.User.Id = httpContext.User?.Identity?.Name ?? "anonymous";
            telemetry.Context.Session.Id = httpContext.Session?.Id ?? Guid.NewGuid().ToString();
        }
    }
}

public class EnrichTelemetryProcessor : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }

    public EnrichTelemetryProcessor(ITelemetryProcessor next)
    {
        Next = next;
    }

    public void Process(ITelemetry item)
    {
        // Add custom properties to all telemetry
        if (!item.Context.GlobalProperties.ContainsKey("Environment"))
        {
            item.Context.GlobalProperties.Add("Environment", "Production");
        }

        if (!item.Context.GlobalProperties.ContainsKey("DataCenter"))
        {
            item.Context.GlobalProperties.Add("DataCenter", "US-East");
        }

        Next.Process(item);
    }
}
```

### Comprehensive Service Implementation

```csharp
public class OrderService
{
    private readonly TelemetryClient _telemetry;
    private readonly ILogger<OrderService> _logger;

    public OrderService(TelemetryClient telemetry, ILogger<OrderService> logger)
    {
        _telemetry = telemetry;
        _logger = logger;
    }

    public async Task<OrderResult> ProcessOrderAsync(Order order)
    {
        // Start an operation for distributed tracing
        using var operation = _telemetry.StartOperation<RequestTelemetry>("ProcessOrder");
        operation.Telemetry.Properties["OrderId"] = order.Id.ToString();
        operation.Telemetry.Properties["CustomerId"] = order.CustomerId.ToString();

        try
        {
            // Track custom event
            _telemetry.TrackEvent("OrderProcessingStarted", new Dictionary<string, string>
            {
                { "OrderId", order.Id.ToString() },
                { "ItemCount", order.Items.Count.ToString() }
            });

            // Validate order
            var validationResult = await ValidateOrderAsync(order);
            if (!validationResult.IsValid)
            {
                operation.Telemetry.Success = false;
                _telemetry.TrackEvent("OrderValidationFailed", new Dictionary<string, string>
                {
                    { "OrderId", order.Id.ToString() },
                    { "Reason", validationResult.Reason }
                });
                return OrderResult.Failed(validationResult.Reason);
            }

            // Track metric
            _telemetry.TrackMetric("OrderValue", order.TotalAmount, new Dictionary<string, string>
            {
                { "Currency", order.Currency },
                { "PaymentMethod", order.PaymentMethod }
            });

            // Process payment
            var paymentResult = await ProcessPaymentAsync(order);

            // Track dependency manually if needed
            var startTime = DateTime.UtcNow;
            var timer = System.Diagnostics.Stopwatch.StartNew();

            try
            {
                await UpdateInventoryAsync(order);

                _telemetry.TrackDependency(
                    "InventoryService",
                    "inventory-api.example.com",
                    "UpdateInventory",
                    data: order.Id.ToString(),
                    startTime: startTime,
                    duration: timer.Elapsed,
                    resultCode: "200",
                    success: true);
            }
            catch (Exception ex)
            {
                _telemetry.TrackDependency(
                    "InventoryService",
                    "inventory-api.example.com",
                    "UpdateInventory",
                    data: order.Id.ToString(),
                    startTime: startTime,
                    duration: timer.Elapsed,
                    resultCode: "500",
                    success: false);
                throw;
            }

            // Track successful completion
            operation.Telemetry.Success = true;
            _telemetry.TrackEvent("OrderProcessingCompleted", new Dictionary<string, string>
            {
                { "OrderId", order.Id.ToString() },
                { "ProcessingTime", timer.Elapsed.TotalMilliseconds.ToString() }
            });

            return OrderResult.Success(order.Id);
        }
        catch (Exception ex)
        {
            operation.Telemetry.Success = false;

            // Track exception with context
            var exceptionTelemetry = new ExceptionTelemetry(ex)
            {
                SeverityLevel = SeverityLevel.Error,
                Message = "Failed to process order"
            };
            exceptionTelemetry.Properties["OrderId"] = order.Id.ToString();
            exceptionTelemetry.Properties["CustomerId"] = order.CustomerId.ToString();
            exceptionTelemetry.Metrics["OrderValue"] = order.TotalAmount;

            _telemetry.TrackException(exceptionTelemetry);

            // Also log using ILogger (will be captured by Application Insights)
            _logger.LogError(ex, "Error processing order {OrderId}", order.Id);

            throw;
        }
    }

    private async Task<ValidationResult> ValidateOrderAsync(Order order)
    {
        // Track trace for diagnostic logging
        _telemetry.TrackTrace($"Validating order {order.Id}", SeverityLevel.Information);

        // Validation logic...
        await Task.Delay(50); // Simulate validation

        return new ValidationResult { IsValid = true };
    }

    private async Task<PaymentResult> ProcessPaymentAsync(Order order)
    {
        // Dependency tracking is automatic for HttpClient with Application Insights
        // But you can add custom properties
        using var operation = _telemetry.StartOperation<DependencyTelemetry>("ProcessPayment");
        operation.Telemetry.Type = "PaymentGateway";
        operation.Telemetry.Target = "payment-gateway.example.com";
        operation.Telemetry.Properties["OrderId"] = order.Id.ToString();
        operation.Telemetry.Properties["Amount"] = order.TotalAmount.ToString();

        try
        {
            // Payment processing logic...
            await Task.Delay(200); // Simulate payment processing

            operation.Telemetry.Success = true;
            operation.Telemetry.ResultCode = "Approved";

            return new PaymentResult { Success = true };
        }
        catch (Exception ex)
        {
            operation.Telemetry.Success = false;
            operation.Telemetry.ResultCode = "Failed";
            throw;
        }
    }

    private async Task UpdateInventoryAsync(Order order)
    {
        // Inventory update logic...
        await Task.Delay(100);
    }
}
```

### Azure Functions Integration

```csharp
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;

public class OrderFunction
{
    private readonly TelemetryClient _telemetryClient;
    private readonly ILogger<OrderFunction> _logger;

    public OrderFunction(TelemetryClient telemetryClient, ILogger<OrderFunction> logger)
    {
        _telemetryClient = telemetryClient;
        _logger = logger;
    }

    [Function("ProcessOrder")]
    public async Task<HttpResponseData> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequestData req,
        FunctionContext executionContext)
    {
        // Correlation is automatic in Functions
        _logger.LogInformation("Processing order request");

        // Track custom event
        _telemetryClient.TrackEvent("FunctionInvoked", new Dictionary<string, string>
        {
            { "FunctionName", "ProcessOrder" },
            { "InvocationId", executionContext.InvocationId }
        });

        try
        {
            var order = await req.ReadFromJsonAsync<Order>();

            // Track metric
            _telemetryClient.TrackMetric("OrdersProcessed", 1);
            _telemetryClient.TrackMetric("OrderValue", order.TotalAmount);

            // Process order...
            await ProcessOrderAsync(order);

            var response = req.CreateResponse(System.Net.HttpStatusCode.OK);
            await response.WriteAsJsonAsync(new { success = true, orderId = order.Id });

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing order");
            _telemetryClient.TrackException(ex);

            var response = req.CreateResponse(System.Net.HttpStatusCode.InternalServerError);
            await response.WriteAsJsonAsync(new { success = false, error = ex.Message });

            return response;
        }
    }

    private async Task ProcessOrderAsync(Order order)
    {
        // Processing logic with telemetry
        await Task.Delay(100);
    }
}

// Configure in Program.cs for Azure Functions
var host = new HostBuilder()
    .ConfigureFunctionsWorkerDefaults()
    .ConfigureServices(services =>
    {
        services.AddApplicationInsightsTelemetryWorkerService();
        services.ConfigureFunctionsApplicationInsights();
    })
    .Build();

await host.RunAsync();
```

ðŸ“‹ Implement a method that tracks a complete e-commerce checkout flow using TelemetryClient, including the cart view, address entry, payment, and confirmation steps.

<details>
  <summary>Not sure how?</summary>

```csharp
public class CheckoutService
{
    private readonly TelemetryClient _telemetry;

    public CheckoutService(TelemetryClient telemetry)
    {
        _telemetry = telemetry;
    }

    public async Task<CheckoutResult> CompleteCheckoutAsync(string userId, Cart cart)
    {
        // Track the overall checkout operation
        using var checkoutOperation = _telemetry.StartOperation<RequestTelemetry>("CompleteCheckout");
        checkoutOperation.Telemetry.Properties["UserId"] = userId;
        checkoutOperation.Telemetry.Properties["ItemCount"] = cart.Items.Count.ToString();

        try
        {
            // Step 1: Cart View
            _telemetry.TrackEvent("CheckoutStep1_CartView", new Dictionary<string, string>
            {
                { "UserId", userId },
                { "ItemCount", cart.Items.Count.ToString() }
            },
            new Dictionary<string, double>
            {
                { "CartValue", cart.TotalAmount }
            });

            _telemetry.TrackMetric("CartValue", cart.TotalAmount, new Dictionary<string, string>
            {
                { "UserId", userId },
                { "Step", "CartView" }
            });

            // Step 2: Address Entry
            var address = await GetShippingAddressAsync(userId);
            _telemetry.TrackEvent("CheckoutStep2_AddressEntry", new Dictionary<string, string>
            {
                { "UserId", userId },
                { "Country", address.Country },
                { "State", address.State }
            });

            // Step 3: Payment
            var paymentStartTime = DateTime.UtcNow;
            var paymentTimer = System.Diagnostics.Stopwatch.StartNew();

            var paymentResult = await ProcessPaymentAsync(userId, cart.TotalAmount);

            _telemetry.TrackDependency(
                "PaymentGateway",
                "payment.example.com",
                "ProcessPayment",
                data: cart.TotalAmount.ToString(),
                startTime: paymentStartTime,
                duration: paymentTimer.Elapsed,
                resultCode: paymentResult.TransactionId,
                success: paymentResult.Success);

            if (!paymentResult.Success)
            {
                _telemetry.TrackEvent("CheckoutStep3_PaymentFailed", new Dictionary<string, string>
                {
                    { "UserId", userId },
                    { "Reason", paymentResult.FailureReason }
                });

                checkoutOperation.Telemetry.Success = false;
                return CheckoutResult.Failed("Payment failed");
            }

            _telemetry.TrackEvent("CheckoutStep3_PaymentSuccess", new Dictionary<string, string>
            {
                { "UserId", userId },
                { "TransactionId", paymentResult.TransactionId }
            },
            new Dictionary<string, double>
            {
                { "Amount", cart.TotalAmount },
                { "PaymentDuration", paymentTimer.Elapsed.TotalSeconds }
            });

            // Step 4: Confirmation
            var orderId = await CreateOrderAsync(userId, cart, paymentResult.TransactionId);

            _telemetry.TrackEvent("CheckoutStep4_Confirmation", new Dictionary<string, string>
            {
                { "UserId", userId },
                { "OrderId", orderId },
                { "TransactionId", paymentResult.TransactionId }
            });

            // Track conversion metric
            _telemetry.TrackMetric("OrderCompleted", 1, new Dictionary<string, string>
            {
                { "UserId", userId }
            });

            _telemetry.TrackMetric("Revenue", cart.TotalAmount, new Dictionary<string, string>
            {
                { "UserId", userId },
                { "OrderId", orderId }
            });

            // Track trace for audit
            _telemetry.TrackTrace($"Checkout completed for user {userId}, order {orderId}",
                SeverityLevel.Information,
                new Dictionary<string, string>
                {
                    { "UserId", userId },
                    { "OrderId", orderId },
                    { "Amount", cart.TotalAmount.ToString() }
                });

            checkoutOperation.Telemetry.Success = true;
            return CheckoutResult.Success(orderId);
        }
        catch (Exception ex)
        {
            checkoutOperation.Telemetry.Success = false;

            _telemetry.TrackException(ex, new Dictionary<string, string>
            {
                { "UserId", userId },
                { "Step", "Checkout" },
                { "ItemCount", cart.Items.Count.ToString() }
            });

            throw;
        }
    }

    private async Task<Address> GetShippingAddressAsync(string userId)
    {
        await Task.Delay(50);
        return new Address { Country = "USA", State = "CA" };
    }

    private async Task<PaymentResult> ProcessPaymentAsync(string userId, decimal amount)
    {
        await Task.Delay(200);
        return new PaymentResult { Success = true, TransactionId = Guid.NewGuid().ToString() };
    }

    private async Task<string> CreateOrderAsync(string userId, Cart cart, string transactionId)
    {
        await Task.Delay(100);
        return Guid.NewGuid().ToString();
    }
}
```

</details><br/>

> **AZ-204 Exam Tip:** TelemetryClient best practices:
> - Use dependency injection to get TelemetryClient instance
> - Call `Flush()` only when application is shutting down (automatic flush happens periodically)
> - Use `StartOperation<T>()` for distributed tracing with automatic correlation
> - Add properties and metrics to provide context
> - Use telemetry initializers for global properties
> - Use telemetry processors for filtering and enrichment
> - Always set `Success` property on operations
> - Use appropriate severity levels for traces (Verbose, Information, Warning, Error, Critical)

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Application Insights Components:**
   - **Instrumentation Key**: Legacy identifier (still supported)
   - **Connection String**: Recommended method (includes endpoints)
   - **SDK vs. Codeless**: SDK provides more control, codeless is easier
   - **Sampling**: Adaptive, fixed-rate, and ingestion sampling

2. **Telemetry Types:**
   - **Request**: Incoming HTTP requests (automatic)
   - **Dependency**: Outgoing calls to external services (automatic for common types)
   - **Exception**: Unhandled and tracked exceptions
   - **Event**: Custom business events
   - **Metric**: Numeric measurements
   - **Trace**: Diagnostic logs
   - **PageView**: Client-side page views

3. **Distributed Tracing:**
   - **Operation ID**: Links related telemetry across services
   - **Parent ID**: Identifies parent operation
   - **W3C Trace Context**: Standard for distributed tracing
   - **Correlation headers**: Request-Id, traceparent

4. **Sampling Strategies:**
   - **Adaptive**: Automatically adjusts based on volume
   - **Fixed-rate**: Set percentage in code
   - **Ingestion**: Server-side at Application Insights endpoint
   - **Preserve exceptions and critical events at 100%**

5. **Availability Monitoring:**
   - **Standard tests**: Simple URL pings
   - **Multi-step tests**: Complex scenarios (.webtest files)
   - **Custom tests**: Using TrackAvailability() in code
   - **Test frequency**: 5 or 15 minutes
   - **Global locations**: Multiple Microsoft-managed locations

6. **Alerts and Actions:**
   - **Metric alerts**: Near real-time metric values
   - **Log query alerts**: KQL queries against logs
   - **Smart detection**: Automatic anomaly detection
   - **Action groups**: Email, SMS, Webhook, Azure Function, Logic App

7. **Kusto Query Language (KQL):**
   - **Tables**: requests, dependencies, exceptions, traces, customEvents, customMetrics
   - **Operators**: where, project, extend, summarize, join, union
   - **Functions**: ago(), bin(), percentile(), dcount()
   - **Correlation**: Use operation_Id to link related telemetry

### Common Exam Scenarios

1. **Scenario**: Monitor a web application's response time and alert when it exceeds 2 seconds
   - **Solution**: Configure metric alert on `requests/duration` with threshold > 2000ms

2. **Scenario**: Track custom business metrics like "Orders Completed" and "Revenue"
   - **Solution**: Use `TelemetryClient.TrackMetric()` with custom dimensions

3. **Scenario**: Reduce Application Insights costs while maintaining data quality
   - **Solution**: Implement adaptive or fixed-rate sampling, filter out noisy telemetry

4. **Scenario**: Monitor application availability from multiple global locations
   - **Solution**: Create standard availability tests with multiple test locations

5. **Scenario**: Trace a request across multiple microservices
   - **Solution**: Use distributed tracing with operation_Id correlation and Application Map

6. **Scenario**: Find all requests that took longer than 5 seconds in the past 24 hours
   - **Solution**: KQL query: `requests | where timestamp > ago(24h) and duration > 5000`

7. **Scenario**: Get real-time visibility into application performance during deployment
   - **Solution**: Use Live Metrics Stream in Azure Portal

8. **Scenario**: Automatically respond to high error rates
   - **Solution**: Create log query alert with action group pointing to Azure Function or Logic App

9. **Scenario**: Track user behavior through a multi-step process
   - **Solution**: Use custom events with shared session_Id and user_Id

10. **Scenario**: Exclude health check requests from telemetry to reduce noise
    - **Solution**: Implement telemetry processor that filters health check URLs

### Best Practices for AZ-204 Exam

1. **Always use Connection Strings** over Instrumentation Keys (recommended by Microsoft)

2. **Enable auto-instrumentation** for:
   - HTTP requests/responses
   - Database calls (SQL, Cosmos DB)
   - Azure Storage operations
   - Redis cache operations
   - Azure Service Bus, Event Hubs

3. **Use semantic telemetry** with meaningful names and properties:
   - Good: `TrackEvent("OrderCompleted", new { OrderId = "123", Value = 99.99 })`
   - Bad: `TrackEvent("Event1", new { P1 = "123" })`

4. **Implement correlation** for distributed systems:
   - Use `StartOperation<T>()` to create operation context
   - Propagate correlation headers between services
   - Set Cloud.RoleName for each service component

5. **Control costs** with sampling and filtering:
   - Sample high-volume, low-value telemetry
   - Keep exceptions and business events at 100%
   - Filter out health checks and static files

6. **Use Application Map** to visualize:
   - Service dependencies
   - Performance bottlenecks
   - Failure points

7. **Master KQL** for data analysis:
   - Know common tables and schemas
   - Understand joins and correlation
   - Practice time-series queries with bin()

8. **Configure appropriate alerts:**
   - Metric alerts for real-time monitoring
   - Log query alerts for complex conditions
   - Dynamic thresholds for anomaly detection
   - Action groups for automated responses

## Additional Resources

- [Application Insights Overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
- [Application Insights SDK for .NET](https://docs.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core)
- [Kusto Query Language (KQL) Reference](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/)
- [Application Insights Sampling](https://docs.microsoft.com/en-us/azure/azure-monitor/app/sampling)
- [Distributed Tracing](https://docs.microsoft.com/en-us/azure/azure-monitor/app/distributed-tracing)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)

## Cleanup

```bash
# Delete all resources created in this lab
az group delete -y -n labs-appinsights-az204 --no-wait
```

## Summary

You've completed comprehensive Application Insights exercises covering all AZ-204 exam requirements for monitoring, troubleshooting, and optimizing Azure solutions:

- Configured Application Insights for web apps and functions
- Implemented custom telemetry with TelemetryClient
- Worked with Application Map and dependency tracking
- Created availability tests for proactive monitoring
- Used Live Metrics Stream for real-time diagnostics
- Configured alerts and action groups for automated responses
- Implemented sampling and filtering for cost optimization
- Queried Application Insights data with KQL
- Integrated the .NET SDK comprehensively

These skills are essential for the AZ-204 exam's "Monitor, Troubleshoot, and Optimize Azure Solutions" domain.
