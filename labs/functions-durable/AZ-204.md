# Azure Durable Functions - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop Azure Compute Solutions (25-30%)

This lab covers Azure Durable Functions with specific scenarios, patterns, and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Durable Functions labs](README.md) to understand fundamental orchestration concepts.

## AZ-204 Exam Skills Covered

- Implement Durable Functions patterns (chaining, fan-out/fan-in, async HTTP, monitor, human interaction)
- Understand orchestrator function constraints and requirements
- Implement activity functions for stateless work
- Configure client functions to start orchestrations
- Work with sub-orchestrations for complex workflows
- Implement durable entities for stateful objects
- Apply best practices and avoid anti-patterns

## Exercise 1: Function Chaining Pattern

**AZ-204 Critical Pattern:** Sequential execution of multiple activities with data flow.

### Basic Function Chaining

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.DurableTask;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

public static class FunctionChaining
{
    [FunctionName("OrderProcessing")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context,
        ILogger log)
    {
        var orderId = context.GetInput<string>();

        try
        {
            // Step 1: Validate order
            var isValid = await context.CallActivityAsync<bool>("ValidateOrder", orderId);
            if (!isValid)
            {
                return $"Order {orderId} validation failed";
            }

            // Step 2: Process payment
            var paymentResult = await context.CallActivityAsync<string>("ProcessPayment", orderId);

            // Step 3: Update inventory
            var inventoryResult = await context.CallActivityAsync<string>("UpdateInventory", orderId);

            // Step 4: Ship order
            var shippingResult = await context.CallActivityAsync<string>("ShipOrder", orderId);

            // Step 5: Send confirmation
            await context.CallActivityAsync("SendConfirmation", orderId);

            return $"Order {orderId} processed successfully";
        }
        catch (Exception ex)
        {
            // Handle failures
            await context.CallActivityAsync("HandleFailure", new { orderId, error = ex.Message });
            throw;
        }
    }

    [FunctionName("ValidateOrder")]
    public static bool ValidateOrder([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Validating order {orderId}");
        // Validation logic
        return true;
    }

    [FunctionName("ProcessPayment")]
    public static string ProcessPayment([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Processing payment for order {orderId}");
        // Payment processing logic
        return "Payment processed";
    }

    [FunctionName("UpdateInventory")]
    public static string UpdateInventory([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Updating inventory for order {orderId}");
        // Inventory update logic
        return "Inventory updated";
    }

    [FunctionName("ShipOrder")]
    public static string ShipOrder([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Shipping order {orderId}");
        // Shipping logic
        return "Order shipped";
    }

    [FunctionName("SendConfirmation")]
    public static void SendConfirmation([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Sending confirmation for order {orderId}");
        // Send email/notification
    }

    [FunctionName("HandleFailure")]
    public static void HandleFailure([ActivityTrigger] IDurableActivityContext context, ILogger log)
    {
        var input = context.GetInput<dynamic>();
        log.LogError($"Order {input.orderId} failed: {input.error}");
        // Failure handling logic
    }
}
```

### Chaining with Data Transformation

```csharp
public static class DataPipeline
{
    [FunctionName("DataProcessingPipeline")]
    public static async Task<ProcessedData> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var rawData = context.GetInput<RawData>();

        // Chain of transformations
        var cleaned = await context.CallActivityAsync<CleanedData>("CleanData", rawData);
        var validated = await context.CallActivityAsync<ValidatedData>("ValidateData", cleaned);
        var enriched = await context.CallActivityAsync<EnrichedData>("EnrichData", validated);
        var processed = await context.CallActivityAsync<ProcessedData>("TransformData", enriched);

        return processed;
    }

    [FunctionName("CleanData")]
    public static CleanedData CleanData([ActivityTrigger] RawData input, ILogger log)
    {
        log.LogInformation("Cleaning data");
        return new CleanedData { /* cleaned data */ };
    }

    [FunctionName("ValidateData")]
    public static ValidatedData ValidateData([ActivityTrigger] CleanedData input, ILogger log)
    {
        log.LogInformation("Validating data");
        return new ValidatedData { /* validated data */ };
    }

    [FunctionName("EnrichData")]
    public static EnrichedData EnrichData([ActivityTrigger] ValidatedData input, ILogger log)
    {
        log.LogInformation("Enriching data");
        return new EnrichedData { /* enriched data */ };
    }

    [FunctionName("TransformData")]
    public static ProcessedData TransformData([ActivityTrigger] EnrichedData input, ILogger log)
    {
        log.LogInformation("Transforming data");
        return new ProcessedData { /* final data */ };
    }
}

public class RawData { }
public class CleanedData { }
public class ValidatedData { }
public class EnrichedData { }
public class ProcessedData { }
```

> **AZ-204 Exam Tip:** Function chaining:
> - Sequential execution of activities
> - Output of one activity is input to next
> - Use for linear workflows with dependencies
> - Good for data transformation pipelines

## Exercise 2: Fan-Out/Fan-In Pattern

**AZ-204 Critical Pattern:** Parallel execution of multiple activities, then aggregate results.

### Basic Fan-Out/Fan-In

```csharp
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

public static class FanOutFanIn
{
    [FunctionName("ParallelFileProcessing")]
    public static async Task<ProcessingSummary> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var files = await context.CallActivityAsync<string[]>("GetFileList", null);

        // Fan-out: Start parallel activities
        var tasks = new List<Task<FileResult>>();
        foreach (var file in files)
        {
            tasks.Add(context.CallActivityAsync<FileResult>("ProcessFile", file));
        }

        // Fan-in: Wait for all to complete
        var results = await Task.WhenAll(tasks);

        // Aggregate results
        var summary = new ProcessingSummary
        {
            TotalFiles = results.Length,
            SuccessCount = results.Count(r => r.Success),
            FailureCount = results.Count(r => !r.Success),
            TotalSize = results.Sum(r => r.Size)
        };

        return summary;
    }

    [FunctionName("GetFileList")]
    public static string[] GetFileList([ActivityTrigger] IDurableActivityContext context, ILogger log)
    {
        log.LogInformation("Retrieving file list");
        return new[] { "file1.txt", "file2.txt", "file3.txt", "file4.txt", "file5.txt" };
    }

    [FunctionName("ProcessFile")]
    public static async Task<FileResult> ProcessFile([ActivityTrigger] string fileName, ILogger log)
    {
        log.LogInformation($"Processing file: {fileName}");

        // Simulate file processing
        await Task.Delay(1000);

        return new FileResult
        {
            FileName = fileName,
            Success = true,
            Size = 1024
        };
    }
}

public class FileResult
{
    public string FileName { get; set; }
    public bool Success { get; set; }
    public long Size { get; set; }
}

public class ProcessingSummary
{
    public int TotalFiles { get; set; }
    public int SuccessCount { get; set; }
    public int FailureCount { get; set; }
    public long TotalSize { get; set; }
}
```

### Batch Processing with Fan-Out/Fan-In

```csharp
public static class BatchProcessing
{
    [FunctionName("BatchOrderProcessing")]
    public static async Task<BatchResult> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var orderIds = context.GetInput<List<string>>();

        // Process in batches of 10 for better control
        var batchSize = 10;
        var allResults = new List<OrderResult>();

        for (int i = 0; i < orderIds.Count; i += batchSize)
        {
            var batch = orderIds.Skip(i).Take(batchSize).ToList();

            // Fan-out for this batch
            var tasks = batch.Select(orderId =>
                context.CallActivityAsync<OrderResult>("ProcessOrder", orderId)
            ).ToList();

            // Fan-in for this batch
            var batchResults = await Task.WhenAll(tasks);
            allResults.AddRange(batchResults);
        }

        return new BatchResult
        {
            TotalProcessed = allResults.Count,
            Successful = allResults.Count(r => r.Success),
            Failed = allResults.Count(r => !r.Success)
        };
    }

    [FunctionName("ProcessOrder")]
    public static async Task<OrderResult> ProcessOrder([ActivityTrigger] string orderId, ILogger log)
    {
        log.LogInformation($"Processing order: {orderId}");
        await Task.Delay(500);

        return new OrderResult
        {
            OrderId = orderId,
            Success = true
        };
    }
}

public class OrderResult
{
    public string OrderId { get; set; }
    public bool Success { get; set; }
}

public class BatchResult
{
    public int TotalProcessed { get; set; }
    public int Successful { get; set; }
    public int Failed { get; set; }
}
```

> **AZ-204 Exam Tip:** Fan-out/fan-in:
> - Execute multiple activities in parallel
> - Use `Task.WhenAll()` to wait for completion
> - Good for parallel data processing, batch operations
> - Consider batching for large datasets

## Exercise 3: Async HTTP APIs Pattern

**AZ-204 Critical Pattern:** Long-running operations with status polling.

### Async HTTP Pattern Implementation

```csharp
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs.Extensions.Http;
using System;
using System.Threading.Tasks;

public static class AsyncHttpPattern
{
    [FunctionName("AsyncHttpPattern_HttpStart")]
    public static async Task<IActionResult> HttpStart(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
        [DurableClient] IDurableOrchestrationClient starter,
        ILogger log)
    {
        var requestData = await req.ReadAsStringAsync();

        // Start the orchestration
        string instanceId = await starter.StartNewAsync("AsyncHttpPattern_Orchestrator", null, requestData);

        log.LogInformation($"Started orchestration with ID = '{instanceId}'");

        // Return HTTP 202 with status query URLs
        return starter.CreateCheckStatusResponse(req, instanceId);
    }

    [FunctionName("AsyncHttpPattern_Orchestrator")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var input = context.GetInput<string>();

        // Long-running operation
        var result = await context.CallActivityAsync<string>("LongRunningOperation", input);

        return result;
    }

    [FunctionName("LongRunningOperation")]
    public static async Task<string> LongRunningOperation([ActivityTrigger] string input, ILogger log)
    {
        log.LogInformation("Starting long-running operation");

        // Simulate long operation (e.g., data processing, external API calls)
        await Task.Delay(30000); // 30 seconds

        log.LogInformation("Long-running operation completed");
        return $"Processed: {input}";
    }

    [FunctionName("AsyncHttpPattern_GetStatus")]
    public static async Task<IActionResult> GetStatus(
        [HttpTrigger(AuthorizationLevel.Function, "get", Route = "status/{instanceId}")] HttpRequest req,
        [DurableClient] IDurableOrchestrationClient client,
        string instanceId,
        ILogger log)
    {
        var status = await client.GetStatusAsync(instanceId);

        if (status == null)
        {
            return new NotFoundObjectResult($"Instance {instanceId} not found");
        }

        return new OkObjectResult(new
        {
            instanceId = status.InstanceId,
            runtimeStatus = status.RuntimeStatus.ToString(),
            input = status.Input,
            output = status.Output,
            createdTime = status.CreatedTime,
            lastUpdatedTime = status.LastUpdatedTime
        });
    }
}
```

### Report Generation with Async HTTP

```csharp
public static class ReportGeneration
{
    [FunctionName("GenerateReport_HttpStart")]
    public static async Task<IActionResult> HttpStart(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
        [DurableClient] IDurableOrchestrationClient starter,
        ILogger log)
    {
        var reportRequest = await req.ReadAsAsync<ReportRequest>();

        string instanceId = await starter.StartNewAsync(
            "GenerateReport_Orchestrator",
            null,
            reportRequest);

        log.LogInformation($"Started report generation with ID = '{instanceId}'");

        return starter.CreateCheckStatusResponse(req, instanceId);
    }

    [FunctionName("GenerateReport_Orchestrator")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var request = context.GetInput<ReportRequest>();

        // Fetch data
        var data = await context.CallActivityAsync<ReportData>("FetchReportData", request);

        // Generate report
        var reportUrl = await context.CallActivityAsync<string>("GenerateReport", data);

        // Send notification
        await context.CallActivityAsync("SendReportNotification", new { request.Email, reportUrl });

        return reportUrl;
    }

    [FunctionName("FetchReportData")]
    public static async Task<ReportData> FetchReportData([ActivityTrigger] ReportRequest request, ILogger log)
    {
        log.LogInformation($"Fetching report data for {request.ReportType}");
        await Task.Delay(5000);
        return new ReportData();
    }

    [FunctionName("GenerateReport")]
    public static async Task<string> GenerateReport([ActivityTrigger] ReportData data, ILogger log)
    {
        log.LogInformation("Generating report");
        await Task.Delay(10000);
        return "https://storage.example.com/reports/report-123.pdf";
    }

    [FunctionName("SendReportNotification")]
    public static void SendReportNotification([ActivityTrigger] IDurableActivityContext context, ILogger log)
    {
        var input = context.GetInput<dynamic>();
        log.LogInformation($"Sending report to {input.Email}: {input.reportUrl}");
    }
}

public class ReportRequest
{
    public string ReportType { get; set; }
    public string Email { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
}

public class ReportData { }
```

> **AZ-204 Exam Tip:** Async HTTP APIs pattern:
> - Returns HTTP 202 (Accepted) immediately
> - Provides status query endpoints
> - Use `CreateCheckStatusResponse()` for standard response
> - Good for long-running operations (minutes to hours)

## Exercise 4: Monitor Pattern

**AZ-204 Pattern:** Recurring process until condition is met.

### Basic Monitor Pattern

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

public static class MonitorPattern
{
    [FunctionName("MonitorJobStatus")]
    public static async Task RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var jobId = context.GetInput<string>();
        var expiryTime = context.CurrentUtcDateTime.AddHours(1);

        while (context.CurrentUtcDateTime < expiryTime)
        {
            // Check job status
            var status = await context.CallActivityAsync<JobStatus>("CheckJobStatus", jobId);

            if (status.IsComplete)
            {
                // Job completed
                await context.CallActivityAsync("NotifyJobComplete", jobId);
                break;
            }

            if (status.IsFailed)
            {
                // Job failed
                await context.CallActivityAsync("NotifyJobFailed", jobId);
                break;
            }

            // Wait before next check
            var nextCheck = context.CurrentUtcDateTime.AddMinutes(5);
            await context.CreateTimer(nextCheck, CancellationToken.None);
        }

        // Timeout
        if (context.CurrentUtcDateTime >= expiryTime)
        {
            await context.CallActivityAsync("NotifyJobTimeout", jobId);
        }
    }

    [FunctionName("CheckJobStatus")]
    public static async Task<JobStatus> CheckJobStatus([ActivityTrigger] string jobId, ILogger log)
    {
        log.LogInformation($"Checking status of job {jobId}");

        // Call external API to check status
        await Task.Delay(100);

        return new JobStatus
        {
            IsComplete = false,
            IsFailed = false,
            Progress = 50
        };
    }

    [FunctionName("NotifyJobComplete")]
    public static void NotifyJobComplete([ActivityTrigger] string jobId, ILogger log)
    {
        log.LogInformation($"Job {jobId} completed successfully");
    }

    [FunctionName("NotifyJobFailed")]
    public static void NotifyJobFailed([ActivityTrigger] string jobId, ILogger log)
    {
        log.LogError($"Job {jobId} failed");
    }

    [FunctionName("NotifyJobTimeout")]
    public static void NotifyJobTimeout([ActivityTrigger] string jobId, ILogger log)
    {
        log.LogWarning($"Job {jobId} timed out");
    }
}

public class JobStatus
{
    public bool IsComplete { get; set; }
    public bool IsFailed { get; set; }
    public int Progress { get; set; }
}
```

### Weather Alert Monitor

```csharp
public static class WeatherMonitor
{
    [FunctionName("MonitorWeather")]
    public static async Task RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var location = context.GetInput<string>();
        var monitorDuration = TimeSpan.FromHours(6);
        var checkInterval = TimeSpan.FromMinutes(30);
        var expiryTime = context.CurrentUtcDateTime.Add(monitorDuration);

        while (context.CurrentUtcDateTime < expiryTime)
        {
            // Check weather conditions
            var weather = await context.CallActivityAsync<WeatherData>("CheckWeather", location);

            // Check for severe weather
            if (weather.Temperature > 100 || weather.Temperature < -20)
            {
                await context.CallActivityAsync("SendWeatherAlert", new
                {
                    location,
                    condition = "Extreme temperature",
                    temperature = weather.Temperature
                });
            }

            if (weather.WindSpeed > 50)
            {
                await context.CallActivityAsync("SendWeatherAlert", new
                {
                    location,
                    condition = "High winds",
                    windSpeed = weather.WindSpeed
                });
            }

            // Wait before next check
            var nextCheck = context.CurrentUtcDateTime.Add(checkInterval);
            await context.CreateTimer(nextCheck, CancellationToken.None);
        }
    }

    [FunctionName("CheckWeather")]
    public static async Task<WeatherData> CheckWeather([ActivityTrigger] string location, ILogger log)
    {
        log.LogInformation($"Checking weather for {location}");

        // Call weather API
        await Task.Delay(100);

        return new WeatherData
        {
            Temperature = 72,
            WindSpeed = 10,
            Conditions = "Sunny"
        };
    }

    [FunctionName("SendWeatherAlert")]
    public static void SendWeatherAlert([ActivityTrigger] IDurableActivityContext context, ILogger log)
    {
        var alert = context.GetInput<dynamic>();
        log.LogWarning($"WEATHER ALERT for {alert.location}: {alert.condition}");
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public double WindSpeed { get; set; }
    public string Conditions { get; set; }
}
```

> **AZ-204 Exam Tip:** Monitor pattern:
> - Periodic checking until condition met
> - Use `CreateTimer()` for delays (not Task.Delay!)
> - Set expiry time to prevent infinite loops
> - Good for polling external systems, health checks

## Exercise 5: Human Interaction Pattern

**AZ-204 Pattern:** Wait for external events or approvals.

### Approval Workflow

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

public static class ApprovalWorkflow
{
    [FunctionName("ExpenseApproval")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var expense = context.GetInput<ExpenseRequest>();

        // Auto-approve if under threshold
        if (expense.Amount < 1000)
        {
            await context.CallActivityAsync("ProcessExpense", expense);
            return "Auto-approved";
        }

        // Request approval
        await context.CallActivityAsync("RequestApproval", expense);

        // Wait for approval (with timeout)
        using (var cts = new CancellationTokenSource())
        {
            var approvalTask = context.WaitForExternalEvent<bool>("ApprovalEvent");
            var timeoutTask = context.CreateTimer(
                context.CurrentUtcDateTime.AddHours(24),
                cts.Token);

            var winner = await Task.WhenAny(approvalTask, timeoutTask);

            if (winner == approvalTask)
            {
                cts.Cancel(); // Cancel the timer

                if (await approvalTask)
                {
                    // Approved
                    await context.CallActivityAsync("ProcessExpense", expense);
                    await context.CallActivityAsync("NotifyApproval", expense);
                    return "Approved";
                }
                else
                {
                    // Rejected
                    await context.CallActivityAsync("NotifyRejection", expense);
                    return "Rejected";
                }
            }
            else
            {
                // Timeout
                await context.CallActivityAsync("NotifyTimeout", expense);
                return "Approval timeout";
            }
        }
    }

    [FunctionName("RequestApproval")]
    public static void RequestApproval([ActivityTrigger] ExpenseRequest expense, ILogger log)
    {
        log.LogInformation($"Requesting approval for expense: ${expense.Amount}");
        // Send email to approver with approval/rejection links
    }

    [FunctionName("ProcessExpense")]
    public static void ProcessExpense([ActivityTrigger] ExpenseRequest expense, ILogger log)
    {
        log.LogInformation($"Processing expense: ${expense.Amount}");
    }

    [FunctionName("NotifyApproval")]
    public static void NotifyApproval([ActivityTrigger] ExpenseRequest expense, ILogger log)
    {
        log.LogInformation($"Expense approved: ${expense.Amount}");
    }

    [FunctionName("NotifyRejection")]
    public static void NotifyRejection([ActivityTrigger] ExpenseRequest expense, ILogger log)
    {
        log.LogInformation($"Expense rejected: ${expense.Amount}");
    }

    [FunctionName("NotifyTimeout")]
    public static void NotifyTimeout([ActivityTrigger] ExpenseRequest expense, ILogger log)
    {
        log.LogWarning($"Expense approval timeout: ${expense.Amount}");
    }

    // HTTP endpoint to receive approval/rejection
    [FunctionName("SubmitApproval")]
    public static async Task<IActionResult> SubmitApproval(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = "approval/{instanceId}")] HttpRequest req,
        [DurableClient] IDurableOrchestrationClient client,
        string instanceId,
        ILogger log)
    {
        var approval = await req.ReadAsAsync<ApprovalResponse>();

        // Raise event to orchestration
        await client.RaiseEventAsync(instanceId, "ApprovalEvent", approval.Approved);

        return new OkObjectResult($"Approval {(approval.Approved ? "granted" : "denied")}");
    }
}

public class ExpenseRequest
{
    public string Id { get; set; }
    public decimal Amount { get; set; }
    public string Description { get; set; }
    public string RequestedBy { get; set; }
}

public class ApprovalResponse
{
    public bool Approved { get; set; }
    public string Comments { get; set; }
}
```

### Multi-Stage Approval

```csharp
public static class MultiStageApproval
{
    [FunctionName("MultiStageApproval")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var request = context.GetInput<ApprovalRequest>();

        // Stage 1: Manager approval
        await context.CallActivityAsync("RequestManagerApproval", request);
        var managerApproved = await context.WaitForExternalEvent<bool>("ManagerApproval");

        if (!managerApproved)
        {
            return "Rejected by manager";
        }

        // Stage 2: Director approval (for amounts > $10,000)
        if (request.Amount > 10000)
        {
            await context.CallActivityAsync("RequestDirectorApproval", request);
            var directorApproved = await context.WaitForExternalEvent<bool>("DirectorApproval");

            if (!directorApproved)
            {
                return "Rejected by director";
            }
        }

        // Stage 3: CFO approval (for amounts > $50,000)
        if (request.Amount > 50000)
        {
            await context.CallActivityAsync("RequestCFOApproval", request);
            var cfoApproved = await context.WaitForExternalEvent<bool>("CFOApproval");

            if (!cfoApproved)
            {
                return "Rejected by CFO";
            }
        }

        // All approvals received
        await context.CallActivityAsync("FinalizeApproval", request);
        return "Fully approved";
    }

    [FunctionName("RequestManagerApproval")]
    public static void RequestManagerApproval([ActivityTrigger] ApprovalRequest request, ILogger log)
    {
        log.LogInformation($"Requesting manager approval for ${request.Amount}");
    }

    [FunctionName("RequestDirectorApproval")]
    public static void RequestDirectorApproval([ActivityTrigger] ApprovalRequest request, ILogger log)
    {
        log.LogInformation($"Requesting director approval for ${request.Amount}");
    }

    [FunctionName("RequestCFOApproval")]
    public static void RequestCFOApproval([ActivityTrigger] ApprovalRequest request, ILogger log)
    {
        log.LogInformation($"Requesting CFO approval for ${request.Amount}");
    }

    [FunctionName("FinalizeApproval")]
    public static void FinalizeApproval([ActivityTrigger] ApprovalRequest request, ILogger log)
    {
        log.LogInformation($"Finalizing approval for ${request.Amount}");
    }
}

public class ApprovalRequest
{
    public string Id { get; set; }
    public decimal Amount { get; set; }
    public string Description { get; set; }
}
```

> **AZ-204 Exam Tip:** Human interaction pattern:
> - Use `WaitForExternalEvent<T>()` to wait for external input
> - Always set timeout with `CreateTimer()`
> - Use `RaiseEventAsync()` to send events from HTTP triggers
> - Good for approval workflows, manual interventions

## Exercise 6: Sub-Orchestrations

**AZ-204 Advanced Topic:** Compose complex workflows from smaller orchestrations.

### Sub-Orchestration Pattern

```csharp
public static class SubOrchestrations
{
    [FunctionName("MainOrchestration")]
    public static async Task<string> RunMainOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var customerId = context.GetInput<string>();

        // Call sub-orchestrations
        var orderResult = await context.CallSubOrchestratorAsync<string>(
            "ProcessOrder",
            $"order-{customerId}");

        var billingResult = await context.CallSubOrchestratorAsync<string>(
            "ProcessBilling",
            $"billing-{customerId}");

        var shippingResult = await context.CallSubOrchestratorAsync<string>(
            "ProcessShipping",
            $"shipping-{customerId}");

        return $"Completed: Order={orderResult}, Billing={billingResult}, Shipping={shippingResult}";
    }

    [FunctionName("ProcessOrder")]
    public static async Task<string> ProcessOrderOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var orderId = context.GetInput<string>();

        await context.CallActivityAsync("ValidateOrder", orderId);
        await context.CallActivityAsync("ReserveInventory", orderId);
        await context.CallActivityAsync("CreateOrder", orderId);

        return "Order processed";
    }

    [FunctionName("ProcessBilling")]
    public static async Task<string> ProcessBillingOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var billingId = context.GetInput<string>();

        await context.CallActivityAsync("ValidatePayment", billingId);
        await context.CallActivityAsync("ChargeCard", billingId);
        await context.CallActivityAsync("GenerateInvoice", billingId);

        return "Billing processed";
    }

    [FunctionName("ProcessShipping")]
    public static async Task<string> ProcessShippingOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var shippingId = context.GetInput<string>();

        await context.CallActivityAsync("CalculateShipping", shippingId);
        await context.CallActivityAsync("CreateShippingLabel", shippingId);
        await context.CallActivityAsync("SchedulePickup", shippingId);

        return "Shipping processed";
    }

    // Activity functions omitted for brevity
    [FunctionName("ValidateOrder")]
    public static void ValidateOrder([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Validating order: {input}");

    [FunctionName("ReserveInventory")]
    public static void ReserveInventory([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Reserving inventory: {input}");

    [FunctionName("CreateOrder")]
    public static void CreateOrder([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Creating order: {input}");

    [FunctionName("ValidatePayment")]
    public static void ValidatePayment([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Validating payment: {input}");

    [FunctionName("ChargeCard")]
    public static void ChargeCard([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Charging card: {input}");

    [FunctionName("GenerateInvoice")]
    public static void GenerateInvoice([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Generating invoice: {input}");

    [FunctionName("CalculateShipping")]
    public static void CalculateShipping([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Calculating shipping: {input}");

    [FunctionName("CreateShippingLabel")]
    public static void CreateShippingLabel([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Creating shipping label: {input}");

    [FunctionName("SchedulePickup")]
    public static void SchedulePickup([ActivityTrigger] string input, ILogger log)
        => log.LogInformation($"Scheduling pickup: {input}");
}
```

> **AZ-204 Exam Tip:** Sub-orchestrations:
> - Use `CallSubOrchestratorAsync()` to call another orchestrator
> - Good for modular, reusable workflows
> - Each sub-orchestration has its own instance ID
> - Can be called in parallel or sequentially

## Exercise 7: Durable Entities (Stateful Objects)

**AZ-204 Advanced Topic:** Stateful objects with operations.

### Counter Entity

```csharp
using Microsoft.Azure.WebJobs.Extensions.DurableTask;
using Newtonsoft.Json;
using System.Threading.Tasks;

[JsonObject(MemberSerialization.OptIn)]
public class Counter
{
    [JsonProperty("value")]
    public int Value { get; set; }

    public void Add(int amount) => Value += amount;
    public void Reset() => Value = 0;
    public int Get() => Value;

    [FunctionName(nameof(Counter))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<Counter>();
}

public static class CounterClient
{
    [FunctionName("CounterClient")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
        [DurableClient] IDurableEntityClient client,
        ILogger log)
    {
        var entityId = new EntityId(nameof(Counter), "myCounter");

        // Signal operations (fire and forget)
        await client.SignalEntityAsync(entityId, "Add", 10);
        await client.SignalEntityAsync(entityId, "Add", 5);

        // Read state
        var state = await client.ReadEntityStateAsync<Counter>(entityId);

        return new OkObjectResult(new
        {
            exists = state.EntityExists,
            value = state.EntityState?.Value
        });
    }
}
```

### Shopping Cart Entity

```csharp
[JsonObject(MemberSerialization.OptIn)]
public class ShoppingCart
{
    [JsonProperty("items")]
    public List<CartItem> Items { get; set; } = new List<CartItem>();

    [JsonProperty("total")]
    public decimal Total { get; set; }

    public void AddItem(CartItem item)
    {
        Items.Add(item);
        RecalculateTotal();
    }

    public void RemoveItem(string productId)
    {
        Items.RemoveAll(i => i.ProductId == productId);
        RecalculateTotal();
    }

    public void Clear()
    {
        Items.Clear();
        Total = 0;
    }

    public CartSummary GetSummary()
    {
        return new CartSummary
        {
            ItemCount = Items.Count,
            Total = Total,
            Items = Items
        };
    }

    private void RecalculateTotal()
    {
        Total = Items.Sum(i => i.Price * i.Quantity);
    }

    [FunctionName(nameof(ShoppingCart))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<ShoppingCart>();
}

public class CartItem
{
    public string ProductId { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Quantity { get; set; }
}

public class CartSummary
{
    public int ItemCount { get; set; }
    public decimal Total { get; set; }
    public List<CartItem> Items { get; set; }
}

public static class ShoppingCartClient
{
    [FunctionName("ShoppingCartOperations")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = "cart/{userId}/{action}")] HttpRequest req,
        [DurableClient] IDurableEntityClient client,
        string userId,
        string action,
        ILogger log)
    {
        var entityId = new EntityId(nameof(ShoppingCart), userId);

        switch (action.ToLower())
        {
            case "add":
                var item = await req.ReadAsAsync<CartItem>();
                await client.SignalEntityAsync(entityId, "AddItem", item);
                return new OkObjectResult("Item added");

            case "remove":
                var productId = req.Query["productId"];
                await client.SignalEntityAsync(entityId, "RemoveItem", productId);
                return new OkObjectResult("Item removed");

            case "clear":
                await client.SignalEntityAsync(entityId, "Clear");
                return new OkObjectResult("Cart cleared");

            case "get":
                var state = await client.ReadEntityStateAsync<ShoppingCart>(entityId);
                if (!state.EntityExists)
                {
                    return new NotFoundResult();
                }
                var summary = state.EntityState.GetSummary();
                return new OkObjectResult(summary);

            default:
                return new BadRequestObjectResult("Invalid action");
        }
    }
}
```

### Entity Locking Pattern

```csharp
public static class EntityLocking
{
    [FunctionName("TransferFunds")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        var transfer = context.GetInput<FundTransfer>();

        var fromAccount = new EntityId(nameof(BankAccount), transfer.FromAccountId);
        var toAccount = new EntityId(nameof(BankAccount), transfer.ToAccountId);

        // Lock both accounts (in order to prevent deadlock)
        using (await context.LockAsync(fromAccount, toAccount))
        {
            // Withdraw from source account
            await context.CallEntityAsync(fromAccount, "Withdraw", transfer.Amount);

            // Deposit to destination account
            await context.CallEntityAsync(toAccount, "Deposit", transfer.Amount);
        }

        return "Transfer completed";
    }
}

[JsonObject(MemberSerialization.OptIn)]
public class BankAccount
{
    [JsonProperty("balance")]
    public decimal Balance { get; set; }

    public void Deposit(decimal amount)
    {
        Balance += amount;
    }

    public void Withdraw(decimal amount)
    {
        if (Balance < amount)
        {
            throw new InvalidOperationException("Insufficient funds");
        }
        Balance -= amount;
    }

    public decimal GetBalance() => Balance;

    [FunctionName(nameof(BankAccount))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<BankAccount>();
}

public class FundTransfer
{
    public string FromAccountId { get; set; }
    public string ToAccountId { get; set; }
    public decimal Amount { get; set; }
}
```

> **AZ-204 Exam Tip:** Durable entities:
> - Stateful objects with operations
> - `SignalEntityAsync()` for fire-and-forget operations
> - `CallEntityAsync()` from orchestrators for transactional operations
> - `ReadEntityStateAsync()` to read current state
> - Use locking to prevent concurrent modifications

## Exercise 8: Orchestrator Constraints and Best Practices

**AZ-204 Critical Knowledge:** Understanding what you can and cannot do in orchestrators.

### Orchestrator Constraints

```csharp
public static class OrchestratorConstraints
{
    [FunctionName("CorrectOrchestrator")]
    public static async Task<string> CorrectOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        // ✅ CORRECT: Use context.CurrentUtcDateTime
        var currentTime = context.CurrentUtcDateTime;

        // ✅ CORRECT: Use context.NewGuid()
        var uniqueId = context.NewGuid();

        // ✅ CORRECT: Call activities for non-deterministic operations
        var randomNumber = await context.CallActivityAsync<int>("GenerateRandomNumber", null);

        // ✅ CORRECT: Use CreateTimer for delays
        var deadline = context.CurrentUtcDateTime.AddMinutes(5);
        await context.CreateTimer(deadline, CancellationToken.None);

        // ✅ CORRECT: Read input
        var input = context.GetInput<string>();

        return $"ID: {uniqueId}, Time: {currentTime}, Random: {randomNumber}";
    }

    // ❌ ANTI-PATTERNS (DO NOT USE)
    public static async Task<string> IncorrectOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context)
    {
        // ❌ WRONG: Don't use DateTime.Now or DateTime.UtcNow
        // var now = DateTime.UtcNow; // This will cause non-deterministic replay issues

        // ❌ WRONG: Don't use Guid.NewGuid()
        // var id = Guid.NewGuid(); // Use context.NewGuid() instead

        // ❌ WRONG: Don't use Random
        // var random = new Random().Next(); // Non-deterministic

        // ❌ WRONG: Don't use Task.Delay
        // await Task.Delay(1000); // Use context.CreateTimer instead

        // ❌ WRONG: Don't make HTTP calls directly
        // var response = await httpClient.GetAsync("..."); // Call activity instead

        // ❌ WRONG: Don't access databases directly
        // var data = await dbContext.Users.ToListAsync(); // Call activity instead

        // ❌ WRONG: Don't write to console/logs directly
        // Console.WriteLine("Message"); // Use ILogger in activities

        return "This orchestrator has anti-patterns!";
    }

    [FunctionName("GenerateRandomNumber")]
    public static int GenerateRandomNumber([ActivityTrigger] IDurableActivityContext context, ILogger log)
    {
        // ✅ Non-deterministic operations belong in activities
        return new Random().Next(1, 100);
    }
}
```

### Why Orchestrators Must Be Deterministic

```csharp
public static class DeterminismExample
{
    [FunctionName("DeterministicExample")]
    public static async Task<string> RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context,
        ILogger log)
    {
        // Orchestrator code is REPLAYED every time it resumes
        // Each replay must produce the same results

        // First execution:
        // 1. Calls Activity1 -> writes to history
        // 2. Waits

        // Second execution (after Activity1 completes):
        // 1. Replays from start
        // 2. Reads Activity1 result from history (doesn't re-execute)
        // 3. Calls Activity2 -> writes to history
        // 4. Waits

        var result1 = await context.CallActivityAsync<string>("Activity1", null);
        var result2 = await context.CallActivityAsync<string>("Activity2", result1);

        return result2;
    }
}
```

### Logging in Orchestrators

```csharp
public static class OrchestratorLogging
{
    [FunctionName("LoggingExample")]
    public static async Task RunOrchestrator(
        [OrchestrationTrigger] IDurableOrchestrationContext context,
        ILogger log)
    {
        // ⚠️ WARNING: Orchestrator code is replayed
        // Logging will happen on every replay
        if (!context.IsReplaying)
        {
            log.LogInformation("Orchestrator started (first execution only)");
        }

        var result = await context.CallActivityAsync<string>("DoWork", null);

        if (!context.IsReplaying)
        {
            log.LogInformation($"Work completed: {result}");
        }
    }
}
```

> **AZ-204 Exam Tip:** Orchestrator rules:
> - Must be **deterministic** (same inputs = same outputs)
> - Use `context.CurrentUtcDateTime` not `DateTime.Now`
> - Use `context.NewGuid()` not `Guid.NewGuid()`
> - Use `context.CreateTimer()` not `Task.Delay()`
> - Use activities for I/O, random numbers, HTTP calls
> - Code is replayed on every resume
> - Check `context.IsReplaying` before logging

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Durable Functions Patterns:**
   - **Function Chaining**: Sequential execution, output → input
   - **Fan-out/Fan-in**: Parallel execution, aggregate results
   - **Async HTTP APIs**: Long-running with status polling
   - **Monitor**: Recurring checks until condition met
   - **Human Interaction**: Wait for external events
   - **Aggregator (Stateful Entity)**: Stateful objects

2. **Function Types:**
   - **Orchestrator**: Coordinates workflow, must be deterministic
   - **Activity**: Performs actual work, can be non-deterministic
   - **Client**: Starts orchestrations, queries status
   - **Entity**: Stateful object with operations

3. **Orchestrator Constraints:**
   - Must be deterministic (replayed on resume)
   - No direct I/O operations
   - Use `context.CurrentUtcDateTime` not `DateTime.Now`
   - Use `context.NewGuid()` not `Guid.NewGuid()`
   - Use `context.CreateTimer()` not `Task.Delay()`
   - No random numbers, HTTP calls, database access

4. **Client Operations:**
   - `StartNewAsync()`: Start new orchestration
   - `GetStatusAsync()`: Get orchestration status
   - `RaiseEventAsync()`: Send event to running orchestration
   - `TerminateAsync()`: Terminate orchestration
   - `PurgeInstanceHistoryAsync()`: Clean up history

5. **Entity Operations:**
   - `SignalEntityAsync()`: Fire-and-forget operation
   - `CallEntityAsync()`: Call from orchestrator (transactional)
   - `ReadEntityStateAsync()`: Read current state
   - `LockAsync()`: Lock entities to prevent concurrent access

6. **Runtime Status:**
   - Running, Completed, Failed, Terminated
   - Pending, ContinuedAsNew
   - Check status with `GetStatusAsync()`

### Common Exam Scenarios

1. **Scenario:** Process order with payment, inventory, shipping steps
   - **Solution:** Function chaining pattern

2. **Scenario:** Process 1000 files in parallel and aggregate results
   - **Solution:** Fan-out/fan-in pattern

3. **Scenario:** Generate large report that takes 30 minutes
   - **Solution:** Async HTTP APIs pattern

4. **Scenario:** Wait for manager approval before proceeding
   - **Solution:** Human interaction pattern with `WaitForExternalEvent()`

5. **Scenario:** Check external API every 5 minutes until job completes
   - **Solution:** Monitor pattern with `CreateTimer()`

6. **Scenario:** Orchestrator needs current time
   - **Solution:** Use `context.CurrentUtcDateTime` not `DateTime.Now`

7. **Scenario:** Orchestrator needs random number
   - **Solution:** Call activity function with `Random` logic

8. **Scenario:** Maintain shopping cart state across multiple requests
   - **Solution:** Durable entity

### Durable Functions Architecture

```
Client Function (HTTP Trigger)
    ↓
Start Orchestration
    ↓
Orchestrator Function
    ├→ Activity 1
    ├→ Activity 2 (parallel)
    ├→ Activity 3 (parallel)
    ├→ Sub-Orchestration
    └→ Wait for External Event
    ↓
Return Result
```

### Storage Requirements

Durable Functions require storage account for:
- Orchestration state
- Work items queue
- Instance history
- Entity state

Configuration:
```json
{
  "Values": {
    "AzureWebJobsStorage": "DefaultEndpointsProtocol=https;AccountName=..."
  }
}
```

## Best Practices

1. **Keep orchestrators deterministic** - no I/O, use context methods
2. **Use activities for non-deterministic work** - I/O, random, HTTP calls
3. **Set timeouts** on external events and timers
4. **Check `context.IsReplaying`** before logging in orchestrators
5. **Use sub-orchestrations** for modularity and reusability
6. **Implement error handling** with try-catch in orchestrators
7. **Use retry policies** on activities for resilience
8. **Clean up history** periodically with `PurgeInstanceHistoryAsync()`
9. **Use entities for stateful scenarios** instead of databases
10. **Monitor with Application Insights** for visibility

## Anti-Patterns to Avoid

1. ❌ Using `DateTime.Now` in orchestrators
2. ❌ Using `Guid.NewGuid()` in orchestrators
3. ❌ Using `Task.Delay()` in orchestrators
4. ❌ Making HTTP calls directly from orchestrators
5. ❌ Accessing databases directly from orchestrators
6. ❌ Using `Random` in orchestrators
7. ❌ Writing to console/files from orchestrators
8. ❌ Infinite loops without timeouts
9. ❌ Large inputs/outputs (>60KB)
10. ❌ Long-running activities (>5 minutes without checkpointing)

## Additional Resources

- [Durable Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/durable/)
- [Durable Functions patterns](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp#application-patterns)
- [Durable entities](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-entities)
- [Orchestrator code constraints](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-code-constraints)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)

## Cleanup

```bash
az group delete -y -n labs-functions-durable --no-wait
```
