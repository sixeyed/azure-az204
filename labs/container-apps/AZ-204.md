# Azure Container Apps - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop Azure Compute Solutions (25-30%)

This lab extends the basic Container Apps exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Container Apps lab](README.md) first to understand fundamental Container Apps operations.

## AZ-204 Exam Skills Covered

- Create and implement solutions using Azure Container Apps
- Configure scaling (HTTP, CPU, memory, custom metrics)
- Manage revisions and traffic splitting
- Configure ingress and service discovery
- Implement Dapr integration basics
- Configure secrets and environment variables
- Container Apps vs ACI vs AKS decision-making

## Exercise 1: Container Apps Environment

**AZ-204 Critical Topic:** Environments provide isolation and shared resources.

### Create Environment with Log Analytics

```bash
az group create -n labs-containerapp-az204 --tags courselabs=azure -l eastus

# Create Log Analytics workspace
az monitor log-analytics workspace create \
  -g labs-containerapp-az204 \
  -n container-apps-logs \
  -l eastus

# Get workspace ID and key
LOG_ANALYTICS_WORKSPACE_ID=$(az monitor log-analytics workspace show \
  -g labs-containerapp-az204 \
  -n container-apps-logs \
  --query customerId -o tsv)

LOG_ANALYTICS_KEY=$(az monitor log-analytics workspace get-shared-keys \
  -g labs-containerapp-az204 \
  -n container-apps-logs \
  --query primarySharedKey -o tsv)

# Create Container Apps environment with logging
az containerapp env create \
  -g labs-containerapp-az204 \
  -n production-env \
  -l eastus \
  --logs-workspace-id $LOG_ANALYTICS_WORKSPACE_ID \
  --logs-workspace-key $LOG_ANALYTICS_KEY
```

> **AZ-204 Exam Tip:** Container Apps Environment:
> - **Boundary**: Groups related container apps
> - **Virtual Network**: Apps in same environment can communicate privately
> - **Log Analytics**: Centralized logging for all apps
> - **Dapr**: Shared Dapr configuration
> - **Scaling**: Environment provides shared compute resources

## Exercise 2: Deploy Container App with Configuration

**AZ-204 Critical Topic:** Comprehensive app configuration.

### Create Container App with Full Configuration

```bash
az containerapp create \
  -g labs-containerapp-az204 \
  -n api-service \
  --environment production-env \
  --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
  --target-port 80 \
  --ingress external \
  --min-replicas 2 \
  --max-replicas 10 \
  --cpu 0.5 \
  --memory 1.0Gi \
  --env-vars \
    "APP_ENV=production" \
    "LOG_LEVEL=info" \
  --query properties.configuration.ingress.fqdn
```

**Key Configuration Parameters:**
- **target-port**: Container's listening port
- **ingress**: `external` (internet) or `internal` (environment only)
- **cpu**: 0.25 to 4.0 cores
- **memory**: 0.5Gi to 8Gi
- **min-replicas/max-replicas**: Scaling boundaries

ðŸ“‹ Create a container app that is only accessible internally within the environment.

<details>
  <summary>Not sure how?</summary>

```bash
az containerapp create \
  -g labs-containerapp-az204 \
  -n internal-service \
  --environment production-env \
  --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
  --target-port 80 \
  --ingress internal \
  --min-replicas 1 \
  --max-replicas 3
```

Internal apps get a DNS name within the environment: `internal-service.internal.<environment-unique-identifier>.eastus.azurecontainerapps.io`

</details><br/>

## Exercise 3: Scaling Rules

**AZ-204 Critical Topic:** Multiple scaling trigger types.

### HTTP Scaling (Concurrent Requests)

```bash
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --min-replicas 1 \
  --max-replicas 10 \
  --scale-rule-name http-scale \
  --scale-rule-type http \
  --scale-rule-http-concurrency 100
```

This scales based on concurrent HTTP requests per replica.

### CPU Scaling

```bash
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --scale-rule-name cpu-scale \
  --scale-rule-type cpu \
  --scale-rule-metadata "type=Utilization" "value=70"
```

Scales when CPU utilization exceeds 70%.

### Memory Scaling

```bash
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --scale-rule-name memory-scale \
  --scale-rule-type memory \
  --scale-rule-metadata "type=Utilization" "value=80"
```

### Azure Queue Scaling (Custom)

```bash
# Scale based on Azure Storage Queue depth
az containerapp update \
  -g labs-containerapp-az204 \
  -n queue-processor \
  --scale-rule-name queue-scale \
  --scale-rule-type azure-queue \
  --scale-rule-metadata \
    "queueName=orders" \
    "queueLength=10" \
    "accountName=mystorageaccount" \
  --scale-rule-auth "connection=connection-string-secret"
```

### Scale to Zero

```bash
# Enable scale to zero
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --min-replicas 0 \
  --max-replicas 10
```

> **AZ-204 Exam Tip:** Scale triggers:
> - **HTTP**: Concurrent requests per replica
> - **CPU**: Percentage utilization
> - **Memory**: Percentage utilization
> - **Azure Queue**: Queue message count
> - **Azure Service Bus**: Queue/topic message count
> - **Custom (KEDA)**: Prometheus, Kafka, RabbitMQ, etc.

## Exercise 4: Revisions and Traffic Management

**AZ-204 Critical Topic:** Zero-downtime deployments and A/B testing.

### Create Named Revision

```bash
# Update with new image and create named revision
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
  --revision-suffix v2
```

### List Revisions

```bash
az containerapp revision list \
  -g labs-containerapp-az204 \
  -n api-service \
  -o table
```

### Traffic Splitting

```bash
# Get revision names
REVISION_V1="api-service--v1"
REVISION_V2="api-service--v2"

# Split traffic: 90% v1, 10% v2 (canary)
az containerapp ingress traffic set \
  -g labs-containerapp-az204 \
  -n api-service \
  --revision-weight "$REVISION_V1=90" "$REVISION_V2=10"

# After testing, shift to 100% v2
az containerapp ingress traffic set \
  -g labs-containerapp-az204 \
  -n api-service \
  --revision-weight "$REVISION_V2=100"
```

### Revision Modes

```bash
# Single revision mode (default) - automatic traffic to latest
az containerapp create \
  -g labs-containerapp-az204 \
  -n single-revision-app \
  --environment production-env \
  --image myimage:latest \
  --ingress external \
  --target-port 80 \
  --revisions-mode single

# Multiple revision mode - manual traffic management
az containerapp create \
  -g labs-containerapp-az204 \
  -n multi-revision-app \
  --environment production-env \
  --image myimage:latest \
  --ingress external \
  --target-port 80 \
  --revisions-mode multiple
```

> **AZ-204 Exam Tip:** Revision strategies:
> - **Blue-Green**: Deploy new revision, test, switch 100% traffic
> - **Canary**: Gradually increase traffic (10% â†’ 50% â†’ 100%)
> - **A/B Testing**: Split traffic between versions for comparison
> - **Rollback**: Instantly shift traffic back to previous revision

## Exercise 5: Secrets and Environment Variables

**AZ-204 Topic:** Secure configuration management.

### Add Secrets

```bash
# Add secrets
az containerapp secret set \
  -g labs-containerapp-az204 \
  -n api-service \
  --secrets \
    "db-connection=Server=myserver;Database=mydb;Password=P@ssw0rd" \
    "api-key=sk-1234567890abcdef"

# List secrets (values hidden)
az containerapp secret list \
  -g labs-containerapp-az204 \
  -n api-service \
  -o table
```

### Reference Secrets in Environment Variables

```bash
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --set-env-vars \
    "DatabaseConnection=secretref:db-connection" \
    "ExternalApiKey=secretref:api-key" \
    "AppEnvironment=production" \
    "LogLevel=info"
```

> **AZ-204 Exam Tip:** Secret syntax:
> - `secretref:<secret-name>` - References a secret
> - Plain string - Regular environment variable
> - Secrets are encrypted at rest
> - Can reference secrets from Key Vault (via managed identity)

### Update Secret

```bash
# Update secret value
az containerapp secret set \
  -g labs-containerapp-az204 \
  -n api-service \
  --secrets "api-key=sk-new-key-9876543210" \
  --replace

# Restart to pick up new secret
az containerapp revision restart \
  -g labs-containerapp-az204 \
  -n api-service \
  --revision <revision-name>
```

## Exercise 6: Container Registry Integration

**AZ-204 Topic:** Use private container registries.

### Using Azure Container Registry

```bash
# Create ACR
az acr create \
  -g labs-containerapp-az204 \
  -n <acr-name> \
  --sku Basic \
  --admin-enabled true

# Get ACR credentials
ACR_SERVER=$(az acr show -n <acr-name> --query loginServer -o tsv)
ACR_USERNAME=$(az acr credential show -n <acr-name> --query username -o tsv)
ACR_PASSWORD=$(az acr credential show -n <acr-name> --query passwords[0].value -o tsv)

# Store ACR password as secret
az containerapp secret set \
  -g labs-containerapp-az204 \
  -n api-service \
  --secrets "acr-password=$ACR_PASSWORD"

# Create container app with ACR image
az containerapp create \
  -g labs-containerapp-az204 \
  -n acr-app \
  --environment production-env \
  --image $ACR_SERVER/myapp:v1 \
  --registry-server $ACR_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --target-port 80 \
  --ingress external
```

### Using Managed Identity with ACR

```bash
# Enable system-assigned managed identity
az containerapp identity assign \
  -g labs-containerapp-az204 \
  -n acr-app \
  --system-assigned

# Get identity principal ID
PRINCIPAL_ID=$(az containerapp identity show \
  -g labs-containerapp-az204 \
  -n acr-app \
  --query principalId -o tsv)

# Grant ACR pull permission
az role assignment create \
  --assignee $PRINCIPAL_ID \
  --role AcrPull \
  --scope $(az acr show -n <acr-name> --query id -o tsv)

# Update to use managed identity (no credentials needed)
az containerapp registry set \
  -g labs-containerapp-az204 \
  -n acr-app \
  --server $ACR_SERVER \
  --identity system
```

## Exercise 7: Dapr Integration

**AZ-204 Topic:** Dapr (Distributed Application Runtime) simplifies microservices.

### Enable Dapr

```bash
az containerapp create \
  -g labs-containerapp-az204 \
  -n dapr-app \
  --environment production-env \
  --image myapp:latest \
  --target-port 80 \
  --ingress internal \
  --enable-dapr \
  --dapr-app-id order-service \
  --dapr-app-port 80 \
  --dapr-app-protocol http
```

### Dapr Service Invocation

```bash
# Call another Dapr-enabled service
curl http://localhost:3500/v1.0/invoke/order-service/method/api/orders
```

> **AZ-204 Exam Tip:** Dapr provides:
> - Service-to-service invocation
> - State management
> - Pub/sub messaging
> - Bindings to external systems
> - Secrets management
> - Observability

## Exercise 8: Monitoring and Logging

**AZ-204 Topic:** Query logs with Log Analytics.

### Query Container Logs

```bash
# Get Log Analytics workspace ID
WORKSPACE_ID=$(az monitor log-analytics workspace show \
  -g labs-containerapp-az204 \
  -n container-apps-logs \
  --query customerId -o tsv)

# Query logs (use Azure Portal or CLI)
az monitor log-analytics query \
  -w $WORKSPACE_ID \
  --analytics-query "ContainerAppConsoleLogs_CL | where ContainerAppName_s == 'api-service' | take 100"
```

### Application Insights Integration

```bash
# Create Application Insights
az monitor app-insights component create \
  -g labs-containerapp-az204 \
  --app container-apps-insights \
  -l eastus \
  --workspace $(az monitor log-analytics workspace show \
    -g labs-containerapp-az204 \
    -n container-apps-logs \
    --query id -o tsv)

# Get instrumentation key
INSTRUMENTATION_KEY=$(az monitor app-insights component show \
  -g labs-containerapp-az204 \
  --app container-apps-insights \
  --query instrumentationKey -o tsv)

# Add to container app
az containerapp update \
  -g labs-containerapp-az204 \
  -n api-service \
  --set-env-vars "APPLICATIONINSIGHTS_CONNECTION_STRING=InstrumentationKey=$INSTRUMENTATION_KEY"
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Container Apps vs Alternatives:**
   - **vs ACI**: Container Apps have auto-scaling, load balancing, revisions
   - **vs AKS**: Container Apps abstract Kubernetes complexity
   - **vs App Service**: Container Apps better for microservices, AKS-level features
   - **vs Functions**: Container Apps for longer-running processes, any runtime

2. **Scaling:**
   - HTTP (concurrent requests)
   - CPU/Memory utilization
   - Queue depth (Storage, Service Bus)
   - Custom metrics (KEDA scalers)
   - Scale to zero for cost savings

3. **Revisions:**
   - Immutable snapshots of app configuration
   - Single mode: Auto traffic to latest
   - Multiple mode: Manual traffic splitting
   - Enable blue-green, canary, A/B testing

4. **Ingress:**
   - **External**: Internet-accessible
   - **Internal**: Environment-only
   - Automatic HTTPS with managed certificates
   - Traffic splitting across revisions

5. **Configuration:**
   - Environment variables (plain text)
   - Secrets (encrypted, can reference)
   - Container registry integration
   - Managed identity support

### Common Exam Scenarios

1. **Scenario:** Deploy microservices that auto-scale based on HTTP load
   - **Solution:** Container Apps with HTTP scaling rule

2. **Scenario:** Zero-downtime deployment of new version
   - **Solution:** Multiple revision mode, deploy v2, test, shift traffic gradually

3. **Scenario:** Process queue messages with auto-scaling
   - **Solution:** Container Apps with Azure Queue scaling rule, scale to 0 when empty

4. **Scenario:** Secure inter-service communication
   - **Solution:** Internal ingress + Dapr service invocation

5. **Scenario:** Choose between Container Apps, ACI, and AKS
   - **Solution:**
     - **ACI**: Single container, batch jobs, simple scenarios
     - **Container Apps**: Microservices, HTTP services, need auto-scaling
     - **AKS**: Need full Kubernetes control, complex networking, specific K8s features

## Decision Tree: When to Use Container Apps

```
Need to run containers?
â”œâ”€ Simple single container, no scaling needed
â”‚  â””â”€ Use: Azure Container Instances (ACI)
â”œâ”€ Microservices, HTTP APIs, auto-scaling
â”‚  â””â”€ Use: Azure Container Apps âœ“
â”œâ”€ Need full Kubernetes features (DaemonSets, StatefulSets, etc.)
â”‚  â””â”€ Use: Azure Kubernetes Service (AKS)
â””â”€ Event-driven functions, sub-second execution
   â””â”€ Use: Azure Functions
```

## Best Practices

1. **Use managed identity** for ACR and other Azure services
2. **Enable scale to zero** for cost optimization
3. **Use multiple revision mode** for production deployments
4. **Implement health probes** for reliability
5. **Use internal ingress** for backend services
6. **Store secrets** properly, never in environment variables
7. **Enable logging** to Log Analytics from the start
8. **Use Dapr** for service-to-service communication
9. **Tag revisions** with meaningful suffixes (v1, v2, commit-hash)
10. **Monitor** with Application Insights

## Cleanup

```bash
az group delete -y -n labs-containerapp-az204 --no-wait
```

## Additional Resources

- [Azure Container Apps documentation](https://docs.microsoft.com/en-us/azure/container-apps/)
- [Container Apps samples](https://github.com/Azure-Samples/container-apps-samples)
- [Dapr documentation](https://docs.dapr.io/)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
