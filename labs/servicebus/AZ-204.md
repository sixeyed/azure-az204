# Azure Service Bus - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Connect to and Consume Azure Services (20-25%)

This lab extends the basic Service Bus exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Service Bus lab](README.md) first to understand fundamental Service Bus operations.

## AZ-204 Exam Skills Covered

- Implement solutions that use Azure Service Bus queues
- Implement solutions that use Azure Service Bus topics and subscriptions
- Message sessions for FIFO processing
- Dead-letter queues
- Message deferral and scheduling
- Transactions and duplicate detection

## Exercise 1: Service Bus Queues

**AZ-204 Critical Topic:** Queues provide point-to-point messaging with FIFO guarantee.

### Create Service Bus Namespace and Queue

```bash
az group create -n labs-servicebus-az204 --tags courselabs=azure -l eastus

# Create Service Bus namespace (Standard tier for topics/subscriptions)
az servicebus namespace create \
  -g labs-servicebus-az204 \
  -n <servicebus-namespace> \
  --sku Standard \
  -l eastus

# Create queue
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-queue \
  --max-size 1024 \
  --default-message-time-to-live P14D \
  --enable-dead-lettering-on-message-expiration true
```

Get connection string:

```bash
az servicebus namespace authorization-rule keys list \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name RootManageSharedAccessKey \
  --query primaryConnectionString -o tsv
```

> **AZ-204 Exam Tip:** Service Bus tiers:
> - **Basic**: Queues only, 256 KB max message size
> - **Standard**: Queues and topics, 256 KB, variable pricing
> - **Premium**: High throughput, 1 MB messages, dedicated resources

### Send and Receive Messages with .NET SDK

```csharp
using Azure.Messaging.ServiceBus;

string connectionString = "<connection-string>";
string queueName = "orders-queue";

// Create client
await using var client = new ServiceBusClient(connectionString);

// SEND MESSAGES
await using ServiceBusSender sender = client.CreateSender(queueName);

// Send single message
ServiceBusMessage message = new ServiceBusMessage("Order #12345");
message.ContentType = "application/json";
message.MessageId = Guid.NewGuid().ToString();
message.ApplicationProperties.Add("priority", "high");
await sender.SendMessageAsync(message);

// Send batch of messages
var messageBatch = await sender.CreateMessageBatchAsync();
for (int i = 1; i <= 10; i++)
{
    var msg = new ServiceBusMessage($"Order #{i}");
    if (!messageBatch.TryAddMessage(msg))
    {
        await sender.SendMessagesAsync(messageBatch);
        messageBatch = await sender.CreateMessageBatchAsync();
        messageBatch.TryAddMessage(msg);
    }
}
if (messageBatch.Count > 0)
{
    await sender.SendMessagesAsync(messageBatch);
}

// RECEIVE MESSAGES
await using ServiceBusReceiver receiver = client.CreateReceiver(queueName);

// Receive single message
ServiceBusReceivedMessage receivedMessage = await receiver.ReceiveMessageAsync(
    maxWaitTime: TimeSpan.FromSeconds(5));

if (receivedMessage != null)
{
    Console.WriteLine($"Received: {receivedMessage.Body}");
    Console.WriteLine($"MessageId: {receivedMessage.MessageId}");

    // Complete the message (remove from queue)
    await receiver.CompleteMessageAsync(receivedMessage);
}

// Receive messages in a loop
await foreach (ServiceBusReceivedMessage msg in receiver.ReceiveMessagesAsync())
{
    Console.WriteLine($"Processing: {msg.Body}");
    await receiver.CompleteMessageAsync(msg);
}
```

> **AZ-204 Exam Tip:** Message settlement modes:
> - **PeekLock** (default): Lock message while processing, must explicitly complete
> - **ReceiveAndDelete**: Automatically removes message on receive (no retry if processing fails)

## Exercise 2: Topics and Subscriptions

**AZ-204 Critical Topic:** Topics enable pub/sub pattern with message filtering.

### Create Topic and Subscriptions

```bash
# Create topic
az servicebus topic create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name notifications

# Create subscription with filter
az servicebus topic subscription create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --name high-priority-sub

# Add SQL filter to subscription
az servicebus topic subscription rule create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --subscription-name high-priority-sub \
  --name HighPriorityFilter \
  --filter-sql-expression "priority='high'"

# Create another subscription for all messages
az servicebus topic subscription create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --name all-messages-sub
```

ðŸ“‹ Create a subscription that only receives messages where `region='east'`.

<details>
  <summary>Not sure how?</summary>

```bash
az servicebus topic subscription create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --name east-region-sub

az servicebus topic subscription rule create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --topic-name notifications \
  --subscription-name east-region-sub \
  --name EastRegionFilter \
  --filter-sql-expression "region='east'"
```

</details><br/>

### Publish and Subscribe

```csharp
// Publish to topic
await using var sender = client.CreateSender("notifications");

var message = new ServiceBusMessage("System alert");
message.ApplicationProperties.Add("priority", "high");
message.ApplicationProperties.Add("region", "east");
await sender.SendMessageAsync(message);

// Subscribe from specific subscription
await using var receiver = client.CreateReceiver(
    "notifications",
    "high-priority-sub");

var receivedMsg = await receiver.ReceiveMessageAsync();
Console.WriteLine($"Received: {receivedMsg.Body}");
await receiver.CompleteMessageAsync(receivedMsg);
```

> **AZ-204 Exam Tip:** Filter types:
> - **SQL Filters**: `priority='high' AND region='east'`
> - **Correlation Filters**: Match specific property values (more efficient than SQL)
> - **Boolean Filters**: TrueFilter (all messages) or FalseFilter (no messages)

## Exercise 3: Message Sessions (FIFO)

**AZ-204 Topic:** Sessions guarantee FIFO ordering and enable stateful processing.

### Create Session-Enabled Queue

```bash
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-session-queue \
  --enable-session true
```

### Send Session Messages

```csharp
await using var sender = client.CreateSender("orders-session-queue");

string sessionId = "customer-123";

// Send messages with same session ID (processed in order)
for (int i = 1; i <= 5; i++)
{
    var message = new ServiceBusMessage($"Order step {i}");
    message.SessionId = sessionId;
    await sender.SendMessageAsync(message);
}
```

### Receive Session Messages

```csharp
await using var sessionReceiver = await client.AcceptSessionAsync(
    "orders-session-queue",
    sessionId);

// Get session state
byte[] state = await sessionReceiver.GetSessionStateAsync();

await foreach (var message in sessionReceiver.ReceiveMessagesAsync())
{
    Console.WriteLine($"Session {message.SessionId}: {message.Body}");
    await sessionReceiver.CompleteMessageAsync(message);
}

// Set session state
await sessionReceiver.SetSessionStateAsync(
    BinaryData.FromString("Processing completed"));
```

> **AZ-204 Exam Tip:** Use sessions when:
> - FIFO ordering is required
> - Related messages need to be processed together
> - Stateful processing is needed
> - Load balancing across consumers by session ID

## Exercise 4: Dead-Letter Queue (DLQ)

**AZ-204 Critical Topic:** DLQ stores messages that can't be processed.

### Messages Move to DLQ When:
1. Max delivery count exceeded
2. Message TTL expired (if enabled)
3. Explicitly dead-lettered by code

```csharp
// Abandon message (increments delivery count)
await receiver.AbandonMessageAsync(message);

// Explicitly dead-letter a message
await receiver.DeadLetterMessageAsync(
    message,
    deadLetterReason: "Invalid format",
    deadLetterErrorDescription: "Missing required fields");
```

### Process Dead-Letter Queue

```csharp
// Receive from dead-letter queue
await using var dlqReceiver = client.CreateReceiver(
    "orders-queue",
    new ServiceBusReceiverOptions
    {
        SubQueue = SubQueue.DeadLetter
    });

await foreach (var dlqMessage in dlqReceiver.ReceiveMessagesAsync())
{
    Console.WriteLine($"DLQ Message: {dlqMessage.Body}");
    Console.WriteLine($"Reason: {dlqMessage.DeadLetterReason}");
    Console.WriteLine($"Error: {dlqMessage.DeadLetterErrorDescription}");
    Console.WriteLine($"Delivery count: {dlqMessage.DeliveryCount}");

    // Process or log the message
    await dlqReceiver.CompleteMessageAsync(dlqMessage);
}
```

Set max delivery count:

```bash
az servicebus queue update \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-queue \
  --max-delivery-count 5
```

## Exercise 5: Message Deferral

**AZ-204 Topic:** Defer message processing to a later time.

```csharp
// Defer a message
long sequenceNumber = message.SequenceNumber;
await receiver.DeferMessageAsync(message);

// Later, receive deferred message by sequence number
ServiceBusReceivedMessage deferredMessage = await receiver.ReceiveDeferredMessageAsync(sequenceNumber);

Console.WriteLine($"Processing deferred message: {deferredMessage.Body}");
await receiver.CompleteMessageAsync(deferredMessage);
```

> **AZ-204 Exam Tip:** Use deferral when:
> - Message processing depends on other messages
> - Out-of-order messages need to be reordered
> - Message needs to wait for external condition

## Exercise 6: Scheduled Messages

**AZ-204 Topic:** Schedule messages to be available at a future time.

```csharp
// Schedule message for future delivery
DateTimeOffset scheduleTime = DateTimeOffset.UtcNow.AddHours(1);

long sequenceNumber = await sender.ScheduleMessageAsync(
    new ServiceBusMessage("Scheduled order"),
    scheduleTime);

Console.WriteLine($"Message scheduled. Sequence number: {sequenceNumber}");

// Cancel scheduled message
await sender.CancelScheduledMessageAsync(sequenceNumber);
```

## Exercise 7: Duplicate Detection

**AZ-204 Topic:** Automatically detect and remove duplicate messages.

### Enable Duplicate Detection

```bash
az servicebus queue create \
  -g labs-servicebus-az204 \
  --namespace-name <servicebus-namespace> \
  --name orders-dedupe-queue \
  --enable-duplicate-detection true \
  --duplicate-detection-history-time-window PT10M
```

### Send Messages with MessageId

```csharp
var message = new ServiceBusMessage("Order #12345");
message.MessageId = "order-12345"; // Duplicate detection uses MessageId

await sender.SendMessageAsync(message);

// Try to send duplicate (will be rejected within detection window)
await sender.SendMessageAsync(message);
```

> **AZ-204 Exam Tip:** Duplicate detection:
> - Based on `MessageId` property
> - Detection window: 30 seconds to 7 days
> - Disabled by default (enable at queue/topic creation)
> - Cannot be enabled on existing queue/topic

## Exercise 8: Transactions

**AZ-204 Topic:** Atomic operations across multiple messages.

```csharp
await using var sender = client.CreateSender("orders-queue");
await using var receiver = client.CreateReceiver("orders-queue");

// Receive message
var message = await receiver.ReceiveMessageAsync();

// Start transaction
using (var ts = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
{
    // Complete received message
    await receiver.CompleteMessageAsync(message);

    // Send new message
    await sender.SendMessageAsync(new ServiceBusMessage("Processing order"));

    // Commit transaction
    ts.Complete();
}
// If any operation fails, entire transaction is rolled back
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Queue vs Topic:**
   - **Queue**: Point-to-point, single consumer
   - **Topic**: Pub/sub, multiple subscriptions

2. **Message Settlement:**
   - **Complete**: Successfully processed, remove from queue
   - **Abandon**: Failed, return to queue (increments delivery count)
   - **Dead-letter**: Move to DLQ, unprocessable
   - **Defer**: Save for later processing

3. **Sessions:**
   - FIFO guarantee within session
   - Stateful processing
   - Session state storage
   - Load balancing by session ID

4. **Filters:**
   - SQL filters (flexible but slower)
   - Correlation filters (efficient, recommended)
   - Boolean filters (all or none)

5. **Service Bus vs Queue Storage:**
   | Feature | Service Bus | Queue Storage |
   |---------|-------------|---------------|
   | Max message size | 256 KB (1 MB Premium) | 64 KB |
   | FIFO guarantee | Yes (with sessions) | No |
   | Topics/Subscriptions | Yes | No |
   | Duplicate detection | Yes | No |
   | Transactions | Yes | Yes |
   | Price | Higher | Lower |

### Common Exam Scenarios

1. **Scenario:** Need FIFO processing for customer orders
   - **Solution:** Use sessions with SessionId = customerId

2. **Scenario:** Different systems need different subsets of messages
   - **Solution:** Use topics with filtered subscriptions

3. **Scenario:** Handle messages that fail after 5 attempts
   - **Solution:** Set max delivery count and process DLQ

4. **Scenario:** Send notification in 1 hour
   - **Solution:** Use scheduled messages

5. **Scenario:** Prevent duplicate order processing
   - **Solution:** Enable duplicate detection, set MessageId to order ID

## Best Practices

1. **Use sessions** for FIFO and stateful processing
2. **Batch messages** for better throughput
3. **Set appropriate TTL** to avoid queue buildup
4. **Monitor DLQ** regularly
5. **Use Premium tier** for production high-throughput scenarios
6. **Implement retry logic** with exponential backoff
7. **Use correlation filters** instead of SQL for better performance
8. **Set max delivery count** to prevent poison messages

## Cleanup

```bash
az group delete -y -n labs-servicebus-az204 --no-wait
```

## Additional Resources

- [Azure Service Bus documentation](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)
- [Service Bus SDK for .NET](https://docs.microsoft.com/en-us/dotnet/api/overview/azure/messaging.servicebus-readme)
- [Message sessions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
