# Azure Functions - Timer Triggers - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop Azure Compute Solutions (25-30%)

This lab covers Timer-triggered Azure Functions with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Azure Functions Timer lab](README.md) first to understand fundamental timer trigger operations.

## AZ-204 Exam Skills Covered

- Implement Timer triggers with NCRONTAB expressions
- Understand scheduling patterns and intervals
- Work with TimerInfo and execution metadata
- Implement singleton execution patterns
- Handle past-due executions
- Best practices for scheduled functions

## Exercise 1: Understanding NCRONTAB Expressions

**AZ-204 Critical Topic:** Timer triggers use NCRONTAB expressions with 6 fields for scheduling.

### NCRONTAB Expression Syntax

NCRONTAB expressions have 6 fields:

```
{second} {minute} {hour} {day} {month} {day-of-week}
```

**Field Ranges:**
- Second: 0-59
- Minute: 0-59
- Hour: 0-23
- Day: 1-31
- Month: 1-12 or JAN-DEC
- Day of week: 0-6 or SUN-SAT (0 and 7 are Sunday)

**Special Characters:**
- `*` - Any value (wildcard)
- `,` - Value list separator (e.g., `1,3,5`)
- `-` - Range of values (e.g., `1-5`)
- `/` - Step values (e.g., `*/5` means every 5)

### Common Scheduling Patterns

```csharp
// Every 5 minutes
[TimerTrigger("0 */5 * * * *")]

// Every hour at minute 0
[TimerTrigger("0 0 * * * *")]

// Every day at midnight (2 AM UTC)
[TimerTrigger("0 0 2 * * *")]

// Every weekday at 9 AM
[TimerTrigger("0 0 9 * * MON-FRI")]

// Every 15 minutes during business hours (9 AM - 5 PM)
[TimerTrigger("0 */15 9-17 * * MON-FRI")]

// Twice a day at 9:30 AM and 5:30 PM
[TimerTrigger("0 30 9,17 * * *")]

// First day of every month at midnight
[TimerTrigger("0 0 0 1 * *")]

// Every Monday at 6 AM
[TimerTrigger("0 0 6 * * MON")]

// Every 30 seconds
[TimerTrigger("*/30 * * * * *")]

// Every quarter hour (0, 15, 30, 45 minutes)
[TimerTrigger("0 0,15,30,45 * * * *")]
```

üìã What NCRONTAB expression would run a function every 10 minutes only on weekends?

<details>
  <summary>Not sure how?</summary>

```
0 */10 * * * SAT,SUN
```

Or alternatively:
```
0 */10 * * * 0,6
```

This runs:
- At 0 seconds
- Every 10 minutes
- Every hour
- Every day
- Every month
- On Saturday and Sunday only

</details><br/>

> **AZ-204 Exam Tip:** NCRONTAB expressions are different from standard CRON expressions - they have 6 fields (including seconds), not 5. The order is also slightly different from UNIX cron.

## Exercise 2: TimerInfo and Execution Metadata

**AZ-204 Exam Topic:** Understanding TimerInfo provides insights into function execution timing.

### Working with TimerInfo

Create a comprehensive timer function:

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using System;

public static class TimerWithInfo
{
    [FunctionName("ScheduledTask")]
    public static void Run(
        [TimerTrigger("0 */5 * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Function executed at: {DateTime.UtcNow}");

        // Check if execution is past due
        if (myTimer.IsPastDue)
        {
            log.LogWarning("Timer execution is past due!");
        }

        // Log schedule status
        log.LogInformation($"Next occurrence: {myTimer.Schedule.GetNextOccurrence(DateTime.UtcNow)}");
        log.LogInformation($"Last occurrence: {myTimer.ScheduleStatus?.Last}");
        log.LogInformation($"Next scheduled: {myTimer.ScheduleStatus?.Next}");
        log.LogInformation($"Last updated: {myTimer.ScheduleStatus?.LastUpdated}");

        // Perform scheduled work
        PerformScheduledWork(log);
    }

    private static void PerformScheduledWork(ILogger log)
    {
        log.LogInformation("Performing scheduled maintenance task...");
        // Your business logic here
    }
}
```

**Key TimerInfo Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `IsPastDue` | bool | Indicates if the execution is running late |
| `Schedule` | TimerSchedule | Schedule information with GetNextOccurrence() |
| `ScheduleStatus` | ScheduleStatus | Last/Next/LastUpdated timestamps |

### Handling Past-Due Executions

```csharp
[FunctionName("ResilientTimer")]
public static async Task Run(
    [TimerTrigger("0 */5 * * * *")] TimerInfo myTimer,
    ILogger log)
{
    if (myTimer.IsPastDue)
    {
        log.LogWarning($"Function is running late. Last execution: {myTimer.ScheduleStatus?.Last}");

        // Decide whether to skip or run the past-due execution
        var delay = DateTime.UtcNow - myTimer.ScheduleStatus?.Last;
        if (delay.HasValue && delay.Value.TotalMinutes > 10)
        {
            log.LogWarning("Skipping past-due execution - too far behind");
            return;
        }
    }

    // Normal execution
    await PerformTimerTaskAsync(log);
}

private static async Task PerformTimerTaskAsync(ILogger log)
{
    log.LogInformation("Executing timer task...");
    await Task.Delay(1000); // Simulate work
}
```

> **AZ-204 Exam Tip:** `IsPastDue` is set to `true` when a timer execution is delayed (e.g., during function app restart, cold start, or if previous execution took too long). Always check this property for production timer functions.

## Exercise 3: Singleton Execution and Concurrency

**AZ-204 Advanced Topic:** Prevent overlapping executions of timer functions.

### Using Singleton Attribute

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;

public static class SingletonTimer
{
    // Prevent concurrent executions across all instances
    [FunctionName("DatabaseBackup")]
    [Singleton]
    public static async Task Run(
        [TimerTrigger("0 0 2 * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Database backup started at: {DateTime.UtcNow}");

        if (myTimer.IsPastDue)
        {
            log.LogWarning("Backup is running late - may indicate performance issues");
        }

        // Long-running backup operation
        await PerformBackupAsync(log);

        log.LogInformation($"Database backup completed at: {DateTime.UtcNow}");
    }

    private static async Task PerformBackupAsync(ILogger log)
    {
        log.LogInformation("Starting backup process...");
        await Task.Delay(30000); // Simulate 30-second backup
        log.LogInformation("Backup process completed");
    }
}
```

### Singleton with Custom Scope

```csharp
public static class SingletonWithScope
{
    // Singleton per function (default behavior)
    [FunctionName("PeriodicCleanup")]
    [Singleton(Mode = SingletonMode.Function)]
    public static async Task Run(
        [TimerTrigger("0 */30 * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation("Starting cleanup operation");
        await CleanupOldDataAsync(log);
    }

    private static async Task CleanupOldDataAsync(ILogger log)
    {
        // Cleanup logic
        await Task.Delay(5000);
        log.LogInformation("Cleanup completed");
    }
}
```

### Singleton Listener Mode

```csharp
public static class SingletonListener
{
    // Only one instance listens for timer events
    [FunctionName("MetricsCollector")]
    [Singleton(Mode = SingletonMode.Listener)]
    public static void Run(
        [TimerTrigger("0 * * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation("Collecting metrics at: {0}", DateTime.UtcNow);
        CollectAndStoreMetrics(log);
    }

    private static void CollectAndStoreMetrics(ILogger log)
    {
        // Metrics collection logic
        log.LogInformation("Metrics collected successfully");
    }
}
```

> **AZ-204 Exam Tip:** Singleton modes:
> - **Function** (default): Only one execution of the function runs at a time across all instances
> - **Listener**: Only one instance listens for the timer trigger (execution can still run on multiple instances)

## Exercise 4: Configuration and Best Practices

### Using App Settings for CRON Expressions

Store CRON expressions in application settings for flexibility:

```csharp
public static class ConfigurableTimer
{
    [FunctionName("ConfigurableScheduledTask")]
    public static void Run(
        [TimerTrigger("%ScheduleExpression%")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Configurable timer triggered at: {DateTime.UtcNow}");

        if (myTimer.IsPastDue)
        {
            log.LogWarning("Function execution is past due");
        }

        PerformConfigurableTask(log);
    }

    private static void PerformConfigurableTask(ILogger log)
    {
        log.LogInformation("Executing configurable task...");
    }
}
```

Set the schedule via App Settings:

```bash
az functionapp config appsettings set \
  -g labs-functions-timer \
  -n <function-app-name> \
  --settings "ScheduleExpression=0 */10 * * * *"
```

### Disable Timer on Startup

```csharp
public static class DisableableTimer
{
    [FunctionName("OptionalTimer")]
    [Disable("DisableTimerFunction")]  // Reads from app setting
    public static void Run(
        [TimerTrigger("0 */5 * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation("Optional timer function executed");
    }
}
```

Configure via app settings:

```bash
# Disable the function
az functionapp config appsettings set \
  -g labs-functions-timer \
  -n <function-app-name> \
  --settings "DisableTimerFunction=true"

# Enable the function
az functionapp config appsettings set \
  -g labs-functions-timer \
  -n <function-app-name> \
  --settings "DisableTimerFunction=false"
```

## Exercise 5: Real-World Timer Patterns

### Data Archival Function

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;

public static class DataArchival
{
    // Run every day at 3 AM
    [FunctionName("ArchiveOldData")]
    [Singleton]
    public static async Task Run(
        [TimerTrigger("0 0 3 * * *")] TimerInfo myTimer,
        [Blob("archive/{DateTime}.json", FileAccess.Write)] Stream archiveBlob,
        ILogger log)
    {
        log.LogInformation($"Data archival started at: {DateTime.UtcNow}");

        if (myTimer.IsPastDue)
        {
            log.LogWarning("Archival is running late");
        }

        // Archive data older than 90 days
        await ArchiveDataAsync(archiveBlob, log, daysOld: 90);

        log.LogInformation($"Data archival completed at: {DateTime.UtcNow}");
    }

    private static async Task ArchiveDataAsync(Stream archiveBlob, ILogger log, int daysOld)
    {
        log.LogInformation($"Archiving data older than {daysOld} days");
        // Archive logic here
        await Task.CompletedTask;
    }
}
```

### Health Check Function

```csharp
public static class HealthCheck
{
    // Run every 5 minutes
    [FunctionName("SystemHealthCheck")]
    public static async Task Run(
        [TimerTrigger("0 */5 * * * *")] TimerInfo myTimer,
        [Queue("alerts")] IAsyncCollector<string> alertQueue,
        ILogger log)
    {
        log.LogInformation($"Health check started at: {DateTime.UtcNow}");

        var healthStatus = await CheckSystemHealthAsync();

        if (!healthStatus.IsHealthy)
        {
            await alertQueue.AddAsync($"ALERT: System unhealthy - {healthStatus.Message}");
            log.LogError($"Health check failed: {healthStatus.Message}");
        }
        else
        {
            log.LogInformation("System is healthy");
        }
    }

    private static async Task<(bool IsHealthy, string Message)> CheckSystemHealthAsync()
    {
        // Health check logic
        await Task.Delay(100);
        return (true, "All systems operational");
    }
}
```

### Report Generation Function

```csharp
public static class ReportGeneration
{
    // Run every weekday at 8 AM
    [FunctionName("DailyReportGenerator")]
    [Singleton]
    public static async Task Run(
        [TimerTrigger("0 0 8 * * MON-FRI")] TimerInfo myTimer,
        [Blob("reports/daily-{DateTime:yyyy-MM-dd}.pdf", FileAccess.Write)] Stream reportBlob,
        [SendGrid(ApiKey = "SendGridApiKey")] IAsyncCollector<SendGridMessage> messageCollector,
        ILogger log)
    {
        log.LogInformation($"Report generation started at: {DateTime.UtcNow}");

        // Generate report
        await GenerateReportAsync(reportBlob, log);

        // Send email notification
        var message = new SendGridMessage();
        message.SetSubject("Daily Report - " + DateTime.UtcNow.ToString("yyyy-MM-dd"));
        message.AddContent("text/plain", "Your daily report has been generated.");
        await messageCollector.AddAsync(message);

        log.LogInformation("Report generated and email sent");
    }

    private static async Task GenerateReportAsync(Stream reportBlob, ILogger log)
    {
        log.LogInformation("Generating report...");
        // Report generation logic
        await Task.Delay(2000);
    }
}
```

## Exercise 6: Testing and Debugging Timer Functions

### Local Development with local.settings.json

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "dotnet",
    "ScheduleExpression": "*/10 * * * * *",
    "DisableTimerFunction": "false"
  }
}
```

### Manual Timer Trigger for Testing

```csharp
public static class TestableTimer
{
    [FunctionName("TestableScheduledTask")]
    public static async Task Run(
        [TimerTrigger("0 0 2 * * *")] TimerInfo myTimer,
        ILogger log)
    {
        await ExecuteTaskAsync(log);
    }

    // Separate HTTP trigger for manual testing
    [FunctionName("TestableScheduledTask_Manual")]
    public static async Task ManualTrigger(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
        ILogger log)
    {
        log.LogInformation("Manual trigger invoked");
        await ExecuteTaskAsync(log);
    }

    private static async Task ExecuteTaskAsync(ILogger log)
    {
        log.LogInformation("Executing scheduled task logic");
        // Shared task logic
        await Task.Delay(1000);
        log.LogInformation("Task completed");
    }
}
```

### Monitoring Timer Executions

Query Application Insights for timer metrics:

```bash
# View timer function executions
az monitor app-insights metrics show \
  --app <app-insights-name> \
  -g labs-functions-timer \
  --metrics requests/count \
  --start-time 2024-01-01T00:00:00Z \
  --end-time 2024-01-02T00:00:00Z \
  --interval PT1H \
  --aggregation Count \
  --filter "cloud/roleName eq '<function-app-name>' and operation/name eq 'ScheduledTask'"
```

## Exercise 7: Error Handling and Retry Patterns

### Retry with Exponential Backoff

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;

public static class ResilientTimerFunction
{
    [FunctionName("ResilientScheduledTask")]
    [FixedDelayRetry(5, "00:00:10")]  // 5 retries with 10-second delay
    public static async Task Run(
        [TimerTrigger("0 */15 * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Resilient timer function executed at: {DateTime.UtcNow}");

        try
        {
            await PerformCriticalTaskAsync(log);
        }
        catch (Exception ex)
        {
            log.LogError(ex, "Error in timer function execution");
            throw; // Trigger retry policy
        }
    }

    private static async Task PerformCriticalTaskAsync(ILogger log)
    {
        log.LogInformation("Performing critical task...");
        // Simulated work that might fail
        await Task.Delay(1000);
    }
}
```

### Exponential Backoff Retry

```csharp
public static class ExponentialRetryTimer
{
    [FunctionName("ExponentialRetryTask")]
    [ExponentialBackoffRetry(5, "00:00:04", "00:15:00")]  // 5 retries, 4s to 15min
    public static async Task Run(
        [TimerTrigger("0 0 * * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Exponential retry timer executed at: {DateTime.UtcNow}");

        await PerformTaskWithPossibleFailureAsync(log);
    }

    private static async Task PerformTaskWithPossibleFailureAsync(ILogger log)
    {
        log.LogInformation("Executing task that might fail...");
        // Task logic
        await Task.Delay(500);
    }
}
```

> **AZ-204 Exam Tip:** Retry policies:
> - **FixedDelayRetry**: Fixed delay between retries
> - **ExponentialBackoffRetry**: Exponentially increasing delay (recommended for most scenarios)
> - Max retry count applies per execution
> - Failed retries count toward function execution metrics

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **NCRONTAB Expression Format:**
   - 6 fields: `{second} {minute} {hour} {day} {month} {day-of-week}`
   - Special characters: `*` (any), `,` (list), `-` (range), `/` (step)
   - Difference from standard CRON (has seconds field)
   - Common patterns for daily, weekly, hourly schedules

2. **TimerInfo Properties:**
   - `IsPastDue`: Indicates delayed execution
   - `Schedule`: TimerSchedule with GetNextOccurrence()
   - `ScheduleStatus`: Last, Next, LastUpdated timestamps
   - Use for logging and conditional logic

3. **Singleton Execution:**
   - `[Singleton]` attribute prevents concurrent executions
   - **Function mode**: One execution at a time globally
   - **Listener mode**: One listener, multiple executions possible
   - Critical for long-running or resource-intensive tasks

4. **Configuration Best Practices:**
   - Store CRON expressions in app settings: `"%SettingName%"`
   - Use `[Disable("SettingName")]` for conditional enabling
   - Environment-specific schedules (dev vs prod)
   - TimeZone considerations (default is UTC)

5. **Scaling Behavior:**
   - Timer functions scale differently than HTTP functions
   - Only one instance processes timer trigger (with Singleton)
   - Multiple instances can run the same timer (without Singleton)
   - Consumption plan: Timer ensures single execution per schedule

6. **Error Handling:**
   - Use retry policies: FixedDelayRetry or ExponentialBackoffRetry
   - Check IsPastDue to detect performance issues
   - Log execution times for monitoring
   - Separate trigger from business logic for testability

### Common Exam Scenarios

1. **Scenario:** Schedule a function to run every weekday morning at 9 AM
   - **Solution:** `[TimerTrigger("0 0 9 * * MON-FRI")]`

2. **Scenario:** Prevent multiple instances of a long-running timer function
   - **Solution:** Apply `[Singleton]` attribute to the function

3. **Scenario:** Function needs different schedules in dev and production
   - **Solution:** Use `[TimerTrigger("%ScheduleExpression%")]` with app settings

4. **Scenario:** Timer function is consistently showing IsPastDue = true
   - **Solution:** Function is taking too long to execute or scaling issues - optimize or increase timeout

5. **Scenario:** Need to manually trigger a timer function for testing
   - **Solution:** Create separate HTTP-triggered function that calls the same logic

6. **Scenario:** Archive data every month on the 1st at midnight
   - **Solution:** `[TimerTrigger("0 0 0 1 * *")]`

7. **Scenario:** Function should only run during business hours
   - **Solution:** Use time range in CRON expression or conditional logic in code

### NCRONTAB Quick Reference

| Frequency | NCRONTAB Expression | Description |
|-----------|-------------------|-------------|
| Every 30 seconds | `*/30 * * * * *` | Runs twice per minute |
| Every 5 minutes | `0 */5 * * * *` | Standard monitoring interval |
| Every hour | `0 0 * * * *` | Top of every hour |
| Every day at midnight | `0 0 0 * * *` | Daily batch job |
| Every weekday at 9 AM | `0 0 9 * * MON-FRI` | Business days only |
| Every Monday at 6 AM | `0 0 6 * * MON` | Weekly tasks |
| First of month at midnight | `0 0 0 1 * *` | Monthly billing |
| Every 15 minutes (business hours) | `0 */15 9-17 * * MON-FRI` | Frequent business checks |
| Twice daily (9 AM, 9 PM) | `0 0 9,21 * * *` | Morning and evening |
| Every quarter hour | `0 0,15,30,45 * * * *` | Regular intervals |

### Timer Trigger vs Other Scheduling Options

| Feature | Timer Trigger | Logic Apps | Durable Functions |
|---------|---------------|------------|-------------------|
| CRON scheduling | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No (use timer) |
| Serverless | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| Visual designer | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| Code-first | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes |
| Complex workflows | ‚ùå Limited | ‚úÖ Yes | ‚úÖ Yes |
| Cost | $ Low | $$ Medium | $ Low |
| Best for | Simple schedules | Workflows | Stateful patterns |

## Best Practices

1. **Always check IsPastDue** for production functions
2. **Use Singleton** for long-running or exclusive operations
3. **Store schedules in app settings** for flexibility
4. **Implement retry policies** for resilience
5. **Log execution times** for performance monitoring
6. **Consider time zones** - default is UTC
7. **Test with manual HTTP triggers** during development
8. **Use appropriate plans** - Consumption for infrequent, Premium for critical
9. **Monitor Application Insights** for execution patterns
10. **Document CRON expressions** in comments for maintainability

## Additional Resources

- [Azure Functions Timer trigger documentation](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)
- [NCRONTAB expressions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer?tabs=csharp#ncrontab-expressions)
- [Singleton pattern in Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-class-library#singleton)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)

## Cleanup

```bash
az group delete -y -n labs-functions-timer --no-wait
```
