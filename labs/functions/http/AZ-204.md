# Azure Functions - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop Azure Compute Solutions (25-30%)

This lab extends the basic Azure Functions exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Azure Functions HTTP lab](README.md) first to understand fundamental function operations.

## AZ-204 Exam Skills Covered

- Create and configure Function Apps
- Implement input and output bindings
- Implement function triggers (data operations, timers, webhooks)
- Function App settings and configuration
- Deployment slots and continuous deployment
- Scaling and performance optimization

## Exercise 1: Function App Configuration

### Application Settings and Environment Variables

Function Apps use Application Settings for configuration, accessible as environment variables in code.

```bash
az group create -n labs-functions-az204 --tags courselabs=azure -l eastus

# Create storage account for function app
az storage account create \
  -g labs-functions-az204 \
  -n <sa-name> \
  --sku Standard_LRS

# Create Function App with consumption plan
az functionapp create \
  -g labs-functions-az204 \
  --consumption-plan-location eastus \
  --runtime dotnet \
  --functions-version 4 \
  --name <function-app-name> \
  --storage-account <sa-name>
```

Add application settings:

```bash
az functionapp config appsettings set \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --settings \
    "API_KEY=super-secret-key-12345" \
    "MAX_RETRY_COUNT=3" \
    "FEATURE_FLAG_ENABLED=true"
```

ðŸ“‹ Retrieve all application settings and filter to show only your custom settings (not Azure internal ones).

<details>
  <summary>Not sure how?</summary>

```bash
az functionapp config appsettings list \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --query "[?!starts_with(name, 'WEBSITE_') && !starts_with(name, 'FUNCTIONS_')].{Name:name, Value:value}" \
  -o table
```

</details><br/>

> **AZ-204 Exam Tip:** Application Settings in Function Apps are exposed as environment variables. Use them for connection strings, API keys, and feature flags. Never hardcode secrets in function code.

### Connection Strings

Store database connection strings separately from app settings:

```bash
az functionapp config connection-string set \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --connection-string-type SQLAzure \
  --settings DefaultConnection="Server=tcp:myserver.database.windows.net;Database=mydb;"
```

## Exercise 2: Advanced HTTP Triggers and Authorization

### Authorization Levels

Azure Functions support three authorization levels for HTTP triggers:

1. **Anonymous**: No authentication required
2. **Function**: Requires function-specific API key
3. **Admin**: Requires master/admin key

Get function keys:

```bash
# Get function-level keys
az functionapp function keys list \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --function-name HttpTime

# Get host (admin) keys
az functionapp keys list \
  -g labs-functions-az204 \
  -n <function-app-name>
```

Call a function with a function key:

```bash
FUNCTION_URL=$(az functionapp function show \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --function-name HttpTime \
  --query invokeUrlTemplate -o tsv)

FUNCTION_KEY=$(az functionapp function keys list \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --function-name HttpTime \
  --query default -o tsv)

curl "$FUNCTION_URL?code=$FUNCTION_KEY"
```

ðŸ“‹ Create a new function key named "mobile-app" and use it to call the function.

<details>
  <summary>Not sure how?</summary>

```bash
az functionapp function keys set \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --function-name HttpTime \
  --key-name mobile-app \
  --key-value "my-custom-key-value-xyz"

# Use the custom key
curl "$FUNCTION_URL?code=my-custom-key-value-xyz"
```

</details><br/>

> **AZ-204 Exam Tip:** Function keys vs Host keys:
> - **Function keys**: Specific to one function, use for function-level access
> - **Host keys**: Work with all functions in the app, use for admin operations

## Exercise 3: Input and Output Bindings

**AZ-204 Critical Topic:** Bindings provide declarative way to connect to data sources.

### Create a Function with Queue Output Binding

Create a function that receives HTTP requests and writes to Azure Queue Storage:

```csharp
// Function with HTTP trigger and Queue output binding
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

public static class HttpToQueue
{
    [FunctionName("HttpToQueue")]
    public static IActionResult Run(
        [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
        [Queue("orders", Connection = "AzureWebJobsStorage")] out string queueMessage,
        ILogger log)
    {
        string name = req.Query["name"];
        queueMessage = $"Order from {name} at {DateTime.UtcNow}";

        log.LogInformation($"Queued message: {queueMessage}");
        return new OkObjectResult($"Message queued: {queueMessage}");
    }
}
```

**Key Points:**
- `[Queue]` attribute defines output binding
- `Connection` parameter references app setting for storage connection string
- `out string` parameter automatically writes to queue when function completes

### Blob Input and Output Bindings

```csharp
[FunctionName("ProcessBlob")]
public static void Run(
    [BlobTrigger("input/{name}", Connection = "AzureWebJobsStorage")] string inputBlob,
    [Blob("output/{name}", FileAccess.Write, Connection = "AzureWebJobsStorage")] out string outputBlob,
    string name,
    ILogger log)
{
    log.LogInformation($"Processing blob: {name}, Size: {inputBlob.Length}");
    outputBlob = inputBlob.ToUpper();
}
```

> **AZ-204 Exam Tip:** Common binding types:
> - **Triggers**: HTTP, Timer, Blob, Queue, Service Bus, Event Hub, Cosmos DB, Event Grid
> - **Input Bindings**: Blob, Table, Cosmos DB, SQL
> - **Output Bindings**: Blob, Queue, Table, Cosmos DB, Service Bus, Event Hub, SignalR

## Exercise 4: Timer Triggers

**AZ-204 Exam Topic:** Schedule functions to run on a specific cadence using CRON expressions.

### Understanding CRON Expressions

Timer triggers use NCRONTAB expressions (6 fields):

```
{second} {minute} {hour} {day} {month} {day-of-week}
```

Common patterns:
- `0 */5 * * * *` - Every 5 minutes
- `0 0 * * * *` - Every hour
- `0 0 0 * * *` - Every day at midnight
- `0 0 9 * * MON-FRI` - Every weekday at 9 AM
- `0 30 9,17 * * *` - Every day at 9:30 AM and 5:30 PM

Create a timer-triggered function:

```csharp
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;

public static class TimerFunction
{
    [FunctionName("DailyCleanup")]
    public static void Run(
        [TimerTrigger("0 0 2 * * *")] TimerInfo myTimer,
        ILogger log)
    {
        log.LogInformation($"Cleanup function executed at: {DateTime.Now}");

        if (myTimer.IsPastDue)
        {
            log.LogWarning("Timer is running late!");
        }
    }
}
```

ðŸ“‹ What CRON expression would run a function every 15 minutes during business hours (9 AM - 5 PM)?

<details>
  <summary>Not sure how?</summary>

```
0 */15 9-17 * * MON-FRI
```

This runs:
- At 0 seconds
- Every 15 minutes
- Between hours 9-17 (9 AM to 5 PM)
- Every day of month
- Every month
- Monday through Friday

</details><br/>

## Exercise 5: Durable Functions Patterns

**AZ-204 Advanced Topic:** Durable Functions enable stateful workflows in serverless environment.

### Function Chaining Pattern

```csharp
// Orchestrator function
[FunctionName("OrderProcessing")]
public static async Task<string> RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var orderId = context.GetInput<string>();

    // Function chaining
    var result1 = await context.CallActivityAsync<bool>("ValidateOrder", orderId);
    if (!result1) return "Order validation failed";

    var result2 = await context.CallActivityAsync<string>("ProcessPayment", orderId);
    var result3 = await context.CallActivityAsync<string>("ShipOrder", orderId);
    var result4 = await context.CallActivityAsync<string>("SendNotification", orderId);

    return "Order processed successfully";
}

// Activity functions
[FunctionName("ValidateOrder")]
public static bool ValidateOrder([ActivityTrigger] string orderId, ILogger log)
{
    log.LogInformation($"Validating order {orderId}");
    return true;
}

[FunctionName("ProcessPayment")]
public static string ProcessPayment([ActivityTrigger] string orderId, ILogger log)
{
    log.LogInformation($"Processing payment for order {orderId}");
    return "Payment processed";
}
```

### Fan-out/Fan-in Pattern

```csharp
[FunctionName("ParallelProcessing")]
public static async Task<int> RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var files = await context.CallActivityAsync<string[]>("GetFileList", null);

    // Fan-out: Start multiple activities in parallel
    var tasks = new List<Task<int>>();
    foreach (var file in files)
    {
        tasks.Add(context.CallActivityAsync<int>("ProcessFile", file));
    }

    // Fan-in: Wait for all activities to complete
    var results = await Task.WhenAll(tasks);

    // Aggregate results
    return results.Sum();
}
```

> **AZ-204 Exam Tip:** Durable Function Patterns:
> 1. **Function Chaining**: Sequential execution
> 2. **Fan-out/Fan-in**: Parallel execution then aggregate
> 3. **Async HTTP APIs**: Long-running operations with status check
> 4. **Monitor**: Recurring process until condition met
> 5. **Human Interaction**: Wait for external event/approval

## Exercise 6: Function App Scaling and Performance

### Consumption Plan vs Premium Plan vs Dedicated

**Consumption Plan (Serverless):**
- Automatic scaling
- Pay only for execution time
- Cold start latency
- Max 10 minute execution time (default 5)

**Premium Plan:**
- Pre-warmed instances (no cold start)
- VNET connectivity
- Unlimited execution duration
- Higher compute options

**Dedicated (App Service) Plan:**
- Run on dedicated VMs
- Predictable pricing
- Share resources with Web Apps

Configure function timeout (Consumption plan max is 10 minutes):

```bash
az functionapp config set \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --json '{"functionTimeout": "00:10:00"}'
```

### Monitor Scaling

View function execution count:

```bash
az monitor metrics list \
  --resource "/subscriptions/<subscription-id>/resourceGroups/labs-functions-az204/providers/Microsoft.Web/sites/<function-app-name>" \
  --metric "FunctionExecutionCount" \
  --start-time 2024-01-01T00:00:00Z \
  --end-time 2024-01-02T00:00:00Z \
  --interval PT1H
```

> **AZ-204 Exam Tip:** Consumption plan scales out to 200 instances by default. Premium plan can configure max scale-out limit.

## Exercise 7: Deployment Slots

**AZ-204 Exam Topic:** Use deployment slots for zero-downtime deployments.

```bash
# Deployment slots require Premium plan or higher
az functionapp deployment slot create \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --slot staging

# Deploy to staging slot
az functionapp deployment source config-zip \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --slot staging \
  --src function.zip

# Swap staging to production
az functionapp deployment slot swap \
  -g labs-functions-az204 \
  -n <function-app-name> \
  --slot staging \
  --target-slot production
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Trigger Types:**
   - HTTP triggers with authorization levels
   - Timer triggers with CRON expressions
   - Blob triggers with path patterns
   - Queue triggers with batch processing
   - Service Bus triggers with sessions
   - Event Hub triggers with partitions
   - Cosmos DB change feed triggers

2. **Binding Direction:**
   - **In**: Input bindings (read data)
   - **Out**: Output bindings (write data)
   - **InOut**: Both read and write

3. **Function App Settings:**
   - `AzureWebJobsStorage`: Required for all function apps
   - `FUNCTIONS_WORKER_RUNTIME`: dotnet, node, python, java
   - `FUNCTIONS_EXTENSION_VERSION`: ~4 (latest)
   - Connection strings reference in bindings

4. **Scaling Behavior:**
   - Consumption: Event-driven scaling, up to 200 instances
   - Queue/Service Bus: Scale based on queue length
   - HTTP: Scale based on requests per instance
   - Non-HTTP: Use scale controller decisions

5. **Durable Functions:**
   - Orchestrator functions (coordination)
   - Activity functions (work)
   - Client functions (start orchestrations)
   - Entity functions (stateful objects)

### Common Exam Scenarios

1. **Scenario:** Function needs to process uploaded images and save thumbnails
   - **Solution:** Blob trigger input binding + Blob output binding

2. **Scenario:** Function must run every night at 2 AM to clean up old data
   - **Solution:** Timer trigger with CRON: `0 0 2 * * *`

3. **Scenario:** Function needs database connection string
   - **Solution:** Store in App Settings or Key Vault, reference via `%SettingName%`

4. **Scenario:** Long-running workflow with multiple steps
   - **Solution:** Durable Functions with function chaining pattern

5. **Scenario:** Zero-downtime deployment of new function version
   - **Solution:** Use deployment slots, deploy to staging, then swap

## Additional Resources

- [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/)
- [Bindings and triggers](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings)
- [Durable Functions patterns](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)

## Cleanup

```bash
az group delete -y -n labs-functions-az204 --no-wait
```
