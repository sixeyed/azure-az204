# Cosmos DB - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop for Azure Storage (15-20%)

This lab extends the basic Cosmos DB exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Cosmos DB lab](README.md) first to understand fundamental Cosmos DB operations.

## AZ-204 Exam Skills Covered

- Perform operations on containers and items using the SDK
- Set appropriate consistency levels for operations
- Implement change feed notifications
- Partition strategy and design
- Indexing policies
- Request Units (RU) optimization

## Exercise 1: Cosmos DB Account and Consistency Levels

**AZ-204 Critical Topic:** Consistency levels balance availability, latency, and data consistency.

### Create Cosmos DB Account

```bash
az group create -n labs-cosmos-az204 --tags courselabs=azure -l eastus

# Create Cosmos DB account with NoSQL API
az cosmosdb create \
  -g labs-cosmos-az204 \
  -n <cosmos-account-name> \
  --default-consistency-level Session \
  --enable-automatic-failover false
```

### Understand Consistency Levels

**From Strongest to Weakest:**

1. **Strong**: Linearizability guarantee, reads always return most recent committed write
   - Highest consistency, highest latency
   - 2x RU cost for reads

2. **Bounded Staleness**: Reads lag behind writes by at most K versions or T time
   - Configurable lag (versions or time)
   - Good for globally distributed apps needing strong consistency

3. **Session**: Guarantees monotonic reads/writes within a session (default)
   - Most popular choice
   - Balance of consistency, availability, and latency

4. **Consistent Prefix**: Reads never see out-of-order writes
   - Eventual consistency with ordering guarantee

5. **Eventual**: Weakest consistency, no ordering guarantee
   - Lowest latency, lowest cost
   - Good for non-critical data (counters, likes)

Change consistency level:

```bash
az cosmosdb update \
  -g labs-cosmos-az204 \
  -n <cosmos-account-name> \
  --default-consistency-level BoundedStaleness \
  --max-staleness-prefix 100 \
  --max-interval 5
```

> **AZ-204 Exam Tip:** Session consistency is the default and most commonly used. Strong consistency is only available for single-region accounts or will limit availability in multi-region scenarios.

## Exercise 2: Databases, Containers, and Partition Keys

### Create Database and Container

```bash
# Create database
az cosmosdb sql database create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -n ProductsDB

# Create container with partition key
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --partition-key-path "/category" \
  --throughput 400
```

> **AZ-204 Exam Tip:** Partition key selection is critical:
> - **High cardinality**: Many distinct values
> - **Even distribution**: Avoid hot partitions
> - **Query patterns**: Include partition key in queries for efficiency
> - **Cannot change**: Choose carefully, cannot modify after creation

### Partition Key Examples

**Good partition keys:**
- `/userId` - for user data
- `/tenantId` - for multi-tenant apps
- `/category` - for products (if categories are balanced)
- `/deviceId` - for IoT telemetry

**Bad partition keys:**
- `/status` - (only a few values: active/inactive)
- `/createdDate` - (time-based, creates hot partition)
- `/region` - (if data is concentrated in few regions)

ðŸ“‹ Create a container for storing orders with an appropriate partition key.

<details>
  <summary>Not sure how?</summary>

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Orders \
  --partition-key-path "/customerId" \
  --throughput 400
```

Using `/customerId` allows queries for customer orders to be efficiently scoped to a single partition.

</details><br/>

## Exercise 3: Working with Items using SDK

**AZ-204 Critical:** Know how to perform CRUD operations using the SDK.

### .NET SDK Operations

```csharp
using Microsoft.Azure.Cosmos;

// Initialize client
var client = new CosmosClient(
    accountEndpoint: "https://<cosmos-account>.documents.azure.com:443/",
    authKeyOrResourceToken: "<primary-key>");

// Get container reference
var container = client.GetContainer("ProductsDB", "Products");

// CREATE: Add item
var newProduct = new Product
{
    id = Guid.NewGuid().ToString(),
    name = "Laptop",
    category = "Electronics",
    price = 999.99m
};

ItemResponse<Product> createResponse = await container.CreateItemAsync(
    newProduct,
    new PartitionKey(newProduct.category));

Console.WriteLine($"Created item. RU charge: {createResponse.RequestCharge}");

// READ: Get item by ID and partition key
ItemResponse<Product> readResponse = await container.ReadItemAsync<Product>(
    id: newProduct.id,
    partitionKey: new PartitionKey("Electronics"));

Console.WriteLine($"Read item: {readResponse.Resource.name}");

// UPDATE: Replace item
newProduct.price = 899.99m;
ItemResponse<Product> updateResponse = await container.ReplaceItemAsync(
    newProduct,
    newProduct.id,
    new PartitionKey(newProduct.category));

// DELETE: Remove item
ItemResponse<Product> deleteResponse = await container.DeleteItemAsync<Product>(
    id: newProduct.id,
    partitionKey: new PartitionKey("Electronics"));

Console.WriteLine($"Deleted item. RU charge: {deleteResponse.RequestCharge}");
```

### Query Items

```csharp
// Query with partition key (efficient)
var queryDefinition = new QueryDefinition(
    "SELECT * FROM c WHERE c.category = @category AND c.price < @maxPrice")
    .WithParameter("@category", "Electronics")
    .WithParameter("@maxPrice", 1000);

var iterator = container.GetItemQueryIterator<Product>(
    queryDefinition,
    requestOptions: new QueryRequestOptions
    {
        PartitionKey = new PartitionKey("Electronics")
    });

while (iterator.HasMoreResults)
{
    var response = await iterator.ReadNextAsync();
    Console.WriteLine($"Query RU charge: {response.RequestCharge}");

    foreach (var product in response)
    {
        Console.WriteLine($"Product: {product.name}, Price: {product.price}");
    }
}

// Cross-partition query (less efficient)
var crossPartitionQuery = new QueryDefinition(
    "SELECT * FROM c WHERE c.price < 100");

var crossPartitionIterator = container.GetItemQueryIterator<Product>(
    crossPartitionQuery,
    requestOptions: new QueryRequestOptions
    {
        MaxItemCount = 10
    });
```

> **AZ-204 Exam Tip:** Always include partition key in queries when possible. Cross-partition queries are expensive (higher RU cost) and slower.

## Exercise 4: Change Feed

**AZ-204 Critical Topic:** Change feed provides a persistent record of changes to items in a container.

### Change Feed Processor Pattern

```csharp
using Microsoft.Azure.Cosmos;

// Container to monitor
var monitoredContainer = client.GetContainer("ProductsDB", "Products");

// Lease container (tracks progress)
var leaseContainer = client.GetContainer("ProductsDB", "leases");

// Change Feed Processor
var changeFeedProcessor = monitoredContainer
    .GetChangeFeedProcessorBuilder<Product>(
        processorName: "productChangesProcessor",
        onChangesDelegate: HandleChangesAsync)
    .WithInstanceName("consoleApp")
    .WithLeaseContainer(leaseContainer)
    .Build();

// Start processing
await changeFeedProcessor.StartAsync();
Console.WriteLine("Change Feed Processor started. Listening for changes...");

// Process changes
static async Task HandleChangesAsync(
    ChangeFeedProcessorContext context,
    IReadOnlyCollection<Product> changes,
    CancellationToken cancellationToken)
{
    Console.WriteLine($"Received {changes.Count} changes");

    foreach (var product in changes)
    {
        Console.WriteLine($"Detected change: {product.name}");

        // Process change (e.g., update search index, trigger workflow)
        await ProcessProductChangeAsync(product);
    }
}
```

### Change Feed Use Cases

1. **Real-time Analytics**: Stream changes to analytics pipeline
2. **Event-driven Architecture**: Trigger Azure Functions on data changes
3. **Data Replication**: Sync data to other systems
4. **Materialized Views**: Maintain denormalized views
5. **Audit Trail**: Track all changes for compliance

> **AZ-204 Exam Tip:** Change feed provides:
> - Ordered changes per partition key
> - Insert and update operations (not deletes)
> - At-least-once delivery guarantee
> - Changes available indefinitely (unlike TTL)

## Exercise 5: Indexing Policies

**AZ-204 Topic:** Customize indexing to optimize performance and cost.

### Default Indexing Policy

By default, Cosmos DB indexes all properties automatically.

```bash
# Get current indexing policy
az cosmosdb sql container show \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --query 'resource.indexingPolicy'
```

### Custom Indexing Policy

Create a container with custom indexing:

```json
{
  "indexingMode": "consistent",
  "automatic": true,
  "includedPaths": [
    {
      "path": "/name/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "String"
        }
      ]
    },
    {
      "path": "/category/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "String"
        }
      ]
    },
    {
      "path": "/price/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "Number"
        }
      ]
    }
  ],
  "excludedPaths": [
    {
      "path": "/description/*"
    },
    {
      "path": "/images/*"
    }
  ]
}
```

Update indexing policy:

```bash
az cosmosdb sql container update \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --idx @indexing-policy.json
```

> **AZ-204 Exam Tip:** Indexing trade-offs:
> - **More indexes**: Faster reads, slower writes, higher storage cost
> - **Fewer indexes**: Slower reads, faster writes, lower storage cost
> - **Exclude large properties**: Images, long text descriptions

## Exercise 6: Request Units (RU) and Throughput

**AZ-204 Critical:** Understanding RU consumption and optimization.

### Provisioned Throughput Models

**Database-level throughput** (shared across containers):

```bash
az cosmosdb sql database create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -n SharedDB \
  --throughput 1000
```

**Container-level throughput** (dedicated):

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d SharedDB \
  -n HighPriorityData \
  --partition-key-path "/id" \
  --throughput 2000
```

**Autoscale** (automatically scales between min and max):

```bash
az cosmosdb sql container create \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d SharedDB \
  -n AutoScaleData \
  --partition-key-path "/id" \
  --max-throughput 4000
```

### Monitor RU Consumption

```csharp
// Check RU charge for operations
ItemResponse<Product> response = await container.CreateItemAsync(product);
Console.WriteLine($"Create RU charge: {response.RequestCharge}");

// Query RU consumption
var query = container.GetItemQueryIterator<Product>(queryDefinition);
var results = await query.ReadNextAsync();
Console.WriteLine($"Query RU charge: {results.RequestCharge}");
```

### Optimize RU Consumption

**Best Practices:**

1. **Include partition key in queries**: Avoid cross-partition queries
2. **Use Point Reads**: ReadItemAsync is cheapest (1 RU for 1 KB item)
3. **Limit query results**: Use `MaxItemCount` and pagination
4. **Index only needed properties**: Reduce write costs
5. **Use appropriate consistency**: Strong costs 2x more than Session
6. **Batch operations**: Use bulk operations for multiple items
7. **Cache frequently accessed data**: Use Azure Cache for Redis

```csharp
// Bulk operations (cheaper than individual operations)
List<Task> tasks = new List<Task>();
foreach (var product in products)
{
    tasks.Add(container.CreateItemAsync(product, new PartitionKey(product.category)));
}
await Task.WhenAll(tasks);
```

## Exercise 7: Time to Live (TTL)

**AZ-204 Topic:** Automatically expire items after a period.

### Enable TTL on Container

```bash
az cosmosdb sql container update \
  -g labs-cosmos-az204 \
  -a <cosmos-account-name> \
  -d ProductsDB \
  -n Products \
  --ttl 86400
```

This sets default TTL to 86400 seconds (24 hours).

### Set TTL on Individual Items

```csharp
var temporaryProduct = new Product
{
    id = Guid.NewGuid().ToString(),
    name = "Flash Sale Item",
    category = "Electronics",
    price = 49.99m,
    ttl = 3600 // Expires after 1 hour
};

await container.CreateItemAsync(temporaryProduct, new PartitionKey(temporaryProduct.category));
```

> **AZ-204 Exam Tip:** TTL values:
> - **-1**: Never expire (default if TTL enabled on container)
> - **null**: Inherit container default
> - **positive number**: Expire after N seconds

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **APIs Supported:**
   - NoSQL (native)
   - MongoDB
   - Cassandra
   - Gremlin (graph)
   - Table

2. **Consistency Levels (strongest to weakest):**
   - Strong > Bounded Staleness > Session > Consistent Prefix > Eventual

3. **Partition Strategy:**
   - Logical partitions (up to 20 GB each)
   - Physical partitions (managed by Cosmos)
   - Choose high-cardinality partition key
   - Cannot change partition key after creation

4. **Throughput Models:**
   - **Provisioned**: Fixed RU/s, predictable cost
   - **Autoscale**: Dynamic scaling, pay for actual usage
   - **Serverless**: Pay per request, good for sporadic workloads

5. **Change Feed:**
   - Ordered per partition
   - Inserts and updates only (no deletes)
   - At-least-once delivery
   - Multiple consumers supported

6. **Query Optimization:**
   - Include partition key in WHERE clause
   - Use point reads (ReadItemAsync) when possible
   - Avoid SELECT * (specify needed properties)
   - Use indexes effectively

### Common Exam Scenarios

1. **Scenario:** Globally distributed app needs strong consistency
   - **Solution:** Use Strong consistency, but understand it limits availability

2. **Scenario:** Process every change to items in real-time
   - **Solution:** Implement Change Feed Processor

3. **Scenario:** Optimize query performance for specific properties
   - **Solution:** Create custom indexing policy with included paths

4. **Scenario:** Automatically delete old data
   - **Solution:** Set TTL on container or individual items

5. **Scenario:** Reduce RU consumption for queries
   - **Solution:** Include partition key, limit properties returned, add appropriate indexes

## Best Practices

1. **Partition Key**: Choose carefully based on query patterns
2. **Consistency**: Use Session for most applications
3. **Indexing**: Customize for your workload (exclude unnecessary paths)
4. **Query**: Always include partition key when possible
5. **Monitoring**: Track RU consumption and throttling
6. **SDK**: Use latest SDK with bulk support
7. **Testing**: Test with production-like data volumes

## Cleanup

```bash
az group delete -y -n labs-cosmos-az204 --no-wait
```

## Additional Resources

- [Azure Cosmos DB documentation](https://docs.microsoft.com/en-us/azure/cosmos-db/)
- [Cosmos DB SDK for .NET](https://docs.microsoft.com/en-us/azure/cosmos-db/sql/sql-api-sdk-dotnet-standard)
- [Partitioning in Azure Cosmos DB](https://docs.microsoft.com/en-us/azure/cosmos-db/partitioning-overview)
- [Change feed in Azure Cosmos DB](https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
