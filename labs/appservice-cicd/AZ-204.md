# Azure App Service CI/CD - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Implement Azure App Service Web Apps (15-20%)

This lab focuses on continuous integration and continuous deployment (CI/CD) strategies for Azure App Service, including GitHub Actions, Azure DevOps, deployment patterns, and rollback strategies.

## Prerequisites

Complete the [basic App Service lab](../appservice/README.md) and [App Service Configuration](../appservice-config/AZ-204.md) exercises first.

## AZ-204 Exam Skills Covered

- Implement CI/CD with GitHub Actions
- Configure Azure DevOps Pipelines for App Service
- Implement deployment slots workflow
- Execute blue-green deployments
- Implement canary releases (traffic splitting)
- Configure rollback strategies
- Use deployment centers in Azure Portal
- Implement container-based CI/CD

## Exercise 1: GitHub Actions Integration

**AZ-204 Critical Topic:** Automate deployments using GitHub Actions workflows.

### Setup

```bash
az group create -n labs-appservice-cicd-az204 --tags courselabs=azure -l eastus

# Create App Service Plan
az appservice plan create \
  -g labs-appservice-cicd-az204 \
  -n cicd-plan \
  --sku S1 \
  --location eastus

# Create web app
az webapp create \
  -g labs-appservice-cicd-az204 \
  -p cicd-plan \
  -n <webapp-name> \
  --runtime "NODE:18-lts"

# Create staging slot
az webapp deployment slot create \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging
```

### Configure GitHub Actions Deployment

```bash
# Get publish profile
az webapp deployment list-publishing-profiles \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --xml > publishProfile.xml

# For staging slot
az webapp deployment list-publishing-profiles \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --xml > publishProfile-staging.xml
```

**GitHub Secrets Setup:**
1. Go to GitHub repository → Settings → Secrets and variables → Actions
2. Add secret: `AZURE_WEBAPP_PUBLISH_PROFILE` (content of publishProfile.xml)
3. Add secret: `AZURE_WEBAPP_PUBLISH_PROFILE_STAGING` (content of publishProfile-staging.xml)

### GitHub Actions Workflow - Node.js

**.github/workflows/deploy.yml:**

```yaml
name: Deploy to Azure App Service

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: <webapp-name>
  NODE_VERSION: '18.x'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build application
        run: npm run build --if-present

      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v3
        with:
          name: node-app
          path: .

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-test
    environment:
      name: 'Staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: node-app

      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_STAGING }}
          package: .

  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: node-app

      - name: Deploy to Azure Web App Production
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: .
```

### GitHub Actions Workflow - .NET

**.github/workflows/dotnet-deploy.yml:**

```yaml
name: Deploy .NET App to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: <webapp-name>
  DOTNET_VERSION: '8.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore --configuration Release

      - name: Test
        run: dotnet test --no-build --configuration Release --verbosity normal

      - name: Publish
        run: dotnet publish --no-build --configuration Release --output ./publish

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: dotnet-app
          path: ./publish

  deploy-to-staging:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Staging'

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: dotnet-app

      - name: Deploy to Azure Web App Staging
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_STAGING }}
          package: .

  swap-to-production:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    environment:
      name: 'Production'

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Swap Staging to Production
        run: |
          az webapp deployment slot swap \
            --resource-group labs-appservice-cicd-az204 \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --slot staging \
            --target-slot production
```

> **AZ-204 Exam Tip:** GitHub Actions deployment methods:
> - **Publish Profile**: Simple, app-level credentials (good for single apps)
> - **Service Principal**: Enterprise-grade, subscription-level access (recommended)
> - **GitHub Environments**: Protection rules, approvals, secrets per environment
> - **Artifacts**: Share build output between jobs
> - **Matrix Strategy**: Test across multiple versions/platforms

### Using Service Principal (Recommended)

```bash
# Create service principal
az ad sp create-for-rbac \
  --name "github-actions-sp" \
  --role contributor \
  --scopes /subscriptions/<subscription-id>/resourceGroups/labs-appservice-cicd-az204 \
  --sdk-auth

# Output JSON - add as GitHub secret AZURE_CREDENTIALS
```

**Workflow with Service Principal:**

```yaml
- name: Azure Login
  uses: azure/login@v1
  with:
    creds: ${{ secrets.AZURE_CREDENTIALS }}

- name: Deploy to Azure Web App
  uses: azure/webapps-deploy@v2
  with:
    app-name: ${{ env.AZURE_WEBAPP_NAME }}
    package: ./publish
```

## Exercise 2: Azure DevOps Pipelines

**AZ-204 Critical Topic:** Implement CI/CD using Azure Pipelines.

### Create Service Connection

```bash
# Create service connection in Azure DevOps
# 1. Project Settings → Service connections → New service connection
# 2. Choose Azure Resource Manager
# 3. Service Principal (automatic) or use existing SP
# 4. Scope: Subscription or Resource Group
# 5. Name: azure-connection
```

### Azure Pipeline - YAML (Node.js)

**azure-pipelines.yml:**

```yaml
trigger:
  branches:
    include:
      - main
      - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  azureSubscription: 'azure-connection'
  webAppName: '<webapp-name>'
  nodeVersion: '18.x'

stages:
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildJob
        displayName: 'Build Application'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - script: |
              npm ci
              npm run build
              npm test
            displayName: 'npm install, build and test'

          - task: ArchiveFiles@2
            displayName: 'Archive files'
            inputs:
              rootFolderOrFile: '$(System.DefaultWorkingDirectory)'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip'
              replaceExistingArchive: true

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Artifact'
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'drop'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployStaging
        displayName: 'Deploy to Staging Slot'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebApp@1
                  displayName: 'Deploy Azure Web App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'webAppLinux'
                    appName: $(webAppName)
                    deployToSlotOrASE: true
                    resourceGroupName: 'labs-appservice-cicd-az204'
                    slotName: 'staging'
                    package: '$(Pipeline.Workspace)/drop/$(Build.BuildId).zip'

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Swap Staging to Production'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureAppServiceManage@0
                  displayName: 'Swap Slots'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    WebAppName: $(webAppName)
                    ResourceGroupName: 'labs-appservice-cicd-az204'
                    SourceSlot: 'staging'
                    SwapWithProduction: true
```

### Azure Pipeline - YAML (.NET)

**azure-pipelines-dotnet.yml:**

```yaml
trigger:
  - main

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  azureSubscription: 'azure-connection'
  webAppName: '<webapp-name>'

stages:
  - stage: Build
    jobs:
      - job: BuildJob
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET 8.0'
            inputs:
              version: '8.0.x'

          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: '**/*.csproj'

          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: '**/*.csproj'
              arguments: '--configuration $(buildConfiguration)'

          - task: DotNetCoreCLI@2
            displayName: 'Test'
            inputs:
              command: 'test'
              projects: '**/*Tests/*.csproj'
              arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage"'

          - task: DotNetCoreCLI@2
            displayName: 'Publish'
            inputs:
              command: 'publish'
              publishWebProjects: true
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'
              zipAfterPublish: true

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Artifact'
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'drop'

  - stage: DeployToStaging
    dependsOn: Build
    jobs:
      - deployment: DeployStaging
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebApp@1
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(webAppName)
                    deployToSlotOrASE: true
                    resourceGroupName: 'labs-appservice-cicd-az204'
                    slotName: 'staging'
                    package: '$(Pipeline.Workspace)/drop/*.zip'

  - stage: DeployToProduction
    dependsOn: DeployToStaging
    jobs:
      - deployment: DeployProduction
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureAppServiceManage@0
                  inputs:
                    azureSubscription: $(azureSubscription)
                    Action: 'Swap Slots'
                    WebAppName: $(webAppName)
                    ResourceGroupName: 'labs-appservice-cicd-az204'
                    SourceSlot: 'staging'
                    SwapWithProduction: true
```

> **AZ-204 Exam Tip:** Azure Pipelines concepts:
> - **Stages**: Logical boundaries (Build, Test, Deploy)
> - **Jobs**: Unit of execution, run on agents
> - **Steps**: Individual tasks or scripts
> - **Deployment Jobs**: Special job type with deployment strategies
> - **Environments**: Deployment targets with approvals and checks
> - **Service Connections**: Secure connections to Azure
> - **Artifacts**: Build outputs passed between stages

## Exercise 3: Deployment Slots Workflow

**AZ-204 Critical Topic:** Using deployment slots for staged deployments.

### Multi-Slot Strategy

```bash
# Create multiple slots for different purposes
az webapp deployment slot create \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot dev

az webapp deployment slot create \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging

az webapp deployment slot create \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot qa
```

**Typical Workflow:**
1. **Development** → dev slot (continuous deployment from dev branch)
2. **QA/Testing** → qa slot (automated tests)
3. **Staging** → staging slot (pre-production validation)
4. **Production** → production slot (swap from staging)

### Deployment Workflow with Validation

```bash
# 1. Deploy to staging
az webapp deployment source config-zip \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --src app.zip

# 2. Validate staging (manual or automated)
curl https://<webapp-name>-staging.azurewebsites.net/health

# 3. Swap with preview (apply production settings to staging)
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production \
  --action preview

# 4. Validate staging with production settings
curl https://<webapp-name>-staging.azurewebsites.net/health

# 5. Complete swap
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production \
  --action swap

# If issues found, cancel swap
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production \
  --action reset
```

### Slot Settings Best Practices

```bash
# Configure slot-specific settings
az webapp config appsettings set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --settings \
    ENVIRONMENT="Staging" \
    DATABASE_NAME="staging-db" \
    ENABLE_FEATURE_X="true" \
  --slot-settings ENVIRONMENT DATABASE_NAME

# Production settings
az webapp config appsettings set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --settings \
    ENVIRONMENT="Production" \
    DATABASE_NAME="prod-db" \
    ENABLE_FEATURE_X="false" \
  --slot-settings ENVIRONMENT DATABASE_NAME
```

> **AZ-204 Exam Tip:** Slot swap behavior:
> - **Swapped**: App code, general settings, continuous deployment settings
> - **Not swapped**: Slot settings, publishing endpoints, custom domains per slot
> - **Swap process**: Settings applied → warm-up → routing changed
> - **Auto-swap**: Automatically swap after deployment (staging to production)
> - **Rollback**: Simply swap back to previous state

### Auto-Swap Configuration

```bash
# Enable auto-swap (swap staging to production automatically)
az webapp deployment slot auto-swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --auto-swap-slot production

# Disable auto-swap
az webapp deployment slot auto-swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --disable
```

## Exercise 4: Blue-Green Deployments

**AZ-204 Topic:** Zero-downtime deployment strategy using slots.

### Blue-Green Pattern with App Service

**Blue-Green Concept:**
- **Blue**: Current production (production slot)
- **Green**: New version (staging slot)
- **Switch**: Swap slots instantly
- **Rollback**: Swap back if issues

### Implement Blue-Green Deployment

```bash
# Step 1: Deploy new version to green (staging)
az webapp deployment source config-zip \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --src app-v2.zip

# Step 2: Verify green environment
curl https://<webapp-name>-staging.azurewebsites.net/health
curl https://<webapp-name>-staging.azurewebsites.net/api/version

# Step 3: Swap to make green production (blue becomes staging)
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production

# Step 4: Monitor production
# If issues detected, rollback by swapping back

# Rollback (blue back to production)
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production
```

### Blue-Green with GitHub Actions

```yaml
name: Blue-Green Deployment

on:
  workflow_dispatch:

jobs:
  deploy-green:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build application
        run: |
          npm install
          npm run build

      - name: Deploy to Green (Staging)
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_STAGING }}

      - name: Warm up Green environment
        run: |
          sleep 30
          curl https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net/health

  switch-to-green:
    needs: deploy-green
    runs-on: ubuntu-latest
    environment: 'production'
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Swap Staging to Production (Blue ↔ Green)
        run: |
          az webapp deployment slot swap \
            -g labs-appservice-cicd-az204 \
            -n ${{ env.AZURE_WEBAPP_NAME }} \
            --slot staging \
            --target-slot production

      - name: Verify Production
        run: |
          sleep 10
          curl https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/health
```

## Exercise 5: Canary Releases (Traffic Splitting)

**AZ-204 Critical Topic:** Gradually route traffic to new version.

### Configure Traffic Routing

```bash
# Route 10% of traffic to staging slot
az webapp traffic-routing set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --distribution staging=10

# Gradually increase traffic
az webapp traffic-routing set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --distribution staging=25

# Increase to 50%
az webapp traffic-routing set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --distribution staging=50

# Full cutover (100% to staging, then swap)
az webapp traffic-routing set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --distribution staging=100

# Complete migration by swapping
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production

# Reset routing after swap
az webapp traffic-routing clear \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name>
```

### View Current Traffic Distribution

```bash
az webapp traffic-routing show \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  -o table
```

> **AZ-204 Exam Tip:** Traffic routing features:
> - **Testing in Production**: Route small percentage to new version
> - **Gradual Rollout**: Incrementally increase traffic
> - **A/B Testing**: Compare versions with real traffic
> - **Requires Standard+ tier**: Traffic routing not available in Basic
> - **Cookie-based**: Users stay on same version (sticky sessions)
> - **Monitoring**: Track metrics per slot to compare performance

### Canary Deployment Script

```bash
#!/bin/bash
# canary-deployment.sh

RESOURCE_GROUP="labs-appservice-cicd-az204"
WEBAPP_NAME="<webapp-name>"

echo "Deploying new version to staging..."
az webapp deployment source config-zip \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --slot staging \
  --src app-v2.zip

echo "Routing 10% traffic to staging..."
az webapp traffic-routing set \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --distribution staging=10

sleep 300  # Wait 5 minutes, monitor metrics

echo "Increasing to 25%..."
az webapp traffic-routing set \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --distribution staging=25

sleep 300

echo "Increasing to 50%..."
az webapp traffic-routing set \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --distribution staging=50

sleep 300

echo "Full cutover to 100%..."
az webapp traffic-routing set \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --distribution staging=100

sleep 120

echo "Swapping slots..."
az webapp deployment slot swap \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME \
  --slot staging \
  --target-slot production

echo "Clearing traffic routing..."
az webapp traffic-routing clear \
  -g $RESOURCE_GROUP \
  -n $WEBAPP_NAME

echo "Canary deployment complete!"
```

## Exercise 6: Rollback Strategies

**AZ-204 Critical Topic:** Quickly recover from failed deployments.

### Method 1: Slot Swap Rollback

```bash
# If issues detected after swap, immediately swap back
az webapp deployment slot swap \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --slot staging \
  --target-slot production
```

**Advantages:**
- Instant rollback (seconds)
- No redeployment needed
- Previous version still in staging slot

### Method 2: Deployment History Rollback

```bash
# List deployment history
az webapp deployment list-publishing-credentials \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name>

# View deployments via Kudu API
curl -u '$<webapp-name>:<password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/deployments

# Redeploy previous version (via deployment ID)
curl -X PUT -u '$<webapp-name>:<password>' \
  https://<webapp-name>.scm.azurewebsites.net/api/deployments/<deployment-id>
```

### Method 3: Traffic Routing Rollback

```bash
# Immediately route traffic back to production slot
az webapp traffic-routing clear \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name>

# Or route 100% to production
az webapp traffic-routing set \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --distribution production=100
```

### Method 4: Artifact Rollback

```bash
# Redeploy previous artifact from storage or CI/CD system
az webapp deployment source config-zip \
  -g labs-appservice-cicd-az204 \
  -n <webapp-name> \
  --src previous-version.zip
```

### Automated Rollback Strategy

**GitHub Actions with Automated Rollback:**

```yaml
name: Deploy with Auto Rollback

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Production
        id: deploy
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}

      - name: Health Check
        id: health
        run: |
          sleep 30
          response=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/health)
          if [ $response -ne 200 ]; then
            echo "Health check failed with status $response"
            exit 1
          fi

      - name: Rollback on Failure
        if: failure()
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: ${{ env.PREVIOUS_ARTIFACT }}
```

> **AZ-204 Exam Tip:** Rollback best practices:
> - **Keep previous version**: Always maintain previous working version
> - **Automated health checks**: Detect issues immediately
> - **Slot swap preferred**: Fastest rollback method
> - **Monitor metrics**: Track error rates, response times post-deployment
> - **Document procedures**: Clear rollback runbook
> - **Test rollback**: Regularly practice rollback procedures
> - **Database migrations**: Handle schema changes carefully (forward-compatible)

## Exercise 7: Container-Based CI/CD

**AZ-204 Topic:** Deploy containerized applications with CI/CD.

### Azure Container Registry Integration

```bash
# Create Azure Container Registry
az acr create \
  -g labs-appservice-cicd-az204 \
  -n <acr-name> \
  --sku Basic \
  --admin-enabled true

# Get ACR credentials
ACR_USERNAME=$(az acr credential show -n <acr-name> --query username -o tsv)
ACR_PASSWORD=$(az acr credential show -n <acr-name> --query passwords[0].value -o tsv)

# Create container-based web app
az webapp create \
  -g labs-appservice-cicd-az204 \
  -p cicd-plan \
  -n <container-webapp-name> \
  --deployment-container-image-name <acr-name>.azurecr.io/myapp:latest \
  --docker-registry-server-url https://<acr-name>.azurecr.io \
  --docker-registry-server-user $ACR_USERNAME \
  --docker-registry-server-password $ACR_PASSWORD

# Enable continuous deployment from ACR
az webapp deployment container config \
  -g labs-appservice-cicd-az204 \
  -n <container-webapp-name> \
  --enable-cd true
```

### Dockerfile Example

```dockerfile
# Dockerfile
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=build /app/dist ./dist
COPY --from=build /app/node_modules ./node_modules
EXPOSE 8080
CMD ["node", "dist/server.js"]
```

### GitHub Actions - Container Deployment

```yaml
name: Container CI/CD

on:
  push:
    branches: [ main ]

env:
  ACR_NAME: <acr-name>
  IMAGE_NAME: myapp
  WEBAPP_NAME: <container-webapp-name>

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Azure Container Registry Login
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }} .
          docker tag ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }} \
                     ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Web App
        run: |
          az webapp config container set \
            --name ${{ env.WEBAPP_NAME }} \
            --resource-group labs-appservice-cicd-az204 \
            --docker-custom-image-name ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}

          az webapp restart \
            --name ${{ env.WEBAPP_NAME }} \
            --resource-group labs-appservice-cicd-az204
```

### Azure DevOps - Container Pipeline

```yaml
trigger:
  - main

variables:
  dockerRegistryServiceConnection: 'acr-connection'
  imageRepository: 'myapp'
  containerRegistry: '<acr-name>.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  azureSubscription: 'azure-connection'
  webAppName: '<container-webapp-name>'

stages:
  - stage: Build
    jobs:
      - job: BuildAndPush
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Docker@2
            displayName: 'Build and Push'
            inputs:
              containerRegistry: $(dockerRegistryServiceConnection)
              repository: $(imageRepository)
              command: 'buildAndPush'
              Dockerfile: $(dockerfilePath)
              tags: |
                $(tag)
                latest

  - stage: Deploy
    dependsOn: Build
    jobs:
      - deployment: DeployContainer
        environment: 'production'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: 'Deploy Container to Web App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(webAppName)
                    containers: $(containerRegistry)/$(imageRepository):$(tag)
```

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **GitHub Actions:**
   - Workflows triggered by events (push, pull_request, workflow_dispatch)
   - Jobs run in parallel by default
   - Artifacts shared between jobs
   - Environments for approvals and secrets
   - Publish profiles or service principals for authentication

2. **Azure DevOps Pipelines:**
   - YAML pipelines (multi-stage)
   - Stages → Jobs → Steps hierarchy
   - Service connections for Azure access
   - Deployment jobs with strategies
   - Artifacts published and downloaded

3. **Deployment Slots:**
   - Standard tier or higher required
   - Slot-specific vs swappable settings
   - Swap process includes warm-up
   - Easy rollback by swapping back
   - Auto-swap for automated deployments

4. **Blue-Green Deployments:**
   - Zero-downtime deployment
   - New version in staging (green)
   - Swap to make staging production
   - Old version becomes staging (blue)
   - Instant rollback capability

5. **Canary Releases:**
   - Traffic splitting between slots
   - Gradual rollout (10% → 25% → 50% → 100%)
   - A/B testing capability
   - Cookie-based routing (sticky sessions)
   - Requires Standard tier or higher

6. **Rollback Strategies:**
   - Slot swap (fastest)
   - Traffic routing (immediate)
   - Deployment history
   - Artifact redeployment
   - Automated health checks

7. **Container CI/CD:**
   - Build and push to Azure Container Registry
   - Continuous deployment from ACR
   - Image tagging strategies
   - Multi-stage deployments
   - Container slots support

### Common Exam Scenarios

1. **Scenario:** Deploy without downtime
   - **Solution:** Use deployment slots, deploy to staging, test, swap to production

2. **Scenario:** Test new version with small percentage of users
   - **Solution:** Deploy to staging slot, configure traffic routing (e.g., 10%)

3. **Scenario:** Automate deployments from GitHub
   - **Solution:** Create GitHub Actions workflow with azure/webapps-deploy action

4. **Scenario:** Quick rollback after failed deployment
   - **Solution:** Swap slots back (previous version still in staging slot)

5. **Scenario:** Different database for staging and production
   - **Solution:** Configure slot-specific connection strings

6. **Scenario:** Gradual rollout of new feature
   - **Solution:** Canary release with incremental traffic routing

7. **Scenario:** Deploy containerized app with CI/CD
   - **Solution:** Build/push to ACR, enable continuous deployment, configure webhook

## Best Practices

1. **Always deploy to staging first** before production
2. **Use slot-specific settings** for environment-specific configuration
3. **Implement health checks** to validate deployments
4. **Test rollback procedures** regularly
5. **Use traffic routing** for gradual rollouts of major changes
6. **Tag container images** with build ID and latest
7. **Enable continuous deployment** from container registry
8. **Configure approval gates** for production deployments
9. **Monitor deployments** with Application Insights
10. **Automate testing** in CI/CD pipeline before deployment
11. **Keep deployment artifacts** for rollback capability
12. **Document deployment procedures** and runbooks

## Cleanup

```bash
az group delete -y -n labs-appservice-cicd-az204 --no-wait
```

## Additional Resources

- [GitHub Actions for Azure](https://docs.microsoft.com/en-us/azure/developer/github/github-actions)
- [Azure Pipelines documentation](https://docs.microsoft.com/en-us/azure/devops/pipelines/)
- [Deployment slots](https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots)
- [Traffic routing](https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots#route-traffic)
- [Container deployment](https://docs.microsoft.com/en-us/azure/app-service/configure-custom-container)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
