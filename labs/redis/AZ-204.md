# Azure Cache for Redis - AZ-204 Exam Exercises

**AZ-204 Exam Domain:** Develop for Azure Storage (15-20%)

This lab extends the basic Azure Cache for Redis exercises with specific scenarios and skills required for the AZ-204 exam.

## Prerequisites

Complete the basic [Redis lab](README.md) first to understand fundamental caching operations.

## AZ-204 Exam Skills Covered

- Understand cache tiers and sizing decisions
- Implement cache-aside pattern
- Store and retrieve session state
- Use Redis data types and commands
- Configure persistence options
- Use StackExchange.Redis in .NET applications
- Apply caching best practices

## Exercise 1: Cache Tiers and Sizing

**AZ-204 Critical Topic:** Understand the differences between Basic, Standard, and Premium tiers.

### Cache Tier Comparison

| Feature | Basic | Standard | Premium |
|---------|-------|----------|---------|
| **SLA** | No SLA | 99.9% | 99.95% |
| **Replication** | Single node | Primary + Replica | Primary + Replica |
| **Availability** | No failover | Automatic failover | Automatic failover |
| **Persistence** | ‚ùå No | ‚ùå No | ‚úÖ RDB & AOF |
| **Clustering** | ‚ùå No | ‚ùå No | ‚úÖ Yes (up to 10 shards) |
| **VNet** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Geo-replication** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Import/Export** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Zone Redundancy** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Max Memory** | 53 GB | 53 GB | 1.2 TB |
| **Use Case** | Dev/Test | Production | Enterprise |

### Cache Sizes (C-Series Standard)

- **C0**: 250 MB - Dev/test only
- **C1**: 1 GB - Small workloads
- **C2**: 2.5 GB - Medium workloads
- **C3**: 6 GB - Large workloads
- **C4**: 13 GB - Very large workloads
- **C5**: 26 GB - Enterprise workloads
- **C6**: 53 GB - Maximum size

### Create Redis Cache

```bash
az group create -n labs-redis-az204 --tags courselabs=azure -l eastus

# Basic tier (development only)
az redis create \
  -g labs-redis-az204 \
  -n redis-basic-$RANDOM \
  -l eastus \
  --sku Basic \
  --vm-size c0

# Standard tier (production)
REDIS_NAME=redis-std-$RANDOM
az redis create \
  -g labs-redis-az204 \
  -n $REDIS_NAME \
  -l eastus \
  --sku Standard \
  --vm-size c1 \
  --enable-non-ssl-port false

# Premium tier (enterprise)
az redis create \
  -g labs-redis-az204 \
  -n redis-premium-$RANDOM \
  -l eastus \
  --sku Premium \
  --vm-size p1 \
  --enable-non-ssl-port false
```

### View Cache Details

```bash
az redis show \
  -g labs-redis-az204 \
  -n $REDIS_NAME \
  --query '{name:name, sku:sku.name, size:sku.family+sku.capacity, sslPort:sslPort, hostName:hostName, provisioningState:provisioningState}' \
  -o table
```

### Scale Redis Cache

```bash
# Scale up within same tier
az redis update \
  -g labs-redis-az204 \
  -n $REDIS_NAME \
  --set sku.capacity=2

# Upgrade to Premium (allows clustering, persistence, VNet)
az redis update \
  -g labs-redis-az204 \
  -n $REDIS_NAME \
  --set sku.name=Premium sku.family=P sku.capacity=1
```

üìã Create a Standard C2 cache for production workloads and verify it's accessible.

<details>
  <summary>Not sure how?</summary>

```bash
# Create Standard C2 cache
az redis create \
  -g labs-redis-az204 \
  -n redis-prod-$RANDOM \
  -l eastus \
  --sku Standard \
  --vm-size c2 \
  --enable-non-ssl-port false

# Get access keys
REDIS_HOST=$(az redis show -g labs-redis-az204 -n redis-prod-<suffix> --query hostName -o tsv)
REDIS_KEY=$(az redis list-keys -g labs-redis-az204 -n redis-prod-<suffix> --query primaryKey -o tsv)

echo "Host: $REDIS_HOST"
echo "Key: $REDIS_KEY"
```

</details><br/>

> **AZ-204 Exam Tip:**
> - **Basic**: Dev/test only, no SLA, single node, no replication
> - **Standard**: Production, 99.9% SLA, automatic replication, no persistence
> - **Premium**: Enterprise, 99.95% SLA, clustering, persistence, VNet, geo-replication
> - Cannot downgrade from Premium to Standard/Basic
> - Scaling causes brief connection interruption
> - Size based on data + overhead (30% minimum)

## Exercise 2: Cache-Aside Pattern Implementation

**AZ-204 Critical Pattern:** Most common caching pattern for Azure applications.

### Understanding Cache-Aside Pattern

**Flow:**
1. Application checks cache first
2. If found (cache hit), return cached data
3. If not found (cache miss):
   - Retrieve from database
   - Store in cache for future requests
   - Return data to caller
4. On update: Invalidate/update cache

**Benefits:**
- Reduces database load
- Improves response time
- Handles cache failures gracefully

### Get Connection Details

```bash
# Get connection string
REDIS_CONNECTION=$(az redis show-connection-string \
  -g labs-redis-az204 \
  -n $REDIS_NAME \
  --query connectionString -o tsv)

echo $REDIS_CONNECTION
```

### Implement Cache-Aside in .NET

```csharp
using StackExchange.Redis;
using System.Text.Json;

public class ProductRepository
{
    private readonly IDatabase _cache;
    private readonly IProductDatabase _database;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromMinutes(5);

    public ProductRepository(IConnectionMultiplexer redis, IProductDatabase database)
    {
        _cache = redis.GetDatabase();
        _database = database;
    }

    // Cache-Aside Pattern - Read
    public async Task<Product> GetProductAsync(int productId)
    {
        string cacheKey = $"product:{productId}";

        // 1. Try to get from cache
        string cachedProduct = await _cache.StringGetAsync(cacheKey);

        if (!string.IsNullOrEmpty(cachedProduct))
        {
            // Cache hit - return cached data
            Console.WriteLine($"Cache HIT for product {productId}");
            return JsonSerializer.Deserialize<Product>(cachedProduct);
        }

        // Cache miss - get from database
        Console.WriteLine($"Cache MISS for product {productId}");
        var product = await _database.GetProductAsync(productId);

        if (product != null)
        {
            // Store in cache for future requests
            string serialized = JsonSerializer.Serialize(product);
            await _cache.StringSetAsync(cacheKey, serialized, _cacheExpiration);
        }

        return product;
    }

    // Cache-Aside Pattern - Write (Update)
    public async Task UpdateProductAsync(Product product)
    {
        // 1. Update database first
        await _database.UpdateProductAsync(product);

        // 2. Invalidate cache (remove stale data)
        string cacheKey = $"product:{product.Id}";
        await _cache.KeyDeleteAsync(cacheKey);

        // Alternative: Update cache immediately
        // string serialized = JsonSerializer.Serialize(product);
        // await _cache.StringSetAsync(cacheKey, serialized, _cacheExpiration);
    }

    // Cache-Aside Pattern - Delete
    public async Task DeleteProductAsync(int productId)
    {
        // 1. Delete from database
        await _database.DeleteProductAsync(productId);

        // 2. Remove from cache
        string cacheKey = $"product:{productId}";
        await _cache.KeyDeleteAsync(cacheKey);
    }

    // Get multiple products with cache
    public async Task<List<Product>> GetProductsByCategoryAsync(string category)
    {
        string cacheKey = $"products:category:{category}";

        // Try cache first
        string cached = await _cache.StringGetAsync(cacheKey);
        if (!string.IsNullOrEmpty(cached))
        {
            return JsonSerializer.Deserialize<List<Product>>(cached);
        }

        // Get from database
        var products = await _database.GetProductsByCategoryAsync(category);

        // Cache results
        string serialized = JsonSerializer.Serialize(products);
        await _cache.StringSetAsync(cacheKey, serialized, TimeSpan.FromMinutes(10));

        return products;
    }
}
```

### Initialize Redis Connection

```csharp
using StackExchange.Redis;

public class RedisConnection
{
    private static Lazy<ConnectionMultiplexer> _lazyConnection;

    static RedisConnection()
    {
        var configurationOptions = ConfigurationOptions.Parse(
            "<redis-name>.redis.cache.windows.net:6380,password=<access-key>,ssl=True,abortConnect=False");

        configurationOptions.ConnectTimeout = 5000;
        configurationOptions.SyncTimeout = 5000;

        _lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
            ConnectionMultiplexer.Connect(configurationOptions));
    }

    public static ConnectionMultiplexer Connection => _lazyConnection.Value;

    public static IDatabase GetDatabase() => Connection.GetDatabase();
}

// Usage
var redis = RedisConnection.Connection;
var db = redis.GetDatabase();
```

### Advanced Cache-Aside with Retry

```csharp
public async Task<Product> GetProductWithRetryAsync(int productId)
{
    string cacheKey = $"product:{productId}";

    try
    {
        // Try cache with timeout
        var cachedValue = await _cache.StringGetAsync(cacheKey);
        if (cachedValue.HasValue)
        {
            return JsonSerializer.Deserialize<Product>(cachedValue);
        }
    }
    catch (RedisException ex)
    {
        // Cache unavailable, log and continue to database
        Console.WriteLine($"Cache error: {ex.Message}");
    }

    // Get from database
    var product = await _database.GetProductAsync(productId);

    // Try to cache (fire-and-forget)
    _ = Task.Run(async () =>
    {
        try
        {
            string serialized = JsonSerializer.Serialize(product);
            await _cache.StringSetAsync(cacheKey, serialized, _cacheExpiration);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to cache product: {ex.Message}");
        }
    });

    return product;
}
```

üìã Implement cache-aside pattern for a user profile lookup with 30-minute expiration.

<details>
  <summary>Not sure how?</summary>

```csharp
public class UserProfileRepository
{
    private readonly IDatabase _cache;
    private readonly IUserDatabase _database;

    public async Task<UserProfile> GetUserProfileAsync(string userId)
    {
        string cacheKey = $"user:profile:{userId}";

        // Check cache
        string cached = await _cache.StringGetAsync(cacheKey);
        if (!string.IsNullOrEmpty(cached))
        {
            Console.WriteLine("Cache hit");
            return JsonSerializer.Deserialize<UserProfile>(cached);
        }

        // Cache miss - get from database
        Console.WriteLine("Cache miss - fetching from database");
        var profile = await _database.GetUserProfileAsync(userId);

        if (profile != null)
        {
            // Cache with 30-minute expiration
            string serialized = JsonSerializer.Serialize(profile);
            await _cache.StringSetAsync(
                cacheKey,
                serialized,
                TimeSpan.FromMinutes(30));
        }

        return profile;
    }

    public async Task UpdateUserProfileAsync(UserProfile profile)
    {
        // Update database
        await _database.UpdateUserProfileAsync(profile);

        // Invalidate cache
        await _cache.KeyDeleteAsync($"user:profile:{profile.UserId}");
    }
}
```

</details><br/>

> **AZ-204 Exam Tip:** Cache-Aside pattern key points:
> - Application manages cache (not automatic)
> - Cache miss: Read from database, populate cache
> - Write: Update database first, then invalidate/update cache
> - Always handle cache failures gracefully
> - Set appropriate TTL to balance freshness and performance
> - Use for: Read-heavy workloads, expensive queries, frequently accessed data

## Exercise 3: Session State Storage

**AZ-204 Use Case:** Store user session data in Redis for scalable web applications.

### Configure Session State in ASP.NET Core

```csharp
// Program.cs or Startup.cs
using Microsoft.Extensions.Caching.StackExchangeRedis;

var builder = WebApplication.CreateBuilder(args);

// Add Redis distributed cache
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
    options.InstanceName = "SessionStore:";
});

// Add session support
builder.Services.AddSession(options =>
{
    options.IdleTimeout = TimeSpan.FromMinutes(30);
    options.Cookie.HttpOnly = true;
    options.Cookie.IsEssential = true;
});

var app = builder.Build();

// Use session middleware
app.UseSession();

app.MapControllers();
app.Run();
```

### Store and Retrieve Session Data

```csharp
using Microsoft.AspNetCore.Http;
using System.Text.Json;

[ApiController]
[Route("api/[controller]")]
public class SessionController : ControllerBase
{
    // Store simple value
    [HttpPost("login")]
    public IActionResult Login([FromBody] LoginRequest request)
    {
        // Authenticate user...
        var userId = "user123";

        // Store in session
        HttpContext.Session.SetString("UserId", userId);
        HttpContext.Session.SetString("Username", request.Username);
        HttpContext.Session.SetInt32("LoginTime", (int)DateTimeOffset.UtcNow.ToUnixTimeSeconds());

        return Ok(new { message = "Login successful" });
    }

    // Retrieve session value
    [HttpGet("profile")]
    public IActionResult GetProfile()
    {
        var userId = HttpContext.Session.GetString("UserId");
        if (string.IsNullOrEmpty(userId))
        {
            return Unauthorized(new { message = "Not logged in" });
        }

        var username = HttpContext.Session.GetString("Username");
        var loginTime = HttpContext.Session.GetInt32("LoginTime");

        return Ok(new
        {
            userId,
            username,
            loginTime = DateTimeOffset.FromUnixTimeSeconds(loginTime ?? 0)
        });
    }

    // Store complex object
    [HttpPost("cart/add")]
    public IActionResult AddToCart([FromBody] CartItem item)
    {
        var cartJson = HttpContext.Session.GetString("ShoppingCart");
        var cart = string.IsNullOrEmpty(cartJson)
            ? new List<CartItem>()
            : JsonSerializer.Deserialize<List<CartItem>>(cartJson);

        cart.Add(item);

        HttpContext.Session.SetString("ShoppingCart", JsonSerializer.Serialize(cart));

        return Ok(new { itemCount = cart.Count });
    }

    // Clear session
    [HttpPost("logout")]
    public IActionResult Logout()
    {
        HttpContext.Session.Clear();
        return Ok(new { message = "Logged out successfully" });
    }
}
```

### Direct Redis Session Management

```csharp
public class SessionManager
{
    private readonly IDatabase _cache;
    private readonly TimeSpan _sessionTimeout = TimeSpan.FromMinutes(30);

    public SessionManager(IConnectionMultiplexer redis)
    {
        _cache = redis.GetDatabase();
    }

    // Create session
    public async Task<string> CreateSessionAsync(string userId, Dictionary<string, string> sessionData)
    {
        string sessionId = Guid.NewGuid().ToString();
        string sessionKey = $"session:{sessionId}";

        // Store session data as hash
        var entries = sessionData.Select(kvp =>
            new HashEntry(kvp.Key, kvp.Value)).ToArray();

        await _cache.HashSetAsync(sessionKey, entries);
        await _cache.KeyExpireAsync(sessionKey, _sessionTimeout);

        return sessionId;
    }

    // Get session value
    public async Task<string> GetSessionValueAsync(string sessionId, string key)
    {
        string sessionKey = $"session:{sessionId}";
        var value = await _cache.HashGetAsync(sessionKey, key);

        // Refresh session timeout on access
        await _cache.KeyExpireAsync(sessionKey, _sessionTimeout);

        return value;
    }

    // Update session
    public async Task UpdateSessionAsync(string sessionId, string key, string value)
    {
        string sessionKey = $"session:{sessionId}";
        await _cache.HashSetAsync(sessionKey, key, value);
        await _cache.KeyExpireAsync(sessionKey, _sessionTimeout);
    }

    // Delete session
    public async Task DeleteSessionAsync(string sessionId)
    {
        string sessionKey = $"session:{sessionId}";
        await _cache.KeyDeleteAsync(sessionKey);
    }

    // Get all session data
    public async Task<Dictionary<string, string>> GetSessionAsync(string sessionId)
    {
        string sessionKey = $"session:{sessionId}";
        var entries = await _cache.HashGetAllAsync(sessionKey);

        if (entries.Length == 0)
            return null;

        await _cache.KeyExpireAsync(sessionKey, _sessionTimeout);

        return entries.ToDictionary(
            e => e.Name.ToString(),
            e => e.Value.ToString());
    }
}
```

üìã Implement session storage for a shopping cart with automatic expiration after 1 hour.

<details>
  <summary>Not sure how?</summary>

```csharp
public class ShoppingCartSession
{
    private readonly IDatabase _cache;
    private const int SessionTimeoutMinutes = 60;

    public async Task SaveCartAsync(string sessionId, List<CartItem> items)
    {
        string key = $"cart:{sessionId}";
        string json = JsonSerializer.Serialize(items);

        await _cache.StringSetAsync(
            key,
            json,
            TimeSpan.FromMinutes(SessionTimeoutMinutes));
    }

    public async Task<List<CartItem>> GetCartAsync(string sessionId)
    {
        string key = $"cart:{sessionId}";
        string json = await _cache.StringGetAsync(key);

        if (string.IsNullOrEmpty(json))
            return new List<CartItem>();

        // Refresh expiration on access
        await _cache.KeyExpireAsync(key, TimeSpan.FromMinutes(SessionTimeoutMinutes));

        return JsonSerializer.Deserialize<List<CartItem>>(json);
    }

    public async Task AddItemAsync(string sessionId, CartItem item)
    {
        var cart = await GetCartAsync(sessionId);
        cart.Add(item);
        await SaveCartAsync(sessionId, cart);
    }

    public async Task ClearCartAsync(string sessionId)
    {
        string key = $"cart:{sessionId}";
        await _cache.KeyDeleteAsync(key);
    }
}
```

</details><br/>

> **AZ-204 Exam Tip:** Session state in Redis:
> - **Distributed**: Shared across multiple web servers
> - **Scalable**: No sticky sessions required
> - **Fast**: In-memory performance
> - **Persistent**: Survives app restarts (with Premium persistence)
> - **Automatic expiration**: TTL ensures cleanup
> - Use ASP.NET Core session middleware or implement custom
> - Store session ID in cookie, data in Redis

## Exercise 4: Redis Data Types and Commands

**AZ-204 Topic:** Understand core Redis data structures.

### String Operations

```csharp
// Set and get string values
await _cache.StringSetAsync("user:1:name", "John Doe");
await _cache.StringSetAsync("user:1:email", "john@example.com");

string name = await _cache.StringGetAsync("user:1:name");

// Increment counter
await _cache.StringSetAsync("page:views", 0);
long views = await _cache.StringIncrementAsync("page:views");
long viewsBy10 = await _cache.StringIncrementAsync("page:views", 10);

// Decrement counter
long decremented = await _cache.StringDecrementAsync("page:views", 5);

// Set with expiration
await _cache.StringSetAsync("temp:token", "abc123", TimeSpan.FromMinutes(15));

// Set if not exists (NX)
bool set = await _cache.StringSetAsync("user:1:lock", "locked", when: When.NotExists);
```

### Hash Operations (Object Storage)

```csharp
// Store object as hash
var user = new
{
    Id = "1",
    Name = "John Doe",
    Email = "john@example.com",
    Age = 30
};

await _cache.HashSetAsync("user:1", new HashEntry[]
{
    new HashEntry("name", user.Name),
    new HashEntry("email", user.Email),
    new HashEntry("age", user.Age)
});

// Get single field
string email = await _cache.HashGetAsync("user:1", "email");

// Get all fields
var entries = await _cache.HashGetAllAsync("user:1");
foreach (var entry in entries)
{
    Console.WriteLine($"{entry.Name}: {entry.Value}");
}

// Get multiple fields
var values = await _cache.HashGetAsync("user:1", new RedisValue[] { "name", "email" });

// Check if field exists
bool exists = await _cache.HashExistsAsync("user:1", "name");

// Delete field
await _cache.HashDeleteAsync("user:1", "age");

// Increment numeric field
await _cache.HashIncrementAsync("user:1", "loginCount", 1);
```

### List Operations (Queues)

```csharp
// Push to list (left/right)
await _cache.ListLeftPushAsync("queue:tasks", "task1");
await _cache.ListLeftPushAsync("queue:tasks", "task2");
await _cache.ListRightPushAsync("queue:tasks", "task3");

// Pop from list
string task = await _cache.ListLeftPopAsync("queue:tasks");
string lastTask = await _cache.ListRightPopAsync("queue:tasks");

// Get list length
long length = await _cache.ListLengthAsync("queue:tasks");

// Get range of elements
var tasks = await _cache.ListRangeAsync("queue:tasks", 0, -1);

// Recent items list (fixed size)
await _cache.ListLeftPushAsync("recent:viewed", "product123");
await _cache.ListTrimAsync("recent:viewed", 0, 9); // Keep last 10
```

### Set Operations (Unique Items)

```csharp
// Add to set
await _cache.SetAddAsync("tags:post:1", "azure");
await _cache.SetAddAsync("tags:post:1", "redis");
await _cache.SetAddAsync("tags:post:1", "cache");
await _cache.SetAddAsync("tags:post:1", "azure"); // Duplicate ignored

// Get all members
var tags = await _cache.SetMembersAsync("tags:post:1");

// Check membership
bool contains = await _cache.SetContainsAsync("tags:post:1", "azure");

// Remove from set
await _cache.SetRemoveAsync("tags:post:1", "cache");

// Set operations (union, intersection, difference)
await _cache.SetAddAsync("user:1:interests", new RedisValue[] { "sports", "music", "tech" });
await _cache.SetAddAsync("user:2:interests", new RedisValue[] { "music", "tech", "art" });

// Intersection (common interests)
var common = await _cache.SetCombineAsync(SetOperation.Intersect, "user:1:interests", "user:2:interests");
```

### Sorted Set Operations (Leaderboards)

```csharp
// Add to sorted set with scores
await _cache.SortedSetAddAsync("leaderboard", "player1", 100);
await _cache.SortedSetAddAsync("leaderboard", "player2", 250);
await _cache.SortedSetAddAsync("leaderboard", "player3", 175);

// Get top scores (descending)
var topPlayers = await _cache.SortedSetRangeByRankWithScoresAsync(
    "leaderboard",
    0, 9,
    Order.Descending);

foreach (var entry in topPlayers)
{
    Console.WriteLine($"{entry.Element}: {entry.Score}");
}

// Get player rank
long? rank = await _cache.SortedSetRankAsync("leaderboard", "player1", Order.Descending);

// Get player score
double? score = await _cache.SortedSetScoreAsync("leaderboard", "player1");

// Increment score
await _cache.SortedSetIncrementAsync("leaderboard", "player1", 50);

// Get by score range
var rangePlayers = await _cache.SortedSetRangeByScoreAsync(
    "leaderboard",
    100, 200);
```

üìã Implement a leaderboard with scores and retrieve top 10 players.

<details>
  <summary>Not sure how?</summary>

```csharp
public class LeaderboardService
{
    private readonly IDatabase _cache;
    private const string LeaderboardKey = "game:leaderboard";

    public async Task AddOrUpdateScoreAsync(string playerId, int score)
    {
        // Add score (automatically replaces if player exists)
        await _cache.SortedSetAddAsync(LeaderboardKey, playerId, score);
    }

    public async Task IncrementScoreAsync(string playerId, int points)
    {
        await _cache.SortedSetIncrementAsync(LeaderboardKey, playerId, points);
    }

    public async Task<List<LeaderboardEntry>> GetTopPlayersAsync(int count = 10)
    {
        var entries = await _cache.SortedSetRangeByRankWithScoresAsync(
            LeaderboardKey,
            0,
            count - 1,
            Order.Descending);

        return entries.Select((e, index) => new LeaderboardEntry
        {
            Rank = index + 1,
            PlayerId = e.Element,
            Score = (int)e.Score
        }).ToList();
    }

    public async Task<LeaderboardEntry> GetPlayerRankAsync(string playerId)
    {
        long? rank = await _cache.SortedSetRankAsync(
            LeaderboardKey,
            playerId,
            Order.Descending);

        double? score = await _cache.SortedSetScoreAsync(LeaderboardKey, playerId);

        if (!rank.HasValue)
            return null;

        return new LeaderboardEntry
        {
            Rank = (int)rank.Value + 1,
            PlayerId = playerId,
            Score = (int)(score ?? 0)
        };
    }
}
```

</details><br/>

> **AZ-204 Exam Tip:** Redis data types:
> - **String**: Simple values, counters, flags
> - **Hash**: Objects with fields (user profiles, products)
> - **List**: Ordered collection (queues, recent items, activity feeds)
> - **Set**: Unique items (tags, followers, unique visitors)
> - **Sorted Set**: Ordered by score (leaderboards, priority queues, time series)
> - Choose appropriate type for use case

## Exercise 5: Persistence Options (Premium Tier)

**AZ-204 Premium Feature:** Configure data persistence for durability.

### Understanding Persistence Options

**RDB (Redis Database Backup):**
- Point-in-time snapshots
- Less frequent, lower overhead
- Good for disaster recovery
- May lose recent data on crash

**AOF (Append-Only File):**
- Logs every write operation
- Better durability (less data loss)
- Higher overhead, larger files
- Slower restart time

### Enable RDB Persistence

```bash
# Enable RDB (snapshot) persistence
az redis patch-schedule set \
  -g labs-redis-az204 \
  -n <premium-redis-name> \
  --schedule-entries '[{"dayOfWeek":"Everyday","startHourUtc":"3","maintenanceWindow":"PT5H"}]'

# Configure RDB persistence policy
az redis update \
  -g labs-redis-az204 \
  -n <premium-redis-name> \
  --set redisConfiguration.rdb-backup-enabled=true \
        redisConfiguration.rdb-backup-frequency=60 \
        redisConfiguration.rdb-storage-connection-string="<storage-connection-string>"
```

### Enable AOF Persistence

```bash
# Enable AOF persistence (more durable)
az redis update \
  -g labs-redis-az204 \
  -n <premium-redis-name> \
  --set redisConfiguration.aof-backup-enabled=true \
        redisConfiguration.aof-storage-connection-string-0="<storage-connection-string>"
```

### Persistence Comparison

```bash
# RDB Settings
# - Backup frequency: 15, 30, 60 minutes
# - Backup to Azure Storage
# - Lower overhead
# - Use for: Disaster recovery, less critical data

# AOF Settings
# - Writes appended to log
# - Backup every 1 second
# - Higher durability (minimal data loss)
# - Use for: Critical data, financial transactions
```

üìã Choose appropriate persistence option for different scenarios.

<details>
  <summary>See Scenarios</summary>

**Scenario 1:** E-commerce shopping cart data
- **Answer:** AOF persistence
- **Reason:** Critical data, customers expect cart to persist

**Scenario 2:** Web page view counters
- **Answer:** RDB or no persistence
- **Reason:** Approximate data, acceptable to lose recent counts

**Scenario 3:** Financial transaction cache
- **Answer:** AOF persistence
- **Reason:** Zero tolerance for data loss

**Scenario 4:** Session state for web application
- **Answer:** RDB persistence
- **Reason:** Balance between durability and performance

**Scenario 5:** Temporary API rate limiting counters
- **Answer:** No persistence
- **Reason:** Transient data, resets acceptable

</details><br/>

> **AZ-204 Exam Tip:** Persistence (Premium only):
> - **RDB**: Periodic snapshots (15/30/60 min), disaster recovery
> - **AOF**: Append-only log, better durability, higher overhead
> - **Both**: Can enable both for maximum protection
> - **None**: Standard/Basic tiers, volatile memory only
> - Backups stored in Azure Storage (additional cost)
> - Consider: Data criticality, performance impact, cost

## Exercise 6: Best Practices for Caching

**AZ-204 Critical:** Apply caching best practices in applications.

### Connection Management

```csharp
// ‚úÖ GOOD: Singleton ConnectionMultiplexer
public class RedisConnectionFactory
{
    private static Lazy<ConnectionMultiplexer> _connection = new Lazy<ConnectionMultiplexer>(() =>
    {
        var config = ConfigurationOptions.Parse(connectionString);
        config.AbortOnConnectFail = false;
        config.ConnectTimeout = 5000;
        config.SyncTimeout = 5000;
        config.ConnectRetry = 3;
        return ConnectionMultiplexer.Connect(config);
    });

    public static ConnectionMultiplexer Connection => _connection.Value;
}

// ‚ùå BAD: Creating new connection for each operation
public async Task<string> GetValue(string key)
{
    using var redis = ConnectionMultiplexer.Connect(connectionString); // DON'T DO THIS
    var db = redis.GetDatabase();
    return await db.StringGetAsync(key);
}
```

### Key Naming Conventions

```csharp
// Use hierarchical naming with colons
string userKey = $"user:{userId}";
string userProfileKey = $"user:{userId}:profile";
string userSettingsKey = $"user:{userId}:settings";
string sessionKey = $"session:{sessionId}";
string cacheKey = $"cache:products:category:{categoryId}";

// Include version for schema changes
string productKey = $"product:v2:{productId}";
```

### Setting Appropriate TTL

```csharp
public class CacheTTLStrategy
{
    // Frequently changing data - short TTL
    public static TimeSpan UserPresence => TimeSpan.FromMinutes(5);

    // Moderately stable data - medium TTL
    public static TimeSpan ProductDetails => TimeSpan.FromMinutes(30);

    // Rarely changing data - long TTL
    public static TimeSpan CategoryList => TimeSpan.FromHours(24);

    // Static/reference data - very long TTL
    public static TimeSpan CountryList => TimeSpan.FromDays(7);

    // Session data
    public static TimeSpan SessionState => TimeSpan.FromMinutes(30);
}
```

### Error Handling and Resilience

```csharp
public class ResilientCacheService
{
    private readonly IDatabase _cache;
    private readonly ILogger _logger;

    public async Task<T> GetOrCreateAsync<T>(
        string key,
        Func<Task<T>> factory,
        TimeSpan expiration)
    {
        try
        {
            // Try to get from cache
            var cached = await _cache.StringGetAsync(key);
            if (cached.HasValue)
            {
                return JsonSerializer.Deserialize<T>(cached);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Cache read failed for key {Key}", key);
            // Continue to factory method
        }

        // Get from source
        var value = await factory();

        // Try to cache (fire-and-forget)
        _ = Task.Run(async () =>
        {
            try
            {
                var serialized = JsonSerializer.Serialize(value);
                await _cache.StringSetAsync(key, serialized, expiration);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Cache write failed for key {Key}", key);
            }
        });

        return value;
    }
}
```

### Batch Operations

```csharp
// ‚úÖ GOOD: Batch operations
public async Task<Dictionary<string, Product>> GetProductsBatchAsync(List<int> productIds)
{
    var keys = productIds.Select(id => new RedisKey($"product:{id}")).ToArray();
    var values = await _cache.StringGetAsync(keys);

    var results = new Dictionary<string, Product>();
    for (int i = 0; i < productIds.Count; i++)
    {
        if (values[i].HasValue)
        {
            results[productIds[i].ToString()] =
                JsonSerializer.Deserialize<Product>(values[i]);
        }
    }

    return results;
}

// ‚ùå BAD: Individual operations in loop
public async Task<Dictionary<string, Product>> GetProductsSlowAsync(List<int> productIds)
{
    var results = new Dictionary<string, Product>();
    foreach (var id in productIds)
    {
        var value = await _cache.StringGetAsync($"product:{id}");
        if (value.HasValue)
        {
            results[id.ToString()] = JsonSerializer.Deserialize<Product>(value);
        }
    }
    return results;
}
```

### Cache Invalidation Strategies

```csharp
public class CacheInvalidation
{
    private readonly IDatabase _cache;

    // Strategy 1: TTL-based expiration (passive)
    public async Task SetWithTTL(string key, string value)
    {
        await _cache.StringSetAsync(key, value, TimeSpan.FromMinutes(30));
    }

    // Strategy 2: Explicit invalidation on update
    public async Task UpdateAndInvalidate(Product product)
    {
        await UpdateDatabase(product);
        await _cache.KeyDeleteAsync($"product:{product.Id}");
    }

    // Strategy 3: Tag-based invalidation
    public async Task InvalidateByTag(string tag)
    {
        // Get all keys with tag
        var keys = await _cache.SetMembersAsync($"tag:{tag}");
        foreach (var key in keys)
        {
            await _cache.KeyDeleteAsync(key.ToString());
        }
        await _cache.KeyDeleteAsync($"tag:{tag}");
    }

    // Strategy 4: Version-based cache keys
    public async Task<Product> GetWithVersion(int productId, int version)
    {
        string key = $"product:{productId}:v{version}";
        var cached = await _cache.StringGetAsync(key);
        // Old versions automatically become unreachable
        return cached.HasValue ?
            JsonSerializer.Deserialize<Product>(cached) : null;
    }
}
```

üìã Implement a caching service with proper error handling and TTL management.

<details>
  <summary>Not sure how?</summary>

```csharp
public class CachingService
{
    private readonly IDatabase _cache;
    private readonly ILogger<CachingService> _logger;

    public async Task<T> GetOrSetAsync<T>(
        string key,
        Func<Task<T>> fetchFunc,
        TimeSpan? expiration = null)
    {
        expiration ??= TimeSpan.FromMinutes(30);

        // Try to get from cache
        try
        {
            var cached = await _cache.StringGetAsync(key);
            if (cached.HasValue)
            {
                _logger.LogInformation("Cache hit for key: {Key}", key);
                return JsonSerializer.Deserialize<T>(cached);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error reading from cache for key: {Key}", key);
        }

        // Cache miss - fetch from source
        _logger.LogInformation("Cache miss for key: {Key}", key);
        var value = await fetchFunc();

        // Store in cache
        try
        {
            var serialized = JsonSerializer.Serialize(value);
            await _cache.StringSetAsync(key, serialized, expiration);
            _logger.LogInformation("Cached value for key: {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error writing to cache for key: {Key}", key);
            // Continue even if caching fails
        }

        return value;
    }

    public async Task InvalidateAsync(string key)
    {
        try
        {
            await _cache.KeyDeleteAsync(key);
            _logger.LogInformation("Invalidated cache key: {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error invalidating cache key: {Key}", key);
        }
    }
}
```

</details><br/>

> **AZ-204 Exam Tip:** Best practices:
> - **Connection**: Reuse ConnectionMultiplexer (singleton)
> - **TTL**: Always set expiration, choose based on data volatility
> - **Keys**: Use hierarchical naming (colon-separated)
> - **Error Handling**: Graceful degradation if cache unavailable
> - **Batch**: Use batch operations for multiple keys
> - **Monitor**: Track cache hit/miss ratio
> - **Invalidation**: Clear stale data (TTL or explicit)
> - **Security**: Use SSL, firewall rules, private endpoints (Premium)

## AZ-204 Exam Study Points

### Key Concepts to Master

1. **Cache Tiers:**
   - Basic: Dev/test, no SLA, single node
   - Standard: Production, 99.9% SLA, replication
   - Premium: Enterprise, 99.95% SLA, clustering, persistence, VNet

2. **Cache-Aside Pattern:**
   - Check cache first
   - On miss: fetch from source, populate cache
   - On write: update source, invalidate cache
   - Application manages caching logic

3. **Session State:**
   - Distributed across web servers
   - Automatic expiration with TTL
   - ASP.NET Core integration
   - Store session ID in cookie, data in Redis

4. **Data Types:**
   - String: Simple values, counters
   - Hash: Objects with fields
   - List: Ordered collections, queues
   - Set: Unique items
   - Sorted Set: Ordered by score (leaderboards)

5. **Persistence (Premium):**
   - RDB: Snapshots (15/30/60 min)
   - AOF: Append-only log (better durability)
   - Both: Maximum protection
   - Storage cost additional

6. **Best Practices:**
   - Singleton ConnectionMultiplexer
   - Set appropriate TTL
   - Hierarchical key naming
   - Graceful error handling
   - Batch operations
   - Monitor metrics

### Common Exam Scenarios

1. **Scenario:** Reduce database load for frequently queried product data
   - **Solution:** Implement cache-aside pattern with appropriate TTL

2. **Scenario:** Store user session across multiple web servers
   - **Solution:** Use Redis as distributed session store

3. **Scenario:** Implement real-time leaderboard for game
   - **Solution:** Use Redis sorted set with scores

4. **Scenario:** Cache needs to survive restarts and failures
   - **Solution:** Use Premium tier with persistence (RDB or AOF)

5. **Scenario:** Application needs to scale elastically with traffic
   - **Solution:** Standard tier with auto-scaling web app

6. **Scenario:** Choose cache tier for production workload
   - **Solution:** Standard (basic features) or Premium (advanced features)

### Common Mistakes to Avoid

1. ‚ùå Creating new ConnectionMultiplexer for each operation
2. ‚ùå Not setting TTL (cache grows indefinitely)
3. ‚ùå Ignoring cache failures (doesn't degrade gracefully)
4. ‚ùå Using Basic tier for production
5. ‚ùå Not monitoring cache metrics
6. ‚ùå Storing large objects without considering size limits
7. ‚ùå Not using batch operations for multiple keys

## Cleanup

```bash
az group delete -y -n labs-redis-az204 --no-wait
```

## Additional Resources

- [Azure Cache for Redis documentation](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/)
- [StackExchange.Redis documentation](https://stackexchange.github.io/StackExchange.Redis/)
- [Cache-Aside pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)
- [Session state in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state)
- [Redis data types](https://redis.io/docs/data-types/)
- [AZ-204 Study Guide](https://learn.microsoft.com/en-us/credentials/certifications/resources/study-guides/az-204)
